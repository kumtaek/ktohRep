# 구현 설명

이 문서는 소스 분석 에이전트의 특정 기능들에 대한 상세한 구현 설명을 제공합니다.

## 1. 시퀀스 다이어그램 구현 - 메서드 호출 흐름 시각화

시퀀스 다이어그램은 `visualize/builders/sequence_diagram.py`와 `visualize/builders/enhanced_sequence_diagram.py` 파일에 의해 구현됩니다.

### 1.1. 기본 시퀀스 다이어그램 (`sequence_diagram.py`)

`sequence_diagram.py`의 `build_sequence_graph_json` 함수는 다음 단계를 통해 UML 시퀀스 다이어그램 JSON 데이터를 생성합니다.

1.  **엣지(Edge) 데이터 로드**: 데이터베이스에서 `call`, `call_unresolved`, `use_table`, `call_sql` 등 메서드 호출 및 SQL 사용과 관련된 모든 엣지를 가져옵니다. 만약 특정 엣지 타입이 없으면, `call`, `use`, `invoke`, `include`, `depend`, `relation` 키워드를 포함하는 다른 엣지 타입을 찾아 사용합니다.
2.  **시작점 탐색 (`_find_start_nodes`)**: `start_file` 및 `start_method` 인자를 기반으로 시퀀스 다이어그램의 시작 노드를 찾습니다.
    *   `start_file`이 제공되면 해당 파일 내의 메서드를 탐색합니다.
    *   `start_method`가 제공되면 해당 파일 내의 특정 메서드를 시작점으로 사용합니다.
    *   만약 시작 노드를 찾지 못하면, JSP 파일에서 SQL 유닛, 그리고 테이블로 이어지는 `JSP->SQL->Table` 기본 시퀀스 (`_build_jsp_sql_sequence`)를 폴백(fallback)으로 생성합니다.
3.  **UML 시퀀스 다이어그램 빌드 (`_build_uml_sequence_diagram`)**:
    *   **인접성 맵 생성**: 로드된 엣지들을 기반으로 호출 관계의 인접성 맵을 만듭니다. `dst_id`가 없는 `call_unresolved` 엣지의 경우, `meta` 데이터의 `called_name`과 `callee_qualifier_type`을 분석하여 대상 메서드를 추정하거나 `unresolved` 가상 노드를 생성합니다.
    *   **참여자(Participants) 및 상호작용(Interactions) 추적**: BFS(너비 우선 탐색) 알고리즘을 사용하여 `max_depth` 및 `max_nodes` 제한 내에서 호출 트리를 탐색합니다. 각 노드는 참여자(participant)가 되고, 엣지는 상호작용(interaction)이 됩니다.
    *   **미해결 호출 처리**: `call_unresolved` 엣지나 가상 노드는 점선 스타일로 표시하여 미해결 상태임을 나타냅니다.
    *   **Mermaid 문법 생성**: 최종적으로 Mermaid 시퀀스 다이어그램 문법을 생성하여 시각화 도구에서 렌더링할 수 있도록 합니다.
    *   **단일 노드 예외 처리**: 참여자가 1개 이하인 경우 시퀀스 다이어그램을 생성하지 않습니다.
    *   **상호작용 없는 경우 폴백**: 메서드 호출이 발견되지 않으면 참여자 순서 기반의 단순 시퀀스 흐름을 생성합니다.

### 1.2. 강화된 시퀀스 다이어그램 (`enhanced_sequence_diagram.py`)

`enhanced_sequence_diagram.py`의 `build_automatic_sequence_diagrams` 함수는 다음을 통해 자동화된 시퀀스 다이어그램 생성을 제공합니다.

1.  **엣지 메타데이터 분석 및 복구 (`_repair_edge_metadata`)**: 데이터베이스의 엣지 중 `src_id` 또는 `dst_id`가 누락된 경우, 엣지의 `meta` 데이터를 분석하여 해당 ID를 복구하려고 시도합니다. 특히 `src_method_fqn`, `called_name`, `callee_qualifier_type` 정보를 활용하여 메서드 ID를 해결합니다.
2.  **자동 진입점 탐색 (`_discover_entry_points`)**: 다음 전략들을 사용하여 시퀀스 다이어그램의 잠재적 시작점(entry points)을 자동으로 찾아냅니다.
    *   **컨트롤러 메서드**: `@Controller` 또는 `Controller` 이름을 포함하는 클래스의 메서드 (높은 우선순위)
    *   **서비스 진입 메서드**: `Service` 이름을 포함하는 클래스의 메서드 중 외부 호출이 있는 경우
    *   **`main` / 테스트 메서드**: `main` 메서드 (최고 우선순위) 및 `test`로 시작하는 메서드
    *   **높은 활동성 메서드**: 나가는 호출(outgoing calls)이 많은 메서드
    *   중복을 제거하고 우선순위에 따라 정렬하여 최적의 진입점을 선택합니다.
3.  **시퀀스 다이어그램 생성**: 발견된 각 진입점에 대해 `_build_sequence_from_entry_point` 함수를 호출하여 시퀀스 다이어그램을 생성합니다. 이 과정에서 `_build_enhanced_sequence_diagram` 함수가 호출되어 미해결 호출에 대한 가상 노드 생성 등 더욱 견고한 시퀀스 빌딩 로직을 수행합니다.

## 2. 테이블, 컬럼 Enhanced Comment 구현

테이블 및 컬럼에 대한 강화된 주석(Enhanced Comment) 기능은 LLM을 활용하여 JSP, Java, SQL 코드의 컨텍스트를 분석하고 데이터베이스 메타데이터를 보강하는 방식으로 구현됩니다. 주요 관련 파일은 `phase1/llm/enricher.py`, `phase1/tools/llm_analyzer.py`, `phase1/llm/summarizer.py` (간접적으로), `phase1/database/metadata_enhancement_engine.py` 등입니다.

### 2.1. LLM 분석 도구 (`llm_analyzer.py`)

`llm_analyzer.py`는 LLM 기반 분석의 메인 진입점입니다. `enhance_db_comments` 함수는 다음 역할을 수행합니다.

1.  **설정 로드 및 로깅**: 프로젝트별 설정을 로드하고, 데이터베이스 주석 강화 전용 로깅을 설정합니다.
2.  **`CodeSummarizer` 초기화**: `llm/summarizer.py`의 `CodeSummarizer` 클래스를 초기화합니다. 이 클래스는 실제 LLM 호출을 관리하고 다양한 코드 요소에 대한 요약을 생성하는 역할을 합니다.
3.  **테이블 주석 처리**: `summarizer.process_table_comments(batch_size)`를 호출하여 데이터베이스 테이블 및 컬럼에 대한 주석 강화 프로세스를 시작합니다.

### 2.2. LLM 텍스트 생성 유틸리티 (`llm/enricher.py`)

`llm/enricher.py` 파일은 LLM을 사용하여 텍스트를 생성하는 핵심 유틸리티를 제공합니다.

*   `generate_text` 함수는 시스템 프롬프트와 사용자 프롬프트를 받아 LLM 클라이언트(`llm/client.py`에서 가져옴)를 통해 텍스트를 생성합니다. `dry_run` 모드를 지원하여 실제 LLM 호출 없이 스텁(stub) 응답을 반환할 수 있습니다.
*   이 함수는 `llm_analyzer.py`나 `summarizer.py`에서 데이터베이스 주석을 생성하거나 보강하기 위한 실제 LLM 호출에 사용됩니다. 예를 들어, 특정 테이블이나 컬럼이 사용된 JSP, Java, SQL 코드 스니펫을 LLM에 전달하고, 해당 요소의 역할이나 의미에 대한 설명을 요청하여 주석으로 활용할 수 있습니다.

### 2.3. 데이터베이스 메타데이터 강화 엔진 (`phase1/database/metadata_enhancement_engine.py` - 추정)

`llm_analyzer.py`에서 `summarizer.process_table_comments()`가 호출되면, 내부적으로 `metadata_enhancement_engine.py` (또는 유사한 역할을 하는 모듈)가 데이터베이스 메타데이터를 LLM으로 강화하는 로직을 담당할 것으로 추정됩니다. 이 모듈은 다음을 수행할 것입니다.

1.  **데이터베이스 스키마 로드**: 현재 데이터베이스의 테이블 및 컬럼 정보를 로드합니다.
2.  **관련 코드 컨텍스트 수집**: 각 테이블 및 컬럼이 사용되는 JSP, Java, SQL 코드 스니펫을 데이터베이스에서 조회합니다. (예: `use_table` 엣지, SQL 유닛 내의 테이블/컬럼 참조 등을 통해)
3.  **LLM 호출**: 수집된 코드 컨텍스트와 테이블/컬럼 정보를 `llm/enricher.py`의 `generate_text` 함수를 통해 LLM에 전달합니다. LLM에게 해당 테이블/컬럼의 비즈니스 로직, 목적, 사용 예시 등에 대한 설명을 요청합니다.
4.  **주석 업데이트**: LLM이 생성한 설명을 바탕으로 데이터베이스의 테이블/컬럼 주석을 업데이트하거나 새로운 주석을 추가합니다. 이 과정에서 기존 주석과의 병합, 신뢰도 점수 부여 등의 로직이 포함될 수 있습니다.

## 3. 파싱 라이브러리 (javalang, tree_sitter) 폴백 구조 여부

`E:/SourceAnalyzer.git/phase1/parsers/java_parser.py` 파일을 분석한 결과, **`javalang`과 `tree_sitter`는 폴백(fallback) 구조로 사용됩니다.**

구체적인 동작 방식은 다음과 같습니다.

1.  **초기화**: `JavaParser` 클래스 초기화 시 `javalang`과 `tree_sitter` 모듈의 임포트 여부를 확인하고, `tree_sitter`가 사용 가능하면 Java 언어 문법으로 파서를 설정합니다.
2.  **파서 선택 로직**: `parse_file` 메서드 내에서 `_select_parser` 헬퍼 함수를 통해 사용할 파서를 결정합니다.
    *   설정(`config`)에 `java.parser_type`이 `tree-sitter`로 지정되어 있고 `tree_sitter` 파서가 성공적으로 초기화되었다면 `tree_sitter`를 사용합니다.
    *   설정에 `java.parser_type`이 `javalang`으로 지정되어 있고 `javalang` 모듈이 임포트되었다면 `javalang`을 사용합니다.
    *   **폴백**: 만약 위에서 지정된 파서가 없거나 초기화에 실패했다면, **사용 가능한 파서를 우선적으로 선택합니다.** 즉, `tree_sitter`가 사용 가능하면 `tree_sitter`를, 그렇지 않고 `javalang`이 사용 가능하면 `javalang`을 사용합니다.
    *   두 파서 모두 사용 불가능하면 파싱을 수행하지 않고 경고 메시지를 출력합니다.
3.  **AST 추출**: 선택된 파서(`javalang` 또는 `tree_sitter`)를 사용하여 Java 소스 코드의 AST(Abstract Syntax Tree)를 생성하고, 이를 기반으로 클래스, 메서드, 엣지 정보를 추출합니다.

요약하자면, `java_parser.py`는 설정에 따라 선호하는 파서를 사용하려 시도하고, 실패할 경우 다른 파서로 전환하는 **견고한 폴백 메커니즘**을 갖추고 있습니다.

## 4. `README*.md`, `QuickStart.md`, `개발소스 개요.md` 현행화 및 새로운 기능 실행 스크립트 포함

기존 문서들을 현행화하고 새로운 기능 실행 스크립트를 포함하는 방안은 다음과 같습니다.

### 4.1. 문서 현행화 방안

*   **내용 업데이트**: 위에서 요약된 "소스 분석 에이전트 기능 요약" 및 "구현 설명" 내용을 바탕으로 각 문서의 관련 섹션을 업데이트합니다.
    *   `README.md`: 프로젝트의 최신 기능 개요를 반영합니다.
    *   `README_detailed.md`: 각 기능에 대한 좀 더 상세한 설명을 추가합니다.
    *   `QuickStart.md`: 새로운 기능들을 빠르게 시작할 수 있는 가이드와 예시를 추가합니다.
    *   `개발소스 개요.md`: 개발 관점에서 각 기능의 아키텍처 및 구현 세부 사항을 업데이트합니다.
*   **스크립트 예시 추가**: 각 문서의 적절한 위치에 새로운 기능을 실행하는 `.bat` 스크립트 예시를 포함합니다.

### 4.2. 새로운 기능 실행 스크립트 (예시)

`llm_analyzer.py`의 `main` 함수에 정의된 서브커맨드들을 기반으로 새로운 기능들을 실행하는 스크립트를 추가할 수 있습니다.

**LLM 기반 분석 및 강화 기능 실행 스크립트:**

*   **코드 요소 요약**:
    ```bash
    python E:\SourceAnalyzer.git\phase1\tools\llm_analyzer.py summarize --project-name [프로젝트명] --batch-size 10
    ```
*   **데이터베이스 주석 강화**:
    ```bash
    python E:\SourceAnalyzer.git\phase1\tools\llm_analyzer.py enhance-db --project-name [프로젝트명] --batch-size 10
    ```
*   **SQL 조인 조건 분석**:
    ```bash
    python E:\SourceAnalyzer.git\phase1\tools\llm_analyzer.py analyze-joins --project-name [프로젝트명] --batch-size 10
    ```
*   **전체 LLM 분석 (요약, DB 강화, 조인 분석, 명세서 생성)**:
    ```bash
    python E:\SourceAnalyzer.git\phase1\tools\llm_analyzer.py full-analysis --project-name [프로젝트명] --batch-size 10 --output E:\SourceAnalyzer.git\output\[프로젝트명]\
    ```
    *   이 스크립트는 `테이블명세서.md`와 `소스코드명세서.md`를 지정된 `output` 디렉토리에 생성합니다.

**시각화 기능 실행 스크립트:**

시퀀스 다이어그램 및 기타 시각화 기능은 `visualize/cli.py`를 통해 실행될 것으로 예상됩니다. (현재 `visualize/cli.py` 파일 내용은 읽지 않았지만, 일반적인 CLI 구조를 가정합니다.)

*   **자동 시퀀스 다이어그램 생성 (강화된 기능)**:
    ```bash
    python E:\SourceAnalyzer.git\visualize\cli.py generate-sequence-diagrams --project-name [프로젝트명] --max-diagrams 5 --depth 3 --max-nodes 50
    ```
    *   이 스크립트는 `enhanced_sequence_diagram.py`의 `build_automatic_sequence_diagrams` 함수를 호출하여 여러 개의 시퀀스 다이어그램을 자동으로 생성합니다.

*   **특정 파일/메서드 기반 시퀀스 다이어그램 생성 (기본 기능)**:
    ```bash
    python E:\SourceAnalyzer.git\visualize\cli.py generate-sequence-diagram --project-name [프로젝트명] --start-file "src/main/java/com/example/MyController.java" --start-method "myMethod" --depth 3
    ```
    *   이 스크립트는 `sequence_diagram.py`의 `build_sequence_graph_json` 함수를 호출하여 특정 시작점에서 시퀀스 다이어그램을 생성합니다.

**기존 스크립트 현행화:**

기존 `run_*.bat` 파일들도 위 새로운 기능들을 호출하도록 업데이트하거나, 새로운 기능 전용 `.bat` 파일을 추가할 수 있습니다. 예를 들어, `run_auto_sequence.bat` 파일은 `generate-sequence-diagrams` 명령을 호출하도록 업데이트될 수 있습니다.

---

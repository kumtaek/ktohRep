# 수작업분석 초과 관계 분석 보고서

**작성일**: 2025-01-19 20:00  
**분석 대상**: 메타DB 관계 632개 vs 수작업 분석 117개 (540% 초과)  
**목적**: 불필요한 관계 식별 및 품질 개선 방안 제시

## 📊 초과 관계 현황

### **전체 관계 비교**
- **수작업 분석**: 117개 관계
- **메타DB 생성**: 632개 관계  
- **초과율**: 540% (515개 초과)

### **관계 유형별 초과 현황**
| 관계 유형 | 수작업 | 메타DB | 초과율 | 초과량 |
|-----------|--------|--------|--------|--------|
| **calls** | 112개 | 485개 | **433%** | 373개 |
| **dependency** | 56개 | 56개 | 100% | 0개 |
| **foreign_key** | 13개 | 16개 | 123% | 3개 |
| **implements** | 6개 | 6개 | 100% | 0개 |
| **imports** | 69개 | 69개 | 100% | 0개 |

## 🔍 불필요한 관계 분석

### **1. calls 관계의 과다 생성 (485개)**

#### **문제 1: Java 키워드 오인식 (157개)**
```
if|157  ← 가장 많이 호출된 "메서드"
```
**문제점**: 
- `if` 문을 메서드 호출로 오인식
- 실제로는 Java 키워드이므로 관계가 아님
- 정규식 패턴 `r'(\w+)\s*\(\s*[^)]*\)'`이 너무 광범위함

**예시**:
```java
if (name != null && !name.trim().isEmpty()) {  // if를 메서드로 오인식
    params.put("name", "%" + name.trim() + "%");
}
```

#### **문제 2: 기본 메서드 오인식 (27개)**
```
equals|13
toString|1
hashCode|1
setName|6
setEmail|5
getId|4
getName|5
```
**문제점**:
- Object 클래스의 기본 메서드들
- getter/setter 메서드들
- 실제 비즈니스 로직과 무관한 관계

#### **문제 3: 중복 관계 생성**
```
getUserById|9  ← 동일한 메서드가 여러 번 호출되어 중복 생성
createUser|7
updateProductStock|6
```

### **2. 정규식 패턴의 문제점**

#### **현재 사용 중인 문제 패턴들**:
```python
# 너무 광범위한 패턴
r'(\w+)\s*\(\s*[^)]*\)'  # 모든 괄호가 있는 단어를 메서드로 인식

# Java 키워드도 메서드로 인식
r'this\.(\w+)\s*\('      # this.methodName() 패턴
r'super\.(\w+)\s*\('     # super.methodName() 패턴
```

#### **문제가 되는 코드 예시**:
```java
// 1. if 문 오인식
if (condition) { ... }

// 2. 생성자 호출 오인식  
new HashMap<>()

// 3. 타입 캐스팅 오인식
(User) object

// 4. 배열 접근 오인식
array[index]
```

## 🎯 불필요한 관계 제거 방안

### **1. Java 키워드 필터링**
```python
# Java 키워드 목록
JAVA_KEYWORDS = {
    'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'break', 'continue',
    'return', 'try', 'catch', 'finally', 'throw', 'throws', 'new', 'this',
    'super', 'static', 'final', 'abstract', 'public', 'private', 'protected',
    'class', 'interface', 'extends', 'implements', 'import', 'package'
}

def _is_java_keyword(self, word: str) -> bool:
    return word in JAVA_KEYWORDS
```

### **2. 메서드 호출 패턴 개선**
```python
# 개선된 정규식 패턴
method_call_patterns = [
    # 객체.메서드() 패턴만 허용
    r'(\w+)\.(\w+)\s*\(',  # object.method()
    # this.메서드() 패턴
    r'this\.(\w+)\s*\(',   # this.method()
    # super.메서드() 패턴  
    r'super\.(\w+)\s*\('   # super.method()
]

# 단독 메서드 호출은 제외
# r'(\w+)\s*\(\s*[^)]*\)'  # 제거
```

### **3. 기본 메서드 필터링**
```python
# Object 클래스 기본 메서드 제외
OBJECT_METHODS = {'toString', 'equals', 'hashCode', 'getClass', 'notify', 'notifyAll', 'wait'}

# getter/setter 메서드 제외 (선택적)
GETTER_SETTER_PATTERNS = [
    r'^get[A-Z]',  # getXxx
    r'^set[A-Z]',  # setXxx  
    r'^is[A-Z]'    # isXxx
]
```

### **4. 중복 관계 제거**
```python
# 동일한 관계는 한 번만 생성
existing_relationships = set()
for relationship in relationships:
    key = (src_id, dst_id, relationship_type)
    if key not in existing_relationships:
        existing_relationships.add(key)
        # 관계 생성
```

## 📈 개선 후 예상 결과

### **calls 관계 개선 예상**
- **현재**: 485개
- **개선 후**: 약 150-200개 (60% 감소)
- **제거될 관계**: 285-335개

### **제거될 관계 유형**
1. **Java 키워드 오인식**: 157개 → 0개
2. **기본 메서드 오인식**: 27개 → 0개  
3. **중복 관계**: 50-100개 → 0개
4. **잘못된 패턴 매칭**: 50-100개 → 0개

### **최종 예상 관계 수**
- **calls**: 150-200개 (현재 485개에서 60% 감소)
- **전체 관계**: 300-350개 (현재 632개에서 45% 감소)
- **수작업 대비**: 250-300% (현재 540%에서 개선)

## 🔧 구현 우선순위

### **1단계: Java 키워드 필터링 (즉시 적용)**
- 가장 많은 노이즈 제거 (157개)
- 구현 난이도: 낮음
- 효과: 높음

### **2단계: 메서드 호출 패턴 개선**
- 정규식 패턴 정교화
- 구현 난이도: 중간
- 효과: 중간

### **3단계: 중복 관계 제거**
- 동일 관계 중복 생성 방지
- 구현 난이도: 낮음
- 효과: 중간

### **4단계: 기본 메서드 필터링**
- Object 메서드, getter/setter 제외
- 구현 난이도: 낮음
- 효과: 낮음

## 📝 결론

### **주요 문제점**
1. **Java 키워드 오인식**: `if` 문을 메서드로 인식 (157개)
2. **과도한 정규식 패턴**: 너무 광범위한 매칭
3. **중복 관계 생성**: 동일한 관계가 여러 번 생성
4. **기본 메서드 포함**: 비즈니스 로직과 무관한 관계

### **개선 효과**
- **관계 수**: 632개 → 300-350개 (45% 감소)
- **품질 향상**: 의미 있는 관계만 유지
- **수작업 대비**: 540% → 250-300% (개선)

### **권장사항**
1. **즉시 적용**: Java 키워드 필터링
2. **단계적 개선**: 정규식 패턴 정교화
3. **지속적 모니터링**: 관계 품질 검증

**현재 540% 초과는 대부분 노이즈 관계이며, 개선을 통해 수작업 분석 수준에 근접한 고품질 관계를 생성할 수 있습니다.**

super_fqn 및 interfaces 열 추가
8월 31일
금택/ktohRep
주인
+74
-4

아카이브에 보관

공유하기

PR 만들기


1. `phase1/models/database.py`의 `Class` 모델에 `super_fqn`(문자열)과 `interfaces`(JSON/텍스트) 컬럼을 추가한다.
2. 마이그레이션 스크립트를 작성해 기존 DB에 새 컬럼을 반영한다.
3. `phase1/parsers/java_parser.py`의 클래스 추출 로직에서 `node.extends`와 `node.implements` 정보를 파싱해 위 컬럼에 저장한다.

복사
요약
슈퍼클래스 이름을 저장하고 인터페이스를 구현하기 위해 모델 에 열을 super_fqn추가 했습니다 .interfacesClass

extendsjavalang과 Tree-sitter를 통해 정보를 캡처 하고 implements새 필드에 영구적으로 저장하도록 Java 파서를 업데이트했습니다 .

classes테이블 에 새 열을 추가하여 기존 데이터베이스를 변경하기 위한 마이그레이션 스크립트를 생성했습니다.

diff --git a/phase1/models/database.py b/phase1/models/database.py
index 437b3cc965314363c87398cf4704c8264de1a0ce..ea093627602719c40d861d7f1680c7e4218a0b4a 100644
--- a/phase1/models/database.py
+++ b/phase1/models/database.py
@@ -32,50 +32,52 @@ class File(Base):
     
     file_id = Column(Integer, primary_key=True)
     project_id = Column(Integer, ForeignKey('projects.project_id'), nullable=False)
     path = Column(Text, nullable=False)
     language = Column(String(50))
     hash = Column(String(64))  # SHA-256 hash for change detection
     loc = Column(Integer)  # Lines of code
     mtime = Column(DateTime)  # Modification time
     
     # Relationships
     project = relationship("Project", back_populates="files")
     classes = relationship("Class", back_populates="file", cascade="all, delete-orphan")
     sql_units = relationship("SqlUnit", back_populates="file", cascade="all, delete-orphan")
 
 class Class(Base):
     __tablename__ = 'classes'
     
     class_id = Column(Integer, primary_key=True)
     file_id = Column(Integer, ForeignKey('files.file_id'), nullable=False)
     fqn = Column(Text)  # Fully qualified name
     name = Column(String(255), nullable=False)
     start_line = Column(Integer)
     end_line = Column(Integer)
     modifiers = Column(Text)  # JSON array of modifiers
     annotations = Column(Text)  # JSON array of annotations
+    super_fqn = Column(Text)  # Fully qualified name of superclass
+    interfaces = Column(Text)  # JSON array of implemented interfaces
     
     # Relationships  
     file = relationship("File", back_populates="classes")
     methods = relationship("Method", back_populates="class_", cascade="all, delete-orphan")
 
 class Method(Base):
     __tablename__ = 'methods'
     
     method_id = Column(Integer, primary_key=True)
     class_id = Column(Integer, ForeignKey('classes.class_id'), nullable=False)
     name = Column(String(255), nullable=False)
     signature = Column(Text)
     return_type = Column(String(255))
     start_line = Column(Integer)
     end_line = Column(Integer)
     annotations = Column(Text)  # JSON array of annotations
     parameters = Column(Text)   # JSON or string-joined parameter list
     modifiers = Column(Text)    # JSON array of modifiers
     
     # Relationships
     class_ = relationship("Class", back_populates="methods")
 
 class SqlUnit(Base):
     __tablename__ = 'sql_units'
     


diff --git a/phase1/parsers/java_parser.py b/phase1/parsers/java_parser.py
index 419b23f9d10a5e1f4ac7aa9f4ad4383630b32f1b..5b8e05b2192fcf4ca1ccfb5486f290fa863705b8 100644
--- a/phase1/parsers/java_parser.py
+++ b/phase1/parsers/java_parser.py
@@ -190,58 +190,63 @@ class JavaParser:
             
     def _extract_class(self, node: javalang.tree.ClassDeclaration, file_obj: File, path: List) -> Tuple[Class, List[Method], List[Edge]]:
         """
         클래스 정보와 메서드들을 추출
         
         Args:
             node: 클래스 선언 AST 노드
             file_obj: 파일 객체
             path: AST 경로
             
         Returns:
             (Class, Methods, Edges) 튜플
         """
         
         # 완전한 클래스명 구성
         package_name = self._get_package_name(path)
         fqn = f"{package_name}.{node.name}" if package_name else node.name
         
         # 수식어와 어노테이션 추출
         modifiers = [mod for mod in node.modifiers] if node.modifiers else []
         annotations = self._extract_annotations(node.annotations)
         
         # 라인 번호 추정 (javalang은 정확한 위치 정보를 제공하지 않음)
         start_line, end_line = self._estimate_line_numbers(node, file_obj)
         
+        super_fqn = self._get_type_string(node.extends) if node.extends else None
+        interfaces = [self._get_type_string(i) for i in node.implements] if node.implements else []
+
         class_obj = Class(
             file_id=None,  # Will be set after file is saved
             fqn=fqn,
             name=node.name,
             start_line=start_line,
             end_line=end_line,
             modifiers=json.dumps(modifiers),
-            annotations=json.dumps(annotations)
+            annotations=json.dumps(annotations),
+            super_fqn=super_fqn,
+            interfaces=json.dumps(interfaces)
         )
         
         methods = []
         edges = []
         
         # Extract fields to resolve method calls later
         fields = {}
         if hasattr(node, 'body') and node.body:
             for member in node.body:
                 if isinstance(member, javalang.tree.FieldDeclaration):
                     field_type = self._get_type_string(member.type)
                     for declarator in member.declarators:
                         fields[declarator.name] = field_type
 
         # Extract methods
         if hasattr(node, 'body') and node.body:
             for member in node.body:
                 if isinstance(member, javalang.tree.MethodDeclaration):
                     method_obj, method_edges = self._extract_method(member, class_obj, fields)
                     methods.append(method_obj)
                     edges.extend(method_edges)
                 elif isinstance(member, javalang.tree.ConstructorDeclaration):
                     constructor_obj, constructor_edges = self._extract_constructor(member, class_obj)
                     methods.append(constructor_obj)
                     edges.extend(constructor_edges)
diff --git a/phase1/parsers/java_parser.py b/phase1/parsers/java_parser.py
index 419b23f9d10a5e1f4ac7aa9f4ad4383630b32f1b..5b8e05b2192fcf4ca1ccfb5486f290fa863705b8 100644
--- a/phase1/parsers/java_parser.py
+++ b/phase1/parsers/java_parser.py
@@ -756,84 +761,116 @@ class JavaParser:
             results.extend(self._find_nodes_by_type(child, node_type))
             
         return results
     
     def _extract_class_from_tree_sitter(self, class_node, file_obj: File, lines: List[str], package_name: Optional[str] = None) -> Tuple[Optional[Class], List[Method], List[Edge]]:
         """
         Tree-sitter 노드에서 클래스 정보 추출
         """
         try:
             # 클래스 이름 추출
             name_node = None
             for child in class_node.children:
                 if child.type == 'identifier':
                     name_node = child
                     break
                     
             if not name_node:
                 return None, [], []
                 
             class_name = self._get_node_text(name_node, lines)
             
             # 위치 정보
             start_line = class_node.start_point[0] + 1  # 0-based to 1-based
             end_line = class_node.end_point[0] + 1
             
-            # 클래스 객체 생성
+            super_fqn = None
+            interfaces: List[str] = []
+            superclass_nodes = [c for c in class_node.children if c.type == 'superclass']
+            if superclass_nodes:
+                tnodes = self._find_nodes_by_type(superclass_nodes[0], 'type')
+                if tnodes:
+                    super_fqn = self._get_node_text(tnodes[0], lines)
+            interface_nodes = [c for c in class_node.children if c.type == 'super_interfaces']
+            if interface_nodes:
+                tnodes = self._find_nodes_by_type(interface_nodes[0], 'type')
+                interfaces = [self._get_node_text(t, lines) for t in tnodes]
+
             class_obj = Class(
                 file_id=None,
                 fqn=f"{package_name}.{class_name}" if package_name else class_name,
                 name=class_name,
                 start_line=start_line,
                 end_line=end_line,
                 modifiers=json.dumps(self._extract_modifiers(class_node, lines)),
-                annotations=json.dumps(self._extract_annotations_ts(class_node, lines))
+                annotations=json.dumps(self._extract_annotations_ts(class_node, lines)),
+                super_fqn=super_fqn,
+                interfaces=json.dumps(interfaces)
             )
             
             methods = []
             edges = []
             
             # 메서드 추출
             method_nodes = self._find_nodes_by_type(class_node, 'method_declaration')
             for method_node in method_nodes:
                 method_obj, method_edges = self._extract_method_from_tree_sitter(
                     method_node, class_obj, lines
                 )
                 if method_obj:
                     methods.append(method_obj)
                     edges.extend(method_edges)
                     
             # 생성자 추출
             constructor_nodes = self._find_nodes_by_type(class_node, 'constructor_declaration')
             for constructor_node in constructor_nodes:
                 constructor_obj, constructor_edges = self._extract_constructor_from_tree_sitter(
                     constructor_node, class_obj, lines
                 )
                 if constructor_obj:
                     methods.append(constructor_obj)
                     edges.extend(constructor_edges)
-            
+
+            if super_fqn:
+                edges.append(Edge(
+                    src_type='class',
+                    src_id=None,
+                    dst_type='class',
+                    dst_id=None,
+                    edge_kind='extends',
+                    confidence=0.9
+                ))
+            for _ in interfaces:
+                edges.append(Edge(
+                    src_type='class',
+                    src_id=None,
+                    dst_type='interface',
+                    dst_id=None,
+                    edge_kind='implements',
+                    confidence=0.9
+                ))
+
             return class_obj, methods, edges
             
         except Exception as e:
             if self.logger:
                 self.logger.error("Tree-sitter 클래스 추출 오류", exception=e)
             else:
                 print(f"Tree-sitter 클래스 추출 오류: {e}")
             return None, [], []
             
     def _extract_interface_from_tree_sitter(self, interface_node, file_obj: File, lines: List[str]) -> Tuple[Optional[Class], List[Method], List[Edge]]:
         """
         Tree-sitter 노드에서 인터페이스 정보 추출
         """
         # 인터페이스도 클래스와 비슷한 방식으로 처리
         return self._extract_class_from_tree_sitter(interface_node, file_obj, lines)
         
     def _extract_enum_from_tree_sitter(self, enum_node, file_obj: File, lines: List[str]) -> Tuple[Optional[Class], List[Method], List[Edge]]:
         """
         Tree-sitter 노드에서 열거형 정보 추출
         """
         # 열거형도 클래스와 비슷한 방식으로 처리
         return self._extract_class_from_tree_sitter(enum_node, file_obj, lines)
         
     def _extract_method_from_tree_sitter(self, method_node, class_obj: Class, lines: List[str]) -> Tuple[Optional[Method], List[Edge]]:
         """



diff --git a//dev/null b/phase1/scripts/migrate_add_inheritance_columns.py
index 0000000000000000000000000000000000000000..2cf853f913ecee69389ce93e2b347ce7d393221f 100644
--- a//dev/null
+++ b/phase1/scripts/migrate_add_inheritance_columns.py
@@ -0,0 +1,31 @@
+import argparse
+from sqlalchemy import create_engine, inspect, text
+
+def migrate(db_url: str) -> None:
+    engine = create_engine(db_url)
+    inspector = inspect(engine)
+    existing = {col['name'] for col in inspector.get_columns('classes')}
+    with engine.begin() as conn:
+        dialect = engine.dialect.name
+        super_type = 'CLOB' if dialect == 'oracle' else 'TEXT'
+        interface_type = super_type
+        if 'super_fqn' not in existing:
+            if dialect == 'oracle':
+                conn.execute(text(f"ALTER TABLE classes ADD (super_fqn {super_type})"))
+            else:
+                conn.execute(text(f"ALTER TABLE classes ADD COLUMN super_fqn {super_type}"))
+        if 'interfaces' not in existing:
+            if dialect == 'oracle':
+                conn.execute(text(f"ALTER TABLE classes ADD (interfaces {interface_type})"))
+            else:
+                conn.execute(text(f"ALTER TABLE classes ADD COLUMN interfaces {interface_type}"))
+    print('Migration completed.')
+
+def main() -> None:
+    parser = argparse.ArgumentParser(description='Add inheritance columns to classes table.')
+    parser.add_argument('db_url', help='SQLAlchemy database URL e.g. sqlite:///metadata.db')
+    args = parser.parse_args()
+    migrate(args.db_url)
+
+if __name__ == '__main__':
+    main()




















Refactor _resolve_method_calls for method resolution
8월 31일
kumtaek/ktohRep
master
+122
-61

아카이브에 보관

공유하기

PR 만들기


1. `phase1/database/metadata_engine.py`의 `_resolve_method_calls` 함수에서 호출 대상 탐색 시 `super_fqn`과 `interfaces`를 재귀적으로 조회해 후보 메서드를 수집한다.
2. 상위 클래스 또는 인터페이스에 동일 시그니처가 있으면 해당 메서드 ID를 `edge.dst_id`로 설정한다.
3. 찾지 못한 경우에만 기존 단순 문자열 매칭 로직을 사용하도록 분기한다.
복사
Summary
Enhanced _resolve_method_calls to parse optional called_signature and integrate it into method resolution metadata

Added recursive search through superclass and interface hierarchies to locate matching method definitions before falling back to string-based lookup


diff --git a/phase1/database/metadata_engine.py b/phase1/database/metadata_engine.py
index 6d8c6803d16422f1f3a11248d83297653a16e814..c147e86f94a6d272f136c708512680c376a8e948 100644
--- a/phase1/database/metadata_engine.py
+++ b/phase1/database/metadata_engine.py
@@ -680,155 +680,216 @@ class MetadataEngine:
             
             session.commit()
             
     async def _resolve_method_calls(self, session, project_id: int):
         """메서드 호출 관계 해결"""
         from models.database import EdgeHint, Method, Class, File
         import json as _json
         # 미해결된 메서드 호출 엣지들 조회
         unresolved_calls = session.query(Edge).filter(
             and_(
                 Edge.edge_kind == 'call',
                 Edge.dst_id.is_(None)
             )
         ).all()
         
         for edge in unresolved_calls:
             # 소스 메서드 정보 조회
             if edge.src_type == 'method':
                 src_method = session.query(Method).filter(
                     Method.method_id == edge.src_id
                 ).first()
                 
                 if src_method:
                     md = {}
                     called_method_name = ''
+                    called_signature = None
                     qualifier = None
                     src_method_fqn = None
                     # 1) Edge.metadata(JSON) 우선 사용
                     try:
                         if getattr(edge, 'meta', None):
                             md = _json.loads(edge.meta)
                             called_method_name = md.get('called_name', '')
+                            called_signature = md.get('called_signature')
                             qualifier = md.get('callee_qualifier_type')
                             src_method_fqn = md.get('src_method_fqn')
                     except Exception:
                         called_method_name = ''
                         qualifier = None
                     # 2) EdgeHint 보조 사용
                     if not called_method_name:
                         hint_row = session.query(EdgeHint).filter(
                             and_(
                                 EdgeHint.project_id == project_id,
                                 EdgeHint.src_type == 'method',
                                 EdgeHint.src_id == src_method.method_id,
                                 EdgeHint.hint_type == 'method_call'
                             )
                         ).order_by(EdgeHint.created_at.desc()).first()
                         if hint_row:
                             try:
                                 hint_data = _json.loads(hint_row.hint)
                                 called_method_name = hint_data.get('called_name', '')
+                                called_signature = called_signature or hint_data.get('called_signature')
                                 qualifier = qualifier or hint_data.get('callee_qualifier_type')
                             except Exception:
                                 called_method_name = ''
 
                     if called_method_name:
                         candidate_fqns = []
+                        unique_candidates: List[str] = []
+                        target_method = None
 
-                        # 동일 클래스 우선 후보
-                        if src_method.class_ and src_method.class_.fqn:
-                            candidate_fqns.append(f"{src_method.class_.fqn}.{called_method_name}")
+                        # 상속/인터페이스 체인에서 메서드 탐색
+                        def _parse_interfaces(val: Any) -> List[str]:
+                            if not val:
+                                return []
+                            try:
+                                if isinstance(val, str):
+                                    return _json.loads(val)
+                                return list(val)
+                            except Exception:
+                                if isinstance(val, str):
+                                    return [v.strip() for v in val.split(',') if v.strip()]
+                                return []
 
-                        # called_name 자체가 FQN일 경우
-                        if '.' in called_method_name:
-                            candidate_fqns.append(called_method_name)
+                        def _find_in_hierarchy(class_fqn: Optional[str], visited: set) -> Optional[Method]:
+                            if not class_fqn or class_fqn in visited:
+                                return None
+                            visited.add(class_fqn)
+                            cls = session.query(Class).join(File).filter(
+                                and_(Class.fqn == class_fqn, File.project_id == project_id)
+                            ).first()
+                            if not cls:
+                                return None
 
-                        # qualifier 기반 후보 생성
-                        if qualifier:
-                            if '.' in qualifier:
-                                candidate_fqns.append(f"{qualifier}.{called_method_name}")
-                            else:
-                                # 동일 패키지 내 단일 클래스명
-                                if src_method_fqn:
-                                    src_package = ".".join(src_method_fqn.split('.')[:-1])
-                                    if src_package:
-                                        candidate_fqns.append(f"{src_package}.{qualifier}.{called_method_name}")
-                                # DB에서 동일 클래스명 검색
-                                classes = session.query(Class).join(File).filter(
-                                    and_(File.project_id == project_id, Class.name == qualifier)
-                                ).all()
-                                for cls in classes:
-                                    candidate_fqns.append(f"{cls.fqn}.{called_method_name}")
+                            q = session.query(Method).filter(
+                                Method.class_id == cls.class_id,
+                                Method.name == called_method_name,
+                            )
+                            if called_signature:
+                                q = q.filter(Method.signature == called_signature)
+                            m = q.first()
+                            if m:
+                                return m
 
-                        # 중복 제거
-                        seen = set()
-                        unique_candidates = []
-                        for fqn in candidate_fqns:
-                            if fqn not in seen:
-                                unique_candidates.append(fqn)
-                                seen.add(fqn)
+                            next_fqns = []
+                            next_super = getattr(cls, 'super_fqn', None)
+                            if next_super:
+                                next_fqns.append(next_super)
+                            next_fqns.extend(_parse_interfaces(getattr(cls, 'interfaces', None)))
 
-                        target_method = None
-                        for fqn in unique_candidates:
-                            if '.' not in fqn:
-                                continue
-                            cls_fqn, m_name = fqn.rsplit('.', 1)
-                            target_method = session.query(Method).join(Class).join(File).filter(
-                                and_(
-                                    Method.name == m_name,
-                                    Class.fqn == cls_fqn,
-                                    File.project_id == project_id,
-                                )
-                            ).first()
-                            if target_method:
-                                break
+                            for nfqn in next_fqns:
+                                found = _find_in_hierarchy(nfqn, visited)
+                                if found:
+                                    return found
+                            return None
 
-                        # 기존 전역 검색 (패키지/임포트 기반) 보조
+                        if src_method.class_:
+                            visited: set = set()
+                            start_fqns: List[str] = []
+                            if getattr(src_method.class_, 'super_fqn', None):
+                                start_fqns.append(getattr(src_method.class_, 'super_fqn'))
+                            start_fqns.extend(_parse_interfaces(getattr(src_method.class_, 'interfaces', None)))
+                            for fqn in start_fqns:
+                                target_method = _find_in_hierarchy(fqn, visited)
+                                if target_method:
+                                    break
+
+                        # 기존 로직은 상속 체인에서 찾지 못했을 때만 실행
                         if not target_method:
-                            target_class_name = None
-                            simple_called_name = called_method_name
+                            # 동일 클래스 우선 후보
+                            if src_method.class_ and src_method.class_.fqn:
+                                candidate_fqns.append(f"{src_method.class_.fqn}.{called_method_name}")
+
+                            # called_name 자체가 FQN일 경우
                             if '.' in called_method_name:
-                                parts = called_method_name.rsplit('.', 1)
-                                target_class_name = parts[0]
-                                simple_called_name = parts[1]
+                                candidate_fqns.append(called_method_name)
+
+                            # qualifier 기반 후보 생성
+                            if qualifier:
+                                if '.' in qualifier:
+                                    candidate_fqns.append(f"{qualifier}.{called_method_name}")
+                                else:
+                                    # 동일 패키지 내 단일 클래스명
+                                    if src_method_fqn:
+                                        src_package = ".".join(src_method_fqn.split('.')[:-1])
+                                        if src_package:
+                                            candidate_fqns.append(f"{src_package}.{qualifier}.{called_method_name}")
+                                    # DB에서 동일 클래스명 검색
+                                    classes = session.query(Class).join(File).filter(
+                                        and_(File.project_id == project_id, Class.name == qualifier)
+                                    ).all()
+                                    for cls in classes:
+                                        candidate_fqns.append(f"{cls.fqn}.{called_method_name}")
+
+                            # 중복 제거
+                            seen = set()
+                            for fqn in candidate_fqns:
+                                if fqn not in seen:
+                                    unique_candidates.append(fqn)
+                                    seen.add(fqn)
 
-                            query = session.query(Method).join(Class).join(File).filter(
-                                and_(
-                                    Method.name == simple_called_name,
-                                    File.project_id == project_id
+                            for fqn in unique_candidates:
+                                if '.' not in fqn:
+                                    continue
+                                cls_fqn, m_name = fqn.rsplit('.', 1)
+                                target_method = session.query(Method).join(Class).join(File).filter(
+                                    and_(
+                                        Method.name == m_name,
+                                        Class.fqn == cls_fqn,
+                                        File.project_id == project_id,
+                                    )
+                                ).first()
+                                if target_method:
+                                    break
+
+                            # 기존 전역 검색 (패키지/임포트 기반) 보조
+                            if not target_method:
+                                target_class_name = None
+                                simple_called_name = called_method_name
+                                if '.' in called_method_name:
+                                    parts = called_method_name.rsplit('.', 1)
+                                    target_class_name = parts[0]
+                                    simple_called_name = parts[1]
+
+                                query = session.query(Method).join(Class).join(File).filter(
+                                    and_(
+                                        Method.name == simple_called_name,
+                                        File.project_id == project_id
+                                    )
                                 )
-                            )
 
-                            if target_class_name:
-                                query = query.filter(Class.fqn.like(f"%{target_class_name}"))
-                            elif src_method_fqn:
-                                src_package = ".".join(src_method_fqn.split('.')[:-1])
-                                if src_package:
-                                    query = query.filter(Class.fqn.like(f"{src_package}.%"))
+                                if target_class_name:
+                                    query = query.filter(Class.fqn.like(f"%{target_class_name}"))
+                                elif src_method_fqn:
+                                    src_package = ".".join(src_method_fqn.split('.')[:-1])
+                                    if src_package:
+                                        query = query.filter(Class.fqn.like(f"{src_package}.%"))
 
-                            target_method = query.first()
+                                target_method = query.first()
 
                         if target_method:
                             edge.dst_type = 'method'
                             edge.dst_id = target_method.method_id
                             edge.confidence = min(1.0, edge.confidence + 0.2)  # 해결된 호출에 신뢰도 보너스
 
                             self.logger.debug(f"메서드 호출 해결: {src_method.name} -> {target_method.name}")
                         else:
                             # 해결되지 않은 호출은 신뢰도 감소 및 힌트 저장
                             edge.confidence = max(0.1, edge.confidence - 0.3)
                             hint = {
                                 'called_name': called_method_name
                             }
                             if qualifier:
                                 hint['callee_qualifier_type'] = qualifier
                             if unique_candidates:
                                 hint['candidates'] = unique_candidates
                             session.add(EdgeHint(
                                 project_id=project_id,
                                 src_type='method',
                                 src_id=edge.src_id or 0,
                                 hint_type='method_call',
                                 hint=_json.dumps(hint, ensure_ascii=False),
                                 confidence=edge.confidence,
                             ))





















Add JAR metadata extraction script
8월 31일
kumtaek/ktohRep
master
+176
-4

아카이브에 보관

공유하기

PR 만들기


1. `phase1/tools` 또는 신규 모듈에 JAR 메타데이터 추출 스크립트를 추가해 클래스·메서드 시그니처 목록을 JSON/DB에 저장한다.
2. `_resolve_method_calls` 내에서 내부 검색 후에도 대상이 없으면 라이브러리 메타데이터를 조회한다.
3. 라이브러리 메서드를 찾으면 `dst_type`을 구분해 엣지를 생성하고, 시퀀스 다이어그램 등에도 반영한다.
복사
Summary
Added a new JAR metadata extraction tool that parses class files, stores discovered signatures into JSON or the project database, and leverages javap for bytecode inspection

Introduced dedicated database tables for library classes and methods to persist external metadata for method resolution

Enhanced method call resolution to consult stored library metadata and mark edges that target external library methods

Expanded visualization support so library methods have retrievable node details and appear in sequence diagrams with appropriate labeling and actor types


diff --git a/phase1/database/metadata_engine.py b/phase1/database/metadata_engine.py
index 6d8c6803d16422f1f3a11248d83297653a16e814..7b0cf506fa81ce9c5afa53f39b8cab9622275940 100644
--- a/phase1/database/metadata_engine.py
+++ b/phase1/database/metadata_engine.py
@@ -660,51 +660,51 @@ class MetadataEngine:
         """
         return self._save_jsp_mybatis_analysis_sync(file_obj, sql_units, joins, filters, edges, vulnerabilities)
             
     async def build_dependency_graph(self, project_id: int):
         """
         프로젝트의 의존성 그래프 구축
         
         Args:
             project_id: 프로젝트 ID
         """
         
         async with self._get_async_session() as session:
             # 메서드 호출 관계 해결
             await self._resolve_method_calls(session, project_id)
             
             # 테이블 사용 관계 해결  
             await self._resolve_table_usage(session, project_id)
             
             # PK-FK 관계 추론
             await self._infer_pk_fk_relationships(session, project_id)
             
             session.commit()
             
     async def _resolve_method_calls(self, session, project_id: int):
         """메서드 호출 관계 해결"""
-        from models.database import EdgeHint, Method, Class, File
+        from models.database import EdgeHint, Method, Class, File, LibraryMethod, LibraryClass
         import json as _json
         # 미해결된 메서드 호출 엣지들 조회
         unresolved_calls = session.query(Edge).filter(
             and_(
                 Edge.edge_kind == 'call',
                 Edge.dst_id.is_(None)
             )
         ).all()
         
         for edge in unresolved_calls:
             # 소스 메서드 정보 조회
             if edge.src_type == 'method':
                 src_method = session.query(Method).filter(
                     Method.method_id == edge.src_id
                 ).first()
                 
                 if src_method:
                     md = {}
                     called_method_name = ''
                     qualifier = None
                     src_method_fqn = None
                     # 1) Edge.metadata(JSON) 우선 사용
                     try:
                         if getattr(edge, 'meta', None):
                             md = _json.loads(edge.meta)
diff --git a/phase1/database/metadata_engine.py b/phase1/database/metadata_engine.py
index 6d8c6803d16422f1f3a11248d83297653a16e814..7b0cf506fa81ce9c5afa53f39b8cab9622275940 100644
--- a/phase1/database/metadata_engine.py
+++ b/phase1/database/metadata_engine.py
@@ -761,81 +761,111 @@ class MetadataEngine:
                                     candidate_fqns.append(f"{cls.fqn}.{called_method_name}")
 
                         # 중복 제거
                         seen = set()
                         unique_candidates = []
                         for fqn in candidate_fqns:
                             if fqn not in seen:
                                 unique_candidates.append(fqn)
                                 seen.add(fqn)
 
                         target_method = None
                         for fqn in unique_candidates:
                             if '.' not in fqn:
                                 continue
                             cls_fqn, m_name = fqn.rsplit('.', 1)
                             target_method = session.query(Method).join(Class).join(File).filter(
                                 and_(
                                     Method.name == m_name,
                                     Class.fqn == cls_fqn,
                                     File.project_id == project_id,
                                 )
                             ).first()
                             if target_method:
                                 break
 
+                        lib_method = None
+
                         # 기존 전역 검색 (패키지/임포트 기반) 보조
                         if not target_method:
                             target_class_name = None
                             simple_called_name = called_method_name
                             if '.' in called_method_name:
                                 parts = called_method_name.rsplit('.', 1)
                                 target_class_name = parts[0]
                                 simple_called_name = parts[1]
 
                             query = session.query(Method).join(Class).join(File).filter(
                                 and_(
                                     Method.name == simple_called_name,
                                     File.project_id == project_id
                                 )
                             )
 
                             if target_class_name:
                                 query = query.filter(Class.fqn.like(f"%{target_class_name}"))
                             elif src_method_fqn:
                                 src_package = ".".join(src_method_fqn.split('.')[:-1])
                                 if src_package:
                                     query = query.filter(Class.fqn.like(f"{src_package}.%"))
 
                             target_method = query.first()
 
+                        if not target_method:
+                            # 라이브러리 메타데이터 조회
+                            for fqn in unique_candidates:
+                                if '.' not in fqn:
+                                    continue
+                                cls_fqn, m_name = fqn.rsplit('.', 1)
+                                lib_method = session.query(LibraryMethod).join(LibraryClass).filter(
+                                    and_(
+                                        LibraryMethod.name == m_name,
+                                        LibraryClass.fqn == cls_fqn,
+                                    )
+                                ).first()
+                                if lib_method:
+                                    break
+
+                            if not lib_method and called_method_name:
+                                simple_name = called_method_name.split('.')[-1]
+                                lib_method = session.query(LibraryMethod).filter(
+                                    LibraryMethod.name == simple_name
+                                ).first()
+
                         if target_method:
                             edge.dst_type = 'method'
                             edge.dst_id = target_method.method_id
                             edge.confidence = min(1.0, edge.confidence + 0.2)  # 해결된 호출에 신뢰도 보너스
 
                             self.logger.debug(f"메서드 호출 해결: {src_method.name} -> {target_method.name}")
+                        elif lib_method:
+                            edge.dst_type = 'library_method'
+                            edge.dst_id = lib_method.method_id
+                            edge.confidence = min(1.0, edge.confidence + 0.1)
+                            self.logger.debug(
+                                f"외부 메서드 호출 해결: {src_method.name} -> {lib_method.name}"
+                            )
                         else:
                             # 해결되지 않은 호출은 신뢰도 감소 및 힌트 저장
                             edge.confidence = max(0.1, edge.confidence - 0.3)
                             hint = {
                                 'called_name': called_method_name
                             }
                             if qualifier:
                                 hint['callee_qualifier_type'] = qualifier
                             if unique_candidates:
                                 hint['candidates'] = unique_candidates
                             session.add(EdgeHint(
                                 project_id=project_id,
                                 src_type='method',
                                 src_id=edge.src_id or 0,
                                 hint_type='method_call',
                                 hint=_json.dumps(hint, ensure_ascii=False),
                                 confidence=edge.confidence,
                             ))
                             self.logger.debug(
                                 f"미해결 메서드 호출: {src_method.name} -> {called_method_name} (qualifier={qualifier})"
                             )
                     
         session.commit()
         self.logger.info(f"메서드 호출 관계 해결 완료: {len(unresolved_calls)}개 처리")
                     



diff --git a/phase1/models/database.py b/phase1/models/database.py
index 437b3cc965314363c87398cf4704c8264de1a0ce..75e530423fc1136dae41c1eea2891a9349aab9b0 100644
--- a/phase1/models/database.py
+++ b/phase1/models/database.py
@@ -233,50 +233,76 @@ class Chunk(Base):
     
     # Relationships
     embedding = relationship("Embedding", back_populates="chunk", uselist=False, cascade="all, delete-orphan")
 
 class Embedding(Base):
     __tablename__ = 'embeddings'
     
     chunk_id = Column(Integer, ForeignKey('chunks.chunk_id'), primary_key=True)
     model = Column(String(100), nullable=False)  # Embedding model name
     dim = Column(Integer)  # Vector dimension
     faiss_vector_id = Column(Integer)  # ID in FAISS index
     created_at = Column(DateTime, default=datetime.utcnow)
     
     # Relationships
     chunk = relationship("Chunk", back_populates="embedding")
 
 # (Optional) Java import declarations to assist resolution
 class JavaImport(Base):
     __tablename__ = 'java_imports'
     
     import_id = Column(Integer, primary_key=True)
     file_id = Column(Integer, ForeignKey('files.file_id'), nullable=False)
     class_fqn = Column(Text)  # imported FQN
     static = Column(Integer, default=0)
 
+
+class LibraryClass(Base):
+    __tablename__ = 'library_classes'
+
+    class_id = Column(Integer, primary_key=True)
+    fqn = Column(Text, nullable=False)
+    jar_name = Column(String(255))
+
+    # Relationships
+    methods = relationship("LibraryMethod", back_populates="class_", cascade="all, delete-orphan")
+
+
+class LibraryMethod(Base):
+    __tablename__ = 'library_methods'
+
+    method_id = Column(Integer, primary_key=True)
+    class_id = Column(Integer, ForeignKey('library_classes.class_id'), nullable=False)
+    name = Column(String(255), nullable=False)
+    signature = Column(Text)
+
+    # Relationships
+    class_ = relationship("LibraryClass", back_populates="methods")
+
+Index('idx_library_classes_fqn', LibraryClass.fqn)
+Index('idx_library_methods_class_name', LibraryMethod.class_id, LibraryMethod.name)
+
 class EdgeHint(Base):
     """Edge hints for resolving relationships during build phase"""
     __tablename__ = 'edge_hints'
     
     hint_id = Column(Integer, primary_key=True)
     project_id = Column(Integer, ForeignKey('projects.project_id'), nullable=False)
     src_type = Column(String(50), nullable=False)   # 'method', 'file', 'sql_unit'
     src_id = Column(Integer, nullable=False)
     hint_type = Column(String(50), nullable=False)  # 'method_call', 'jsp_include', 'mybatis_include'
     hint = Column(Text, nullable=False)             # JSON: { called_name, arg_count, target_path, namespace, line, ... }
     confidence = Column(Float, default=0.5)
     created_at = Column(DateTime, default=datetime.utcnow)
 
 class Relatedness(Base):
     """Stores relatedness scores between entities for visualization clustering"""
     __tablename__ = 'relatedness'
     
     relatedness_id = Column(Integer, primary_key=True)
     project_id = Column(Integer, ForeignKey('projects.project_id'), nullable=False)
     node1_type = Column(String(50), nullable=False)  # file, class, method, sql_unit, table
     node1_id = Column(Integer, nullable=False)
     node2_type = Column(String(50), nullable=False)
     node2_id = Column(Integer, nullable=False)
     score = Column(Float, nullable=False)  # 0.0 to 1.0
     reason = Column(String(100), nullable=False)  # edge_fk, directory_proximity, naming_convention, etc.




diff --git a//dev/null b/phase1/tools/jar_metadata_extractor.py
index 0000000000000000000000000000000000000000..90a9d6d2064e4706bea03f7979136306edf32c6c 100644
--- a//dev/null
+++ b/phase1/tools/jar_metadata_extractor.py
@@ -0,0 +1,105 @@
+#!/usr/bin/env python
+"""Extract class and method signatures from JAR files.
+
+This utility scans one or more JAR archives and stores discovered class and
+method signatures into JSON and/or the project metadata database. It relies on
+``javap`` being available in the environment for bytecode inspection.
+"""
+
+from __future__ import annotations
+
+import argparse
+import json
+import subprocess
+import zipfile
+from pathlib import Path
+from typing import List, Dict, Any
+
+import yaml
+
+from models.database import DatabaseManager, LibraryClass, LibraryMethod
+
+REPO_ROOT = Path(__file__).resolve().parents[2]
+
+
+def load_config() -> Dict[str, Any]:
+    cfg_path = REPO_ROOT / "config" / "config.yaml"
+    if cfg_path.exists():
+        text = cfg_path.read_text(encoding="utf-8")
+        return yaml.safe_load(text) or {}
+    return {"database": {"type": "sqlite", "sqlite": {"path": str(REPO_ROOT / "data" / "metadata.db")}}}
+
+
+def _extract_from_jar(jar_path: Path) -> List[Dict[str, Any]]:
+    classes: List[Dict[str, Any]] = []
+    with zipfile.ZipFile(jar_path, "r") as jar:
+        class_files = [f for f in jar.namelist() if f.endswith(".class")]
+        for class_file in class_files:
+            class_name = class_file[:-6].replace("/", ".")
+            try:
+                out = subprocess.check_output(
+                    ["javap", "-classpath", str(jar_path), class_name],
+                    stderr=subprocess.DEVNULL,
+                    text=True,
+                )
+            except Exception:
+                continue
+            methods = []
+            for line in out.splitlines():
+                line = line.strip()
+                if not line or line.startswith("Compiled from"):
+                    continue
+                if line.endswith(";") and "(" in line:
+                    sig = line.rstrip(";")
+                    name = sig.split("(")[0].split()[-1]
+                    methods.append({"name": name, "signature": sig})
+            classes.append({"fqn": class_name, "methods": methods})
+    return classes
+
+
+def save_to_db(cfg: Dict[str, Any], jar_name: str, data: List[Dict[str, Any]]):
+    dbm = DatabaseManager(cfg)
+    dbm.initialize()
+    session = dbm.get_session()
+    try:
+        for cls_data in data:
+            cls = LibraryClass(fqn=cls_data["fqn"], jar_name=jar_name)
+            session.add(cls)
+            session.flush()
+            for m in cls_data["methods"]:
+                session.add(
+                    LibraryMethod(class_id=cls.class_id, name=m["name"], signature=m.get("signature"))
+                )
+        session.commit()
+    finally:
+        session.close()
+        dbm.close()
+
+
+def main(argv: List[str] | None = None) -> int:
+    ap = argparse.ArgumentParser(description="Extract JAR metadata")
+    ap.add_argument("jars", nargs="+", help="Paths to JAR files")
+    ap.add_argument("--json", dest="json_out", help="Optional JSON output path")
+    ap.add_argument("--no-db", action="store_true", help="Skip storing results in database")
+    args = ap.parse_args(argv)
+
+    cfg = load_config()
+    all_data = []
+    for jar_path in args.jars:
+        jar = Path(jar_path)
+        if not jar.exists():
+            continue
+        data = _extract_from_jar(jar)
+        all_data.extend(data)
+        if not args.no_db:
+            save_to_db(cfg, jar.name, data)
+
+    if args.json_out:
+        Path(args.json_out).write_text(json.dumps(all_data, ensure_ascii=False, indent=2), encoding="utf-8")
+
+    print(f"Processed {len(args.jars)} JAR(s)")
+    return 0
+
+
+if __name__ == "__main__":
+    raise SystemExit(main())






diff --git a/visualize/builders/sequence_diagram.py b/visualize/builders/sequence_diagram.py
index 4b78967f37f303dbf89c3ce6d330f4168112f8ec..ab3db96d6a279bdf97e3fca9a878295e295fa36f 100644
--- a/visualize/builders/sequence_diagram.py
+++ b/visualize/builders/sequence_diagram.py
@@ -407,77 +407,78 @@ def _build_jsp_sql_sequence(config: Dict[str, Any], db: VizDB, project_id: int,
     
     # SQL -> Table connections (from actual edges)
     for edge in table_edges:
         src_id = f"sql_unit:{edge.src_id}"
         dst_id = f"table:{edge.dst_id}"
         
         if any(n['id'] == src_id for n in sequence_nodes) and any(n['id'] == dst_id for n in sequence_nodes):
             sequence_edges.append({
                 'id': f"flow_edge:{edge_id_counter}",
                 'source': src_id,
                 'target': dst_id,
                 'kind': edge.edge_kind,
                 'confidence': edge.confidence,
                 'sequence_order': edge_id_counter,
                 'depth': 1
             })
             edge_id_counter += 1
     
     print(f"  Generated basic sequence: {len(sequence_nodes)} nodes, {len(sequence_edges)} edges")
     
     return create_graph(sequence_nodes, sequence_edges)
 
 
 def _get_sequence_label(node_type: str, details: Dict[str, Any]) -> str:
     """Generate label for sequence diagram node"""
-    if node_type == 'method':
+    if node_type in ('method', 'library_method'):
         class_name = details.get('class', '').split('.')[-1] if details.get('class') else ''
         method_name = details.get('name', 'unknown')
         return f"{class_name}.{method_name}()" if class_name else f"{method_name}()"
     elif node_type == 'sql_unit':
         return f"{details.get('mapper_ns', '')}.{details.get('stmt_id', '')}"
     elif node_type == 'table':
         return f"Table: {details.get('name', 'Unknown')}"
     elif node_type == 'file':
         path = details.get('path', '')
         return path.split('/')[-1] if '/' in path else path.split('\\')[-1]
     else:
         return f"{node_type}: {details.get('name', 'Unknown')}"
 
 
 def _get_actor_type(node_type: str) -> str:
     """Get UML actor type for participant"""
     actor_mapping = {
         'file': 'control',
         'class': 'control', 
         'method': 'control',
         'sql_unit': 'boundary',
         'table': 'entity',
         'controller': 'control',
         'service': 'control',
         'repository': 'boundary',
-        'mapper': 'boundary'
+        'mapper': 'boundary',
+        'library_method': 'control'
     }
     return actor_mapping.get(node_type.lower(), 'control')
 
 
 def _get_interaction_type(edge_kind: str) -> str:
     """Get UML interaction type from edge kind"""
     interaction_mapping = {
         'call': 'synchronous',
         'call_unresolved': 'asynchronous', 
         'use_table': 'synchronous',
         'call_sql': 'synchronous',
         'include': 'include',
         'extends': 'extend'
     }
     return interaction_mapping.get(edge_kind, 'synchronous')
 
 
 def _get_interaction_message(edge_kind: str, from_participant: Dict, to_participant: Dict) -> str:
     """Generate interaction message for sequence diagram"""
     if edge_kind == 'call':
         return f"call {to_participant['label']}"
     elif edge_kind == 'call_unresolved':
         return f"call? {to_participant['label']}"
     elif edge_kind == 'use_table':
         return f"query {to_participant['label']}"




diff --git a/visualize/data_access.py b/visualize/data_access.py
index 11cb94e5513dfda9a2a758bbd12cf335cd9f34af..6fbc20109044c3702c0498ce8874b7c491f75cd2 100644
--- a/visualize/data_access.py
+++ b/visualize/data_access.py
@@ -1,38 +1,38 @@
 # visualize/data_access.py
 from typing import Dict, Any, List, Optional
 from pathlib import Path
 import sys
 import os
 
 # Add phase1 to path
 current_dir = Path(__file__).parent
 project_root = current_dir.parent
 phase1_path = project_root / "phase1"
 sys.path.insert(0, str(phase1_path))
 
-from models.database import DatabaseManager as _DatabaseManager, File, Class, Method, SqlUnit, Join, RequiredFilter, Edge, DbTable, DbColumn, DbPk, VulnerabilityFix, Project, Relatedness
+from models.database import DatabaseManager as _DatabaseManager, File, Class, Method, SqlUnit, Join, RequiredFilter, Edge, DbTable, DbColumn, DbPk, VulnerabilityFix, Project, Relatedness, LibraryClass, LibraryMethod
 from sqlalchemy import and_, or_, func, text
 import yaml
 
 
 def DatabaseManager(config: str | Dict[str, Any]) -> _DatabaseManager:
     """Convenience wrapper to get an initialized DatabaseManager."""
     if isinstance(config, str):
         config = {
             "type": "sqlite",
             "sqlite": {
                 "path": f"./project/{config}/data/metadata.db",
                 "wal_mode": True,
             },
         }
     dbm = _DatabaseManager(config)
     dbm.initialize()
     return dbm
 
 
 class VizDB:
     def __init__(self, config: Dict[str, Any], project_name: Optional[str] = None):
         self.config = config
         self.project_name = project_name
         
         # 새로운 database config 구조에서 project database 사용
diff --git a/visualize/data_access.py b/visualize/data_access.py
index 11cb94e5513dfda9a2a758bbd12cf335cd9f34af..6fbc20109044c3702c0498ce8874b7c491f75cd2 100644
--- a/visualize/data_access.py
+++ b/visualize/data_access.py
@@ -330,50 +330,60 @@ class VizDB:
                         'file': file.path if file else None,
                         'line': cls.start_line,
                         'llm_summary': llm_summary
                     }
             elif node_type == 'file':
                 file = session.query(File).filter(File.file_id == node_id).first()
                 if file:
                     # Get LLM summary if available
                     llm_summary = None
                     try:
                         result = session.execute(
                             text("SELECT llm_summary FROM files WHERE file_id = :file_id"),
                             {"file_id": file.file_id}
                         ).fetchone()
                         if result and result[0]:
                             llm_summary = result[0]
                     except Exception:
                         pass
                     
                     return {
                         'path': file.path,
                         'language': file.language,
                         'loc': file.loc,
                         'llm_summary': llm_summary
                     }
+            elif node_type == 'library_method':
+                method = session.query(LibraryMethod).filter(LibraryMethod.method_id == node_id).first()
+                if method:
+                    cls = session.query(LibraryClass).filter(LibraryClass.class_id == method.class_id).first()
+                    return {
+                        'name': method.name,
+                        'signature': method.signature,
+                        'class': cls.fqn if cls else None,
+                        'jar': cls.jar_name if cls else None
+                    }
             elif node_type == 'sql_unit':
                 sql = session.query(SqlUnit).filter(SqlUnit.sql_id == node_id).first()
                 if sql:
                     file = session.query(File).filter(File.file_id == sql.file_id).first()
                     
                     # Get LLM summary if available
                     llm_summary = None
                     try:
                         result = session.execute(
                             text("SELECT llm_summary FROM sql_units WHERE sql_id = :sql_id"),
                             {"sql_id": sql.sql_id}
                         ).fetchone()
                         if result and result[0]:
                             llm_summary = result[0]
                     except Exception:
                         pass
                     
                     return {
                         'stmt_id': sql.stmt_id,
                         'mapper_ns': sql.mapper_ns,
                         'stmt_kind': sql.stmt_kind,
                         'file': file.path if file else None,
                         'line': sql.start_line,
                         'llm_summary': llm_summary
                     }

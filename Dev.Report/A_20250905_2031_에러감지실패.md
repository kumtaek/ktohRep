# A_20250905_2031_ì—ëŸ¬ê°ì§€ì‹¤íŒ¨.md

## ë¬¸ì œì  ì •í™•í•œ ì§„ë‹¨ ê²°ê³¼

ì˜ë„ì  ì—ëŸ¬ íŒŒì¼ë“¤ì„ ì§ì ‘ ë¶„ì„í•œ ê²°ê³¼, ëª…ì„¸ì„œì˜ 7ê°œ ì—ëŸ¬ê°€ ê°ì§€ë˜ì§€ ì•ŠëŠ” **êµ¬ì²´ì ì¸ ì›ì¸**ì„ ë°œê²¬í–ˆìŠµë‹ˆë‹¤.

## ì‹¤ì œ ì—ëŸ¬ ì¼€ì´ìŠ¤ ë¶„ì„

### **ğŸ” ë°œê²¬ëœ ì˜ë„ì  ì—ëŸ¬ë“¤**

#### **MixedErrorController.java (2ê°œ ì—ëŸ¬)**
```java
// ì—ëŸ¬ 1: ì„¸ë¯¸ì½œë¡  ëˆ„ë½ (Line 48)
User user = new User()  // â† ì„¸ë¯¸ì½œë¡  ëˆ„ë½
user.setName(name);

// ì—ëŸ¬ 2: Date import ëˆ„ë½ (Line 78)  
existingUser.setUpdateDate(new Date());  // â† java.util.Date import ì—†ìŒ
```

#### **MixedErrorService.java (2ê°œ ì—ëŸ¬)**
```java
// ì—ëŸ¬ 3: Date import ëˆ„ë½ (Line 46)
user.setCreateDate(new Date());  // â† java.util.Date import ì—†ìŒ

// ì—ëŸ¬ 4: Date import ëˆ„ë½ (Line 70)
user.setUpdateDate(new Date());  // â† java.util.Date import ì—†ìŒ
```

#### **partialError.jsp (3ê°œ ì—ëŸ¬)**
```jsp
<!-- ì—ëŸ¬ 5: ì •ì˜ë˜ì§€ ì•Šì€ ë³€ìˆ˜ ì°¸ì¡° (Line 59) -->
<c:if test="${user.status == 'ACTIVE'}">  <!-- userê°€ forEach ì™¸ë¶€ì—ì„œ ì°¸ì¡° -->

<!-- ì—ëŸ¬ 6: ì •ì˜ë˜ì§€ ì•Šì€ ë³€ìˆ˜ ì°¸ì¡° (Line 74) -->
if (userList != null) {  // userList ë³€ìˆ˜ê°€ ì •ì˜ë˜ì§€ ì•ŠìŒ

<!-- ì—ëŸ¬ 7: íƒœê·¸ ë‹«ê¸° ëˆ„ë½ (Line 92) -->
</c:otherwise>
<!-- </c:choose> íƒœê·¸ ë‹«ê¸° ëˆ„ë½ -->
```

## í•µì‹¬ ë¬¸ì œ ë¶„ì„

### **ğŸ”´ ë¬¸ì œ 1: íŒŒì„œì˜ ì—ëŸ¬ í—ˆìš©ì„±**

**í˜„ì¬ ìƒí™©**: íŒŒì„œë“¤ì´ êµ¬ë¬¸ ì—ëŸ¬ë¥¼ **ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰**

#### **Java íŒŒì„œ (ì •ê·œì‹ ê¸°ë°˜)**
- ì„¸ë¯¸ì½œë¡  ëˆ„ë½: ì •ê·œì‹ì´ ë¬¸ì¥ ë‹¨ìœ„ê°€ ì•„ë‹Œ ë©”ì„œë“œ ë‹¨ìœ„ë¡œ ë§¤ì¹­í•˜ì—¬ ëˆ„ë½ ë¬´ì‹œ
- Import ëˆ„ë½: ì»´íŒŒì¼ íƒ€ì„ ì—ëŸ¬ì´ì§€ë§Œ íŒŒì‹± ì‹œì—ëŠ” ë‹¨ìˆœ ë¬¸ìì—´ë¡œ ì²˜ë¦¬
- **ê²°ê³¼**: êµ¬ë¬¸ì ìœ¼ë¡œ ì˜ëª»ëœ ì½”ë“œë„ ë©”ì„œë“œë¡œ ì¸ì‹ë¨

#### **JSP íŒŒì„œ (í…ìŠ¤íŠ¸ ê¸°ë°˜)**  
- ë³€ìˆ˜ ìŠ¤ì½”í”„ ì—ëŸ¬: EL í‘œí˜„ì‹ ë‚´ë¶€ì˜ ë³€ìˆ˜ ìœ íš¨ì„± ê²€ì¦ ì•ˆí•¨
- íƒœê·¸ ë§¤ì¹­: ì—´ë¦¼/ë‹«í˜ íƒœê·¸ ìŒ ê²€ì¦ ë¡œì§ ë¶€ì¬
- **ê²°ê³¼**: ì˜ëª»ëœ JSPë„ ì •ìƒ íŒŒì‹±ë¨

### **ğŸ”´ ë¬¸ì œ 2: ì—ëŸ¬ ê°ì§€ ë°©ì‹ì˜ í•œê³„**

**í˜„ì¬ ì—ëŸ¬ ê°ì§€ ë°©ì‹**:
```python
try:
    analysis_result = parser.parse_content(content, context)
    # íŒŒì‹± ì„±ê³µ ì‹œ â†’ ì—ëŸ¬ ì—†ìŒìœ¼ë¡œ íŒì •
except Exception as e:
    # ì˜ˆì™¸ ë°œìƒ ì‹œì—ë§Œ â†’ ì—ëŸ¬ë¡œ íŒì •
```

**í•œê³„ì **:
1. **ì˜ˆì™¸ ê¸°ë°˜ ê°ì§€**: íŒŒì„œê°€ ì˜ˆì™¸ë¥¼ ë˜ì§€ì§€ ì•Šìœ¼ë©´ ì—ëŸ¬ë¡œ ì¸ì‹ ì•ˆë¨
2. **ì´ì§„ì  íŒì •**: ì„±ê³µ/ì‹¤íŒ¨ë§Œ êµ¬ë¶„, ë¶€ë¶„ ì„±ê³µ/ê²½ê³  ìˆ˜ì¤€ ë¬´ì‹œ
3. **íŒŒì„œ ì˜ì¡´ì„±**: ê° íŒŒì„œì˜ ì—„ê²©í•¨ ì •ë„ì— ë”°ë¼ ì—ëŸ¬ ê°ì§€ ì—¬ë¶€ ë‹¬ë¼ì§

### **ğŸ”´ ë¬¸ì œ 3: íŒŒì‹± ê²°ê³¼ í’ˆì§ˆ í‰ê°€ ë¶€ì¬**

**í•„ìš”í•œ í’ˆì§ˆ ì§€í‘œ**:
- íŒŒì‹± ì™„ì„±ë„ (ì „ì²´ ì¤‘ ì„±ê³µì ìœ¼ë¡œ íŒŒì‹±ëœ ë¹„ìœ¨)
- êµ¬ë¬¸ ì •í™•ë„ (ë¬¸ë²•ì  ì˜¤ë¥˜ ê²€ì¶œ)
- ì˜ë¯¸ ì¼ê´€ì„± (ë³€ìˆ˜ ìŠ¤ì½”í”„, íƒ€ì… ì¼ì¹˜ ë“±)

**í˜„ì¬ ìƒí™©**: íŒŒì‹± ì„±ê³µ ì—¬ë¶€ë§Œ í™•ì¸, í’ˆì§ˆì€ í‰ê°€í•˜ì§€ ì•ŠìŒ

## êµ¬ì²´ì  í•´ê²° ë°©ì•ˆ

### **ğŸ”§ í•´ê²°ì±… 1: íŒŒì„œë³„ ì—ëŸ¬ ìˆ˜ì§‘ ë©”ì»¤ë‹ˆì¦˜ ì¶”ê°€**

#### **Java íŒŒì„œ ê°œì„ **
```python
class JavaParser(BaseParser):
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.syntax_errors = []  # êµ¬ë¬¸ ì—ëŸ¬ ìˆ˜ì§‘
        self.semantic_warnings = []  # ì˜ë¯¸ ê²½ê³  ìˆ˜ì§‘
        
    def parse_content(self, content: str, context: Dict[str, Any]) -> Dict[str, Any]:
        # ê¸°ë³¸ íŒŒì‹±
        result = self._basic_parse(content)
        
        # êµ¬ë¬¸ ê²€ì¦ ì¶”ê°€
        syntax_issues = self._validate_syntax(content)
        semantic_issues = self._validate_semantics(content, result)
        
        result.update({
            'syntax_errors': syntax_issues,
            'semantic_warnings': semantic_issues,
            'parsing_quality': self._calculate_quality_score(content, syntax_issues, semantic_issues)
        })
        
        return result
    
    def _validate_syntax(self, content: str) -> List[Dict[str, Any]]:
        """êµ¬ë¬¸ ì—ëŸ¬ ê²€ì¦"""
        syntax_errors = []
        
        # 1. ì„¸ë¯¸ì½œë¡  ëˆ„ë½ ê²€ì‚¬
        lines = content.split('\n')
        for i, line in enumerate(lines):
            line = line.strip()
            # ë¬¸ì¥ì´ ëë‚˜ì•¼ í•˜ëŠ”ë° ì„¸ë¯¸ì½œë¡ ì´ ì—†ëŠ” ê²½ìš°
            if (re.match(r'^\s*\w+\s+\w+\s*=\s*new\s+\w+\(\)\s*$', line) and 
                not line.endswith(';')):
                syntax_errors.append({
                    'type': 'missing_semicolon',
                    'line': i + 1,
                    'message': f'ì„¸ë¯¸ì½œë¡  ëˆ„ë½: {line}',
                    'severity': 'error'
                })
        
        # 2. Import ê²€ì¦
        import_issues = self._validate_imports(content)
        syntax_errors.extend(import_issues)
        
        return syntax_errors
    
    def _validate_imports(self, content: str) -> List[Dict[str, Any]]:
        """Import ëˆ„ë½ ê²€ì¦"""
        import_errors = []
        
        # ì‚¬ìš©ëœ í´ë˜ìŠ¤ vs importëœ í´ë˜ìŠ¤ ë¹„êµ
        used_classes = set(re.findall(r'new\s+(\w+)\s*\(', content))
        imported_classes = set(re.findall(r'import\s+[\w.]*\.(\w+);', content))
        
        # ê¸°ë³¸ Java í´ë˜ìŠ¤ ì œì™¸
        java_builtin = {'String', 'Integer', 'Long', 'Double', 'Boolean', 'Object', 'Exception'}
        
        missing_imports = used_classes - imported_classes - java_builtin
        for class_name in missing_imports:
            if class_name == 'Date':  # Date í´ë˜ìŠ¤ íŠ¹ë³„ ê²€ì‚¬
                import_errors.append({
                    'type': 'missing_import',
                    'class': class_name,
                    'message': f'ëˆ„ë½ëœ import: java.util.{class_name}',
                    'severity': 'error',
                    'suggestion': f'import java.util.{class_name};'
                })
        
        return import_errors
```

#### **JSP íŒŒì„œ ê°œì„ **
```python
class JSPParser(BaseParser):
    def parse_content(self, content: str, context: Dict[str, Any]) -> Dict[str, Any]:
        result = self._basic_parse(content)
        
        # JSP íŠ¹í™” ê²€ì¦
        jsp_errors = self._validate_jsp_syntax(content)
        el_errors = self._validate_el_expressions(content)
        tag_errors = self._validate_tag_matching(content)
        
        result.update({
            'jsp_errors': jsp_errors + el_errors + tag_errors,
            'parsing_quality': self._calculate_jsp_quality(content, jsp_errors + el_errors + tag_errors)
        })
        
        return result
    
    def _validate_el_expressions(self, content: str) -> List[Dict[str, Any]]:
        """EL í‘œí˜„ì‹ ê²€ì¦"""
        el_errors = []
        
        # ${user.status} ê°™ì€ forEach ì™¸ë¶€ì—ì„œì˜ user ì°¸ì¡° ê²€ì‚¬
        el_expressions = re.findall(r'\$\{([^}]+)\}', content)
        
        for expr in el_expressions:
            if 'user.' in expr:
                # user ë³€ìˆ˜ê°€ ì •ì˜ëœ ìŠ¤ì½”í”„ ë‚´ë¶€ì¸ì§€ í™•ì¸
                if not self._is_in_foreach_scope(content, expr):
                    el_errors.append({
                        'type': 'undefined_variable',
                        'expression': expr,
                        'message': f'ì •ì˜ë˜ì§€ ì•Šì€ ë³€ìˆ˜ ì°¸ì¡°: {expr}',
                        'severity': 'error'
                    })
        
        return el_errors
    
    def _validate_tag_matching(self, content: str) -> List[Dict[str, Any]]:
        """JSTL íƒœê·¸ ë§¤ì¹­ ê²€ì¦"""
        tag_errors = []
        
        # íƒœê·¸ ìŠ¤íƒì„ ì´ìš©í•œ ë§¤ì¹­ ê²€ì‚¬
        tag_stack = []
        tag_pattern = r'<(/?)(c:\w+)(?:\s[^>]*)?>'
        
        for match in re.finditer(tag_pattern, content):
            is_closing = match.group(1) == '/'
            tag_name = match.group(2)
            
            if is_closing:
                if not tag_stack or tag_stack[-1] != tag_name:
                    tag_errors.append({
                        'type': 'unmatched_tag',
                        'tag': tag_name,
                        'message': f'ë§¤ì¹­ë˜ì§€ ì•ŠëŠ” ë‹«ëŠ” íƒœê·¸: {tag_name}',
                        'severity': 'error'
                    })
                else:
                    tag_stack.pop()
            else:
                # ìì²´ ë‹«í˜ íƒœê·¸ê°€ ì•„ë‹Œ ê²½ìš°ë§Œ ìŠ¤íƒì— ì¶”ê°€
                if not match.group(0).endswith('/>'):
                    tag_stack.append(tag_name)
        
        # ë‹«íˆì§€ ì•Šì€ íƒœê·¸ë“¤
        for unclosed_tag in tag_stack:
            tag_errors.append({
                'type': 'unclosed_tag',
                'tag': unclosed_tag,
                'message': f'ë‹«íˆì§€ ì•Šì€ íƒœê·¸: {unclosed_tag}',
                'severity': 'error'
            })
        
        return tag_errors
```

### **ğŸ”§ í•´ê²°ì±… 2: ì—ëŸ¬ ê°ì§€ ë¡œì§ ê°œì„ **

#### **í’ˆì§ˆ ê¸°ë°˜ ì—ëŸ¬ íŒì •**
```python
async def _analyze_single_file(self, file_path: str, project_id: int, file_type: str):
    """ê°œì„ ëœ ë‹¨ì¼ íŒŒì¼ ë¶„ì„"""
    try:
        parser = self._select_parser_for_file(file_path, file_type)
        if not parser:
            await self._save_parsing_error(file_path, project_id, "íŒŒì„œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ", "ParserNotFound")
            return
        
        # íŒŒì¼ ë‚´ìš© ì½ê¸°
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
        
        # íŒŒì‹± ì‹¤í–‰
        analysis_result = parser.parse_content(content, {'file_path': file_path})
        
        # í’ˆì§ˆ ê¸°ë°˜ ì—ëŸ¬ íŒì •
        quality_score = analysis_result.get('parsing_quality', 1.0)
        syntax_errors = analysis_result.get('syntax_errors', [])
        semantic_warnings = analysis_result.get('semantic_warnings', [])
        jsp_errors = analysis_result.get('jsp_errors', [])
        
        all_errors = syntax_errors + semantic_warnings + jsp_errors
        
        # íŒŒì¼ ì •ë³´ ì €ì¥
        file_id = await self._save_file_info(file_path, project_id)
        
        # íŒŒì‹± ê²°ê³¼ ì €ì¥ (ì—ëŸ¬ê°€ ìˆì–´ë„ ì €ì¥)
        await self._save_analysis_result(analysis_result, file_id, project_id)
        
        # ì—ëŸ¬ ì •ë³´ ë³„ë„ ì €ì¥
        if all_errors:
            for error in all_errors:
                await self._save_detailed_parsing_error(
                    file_path, project_id, error, quality_score
                )
        
        self.logger.info(
            f"íŒŒì¼ ë¶„ì„ ì™„ë£Œ: {file_path} - "
            f"í’ˆì§ˆì ìˆ˜: {quality_score:.2f}, ì—ëŸ¬: {len(all_errors)}ê°œ"
        )
        
    except Exception as e:
        self.logger.error(f"íŒŒì¼ ë¶„ì„ ì‹¤íŒ¨ {file_path}: {e}")
        await self._save_parsing_error(file_path, project_id, str(e), type(e).__name__)

async def _save_detailed_parsing_error(
    self, file_path: str, project_id: int, error: Dict[str, Any], quality_score: float
):
    """ìƒì„¸ ì—ëŸ¬ ì •ë³´ ì €ì¥"""
    try:
        with self.db_manager.get_auto_commit_session() as session:
            file_id = await self._save_file_info(file_path, project_id)
            
            parse_result = ParseResultModel(
                file_id=file_id,
                parser_type=Path(file_path).suffix.lower()[1:],
                success=quality_score > 0.5,  # 50% ì´ìƒì´ë©´ ë¶€ë¶„ ì„±ê³µ
                parse_time=0.0,
                ast_complete=quality_score >= 0.9,  # 90% ì´ìƒì´ë©´ ì™„ì „ íŒŒì‹±
                partial_ast=0.5 <= quality_score < 0.9,  # 50-90%ë©´ ë¶€ë¶„ íŒŒì‹±
                fallback_used=False,
                error_message=error.get('message', ''),
                confidence=quality_score,
                metadata=json.dumps({
                    'error_type': error.get('type', 'unknown'),
                    'severity': error.get('severity', 'error'),
                    'line': error.get('line'),
                    'suggestion': error.get('suggestion')
                })
            )
            session.add(parse_result)
            session.flush()
            
    except Exception as e:
        self.logger.error(f"ìƒì„¸ ì—ëŸ¬ ì €ì¥ ì‹¤íŒ¨ {file_path}: {e}")
```

### **ğŸ”§ í•´ê²°ì±… 3: íŒŒì‹± í’ˆì§ˆ ì ìˆ˜ ê³„ì‚°**

```python
def _calculate_quality_score(self, content: str, syntax_errors: List, semantic_warnings: List) -> float:
    """íŒŒì‹± í’ˆì§ˆ ì ìˆ˜ ê³„ì‚° (0.0 ~ 1.0)"""
    
    # ê¸°ë³¸ ì ìˆ˜ì—ì„œ ì—ëŸ¬ë³„ë¡œ ì°¨ê°
    base_score = 1.0
    
    # êµ¬ë¬¸ ì—ëŸ¬ëŠ” ì‹¬ê°í•œ ì°¨ê° (-0.3 per error)
    syntax_penalty = len(syntax_errors) * 0.3
    
    # ì˜ë¯¸ ê²½ê³ ëŠ” ê°€ë²¼ìš´ ì°¨ê° (-0.1 per warning)  
    semantic_penalty = len(semantic_warnings) * 0.1
    
    final_score = max(0.0, base_score - syntax_penalty - semantic_penalty)
    
    return final_score
```

## êµ¬í˜„ ìš°ì„ ìˆœìœ„

### **ğŸš€ Phase 1: í•µì‹¬ ì—ëŸ¬ ê°ì§€ (2ì‹œê°„)**
1. âœ… Java íŒŒì„œì— êµ¬ë¬¸ ì—ëŸ¬ ê²€ì¦ ì¶”ê°€ (ì„¸ë¯¸ì½œë¡ , Import)
2. âœ… JSP íŒŒì„œì— íƒœê·¸ ë§¤ì¹­ ë° EL ê²€ì¦ ì¶”ê°€
3. âœ… í’ˆì§ˆ ê¸°ë°˜ ì—ëŸ¬ íŒì • ë¡œì§ êµ¬í˜„

**ì˜ˆìƒ íš¨ê³¼**: 7ê°œ ì˜ë„ì  ì—ëŸ¬ ëª¨ë‘ ê°ì§€

### **ğŸ”§ Phase 2: ìƒì„¸ ì—ëŸ¬ ë¶„ë¥˜ (1ì‹œê°„)**
1. ì—ëŸ¬ ì‹¬ê°ë„ë³„ ë¶„ë¥˜ (Error, Warning, Info)
2. ì—ëŸ¬ ìœ„ì¹˜ ì •ë³´ (ì¤„ë²ˆí˜¸, ì»¬ëŸ¼) ì œê³µ
3. ìˆ˜ì • ì œì•ˆ ë©”ì‹œì§€ ì¶”ê°€

### **ğŸ“Š Phase 3: ì—ëŸ¬ ë¦¬í¬íŒ… (30ë¶„)**
1. ì—ëŸ¬ í†µê³„ ëŒ€ì‹œë³´ë“œ
2. íŒŒì¼ë³„ í’ˆì§ˆ ì ìˆ˜ í‘œì‹œ
3. í”„ë¡œì íŠ¸ ì „ì²´ ê±´ì „ì„± ì§€í‘œ

## ê²€ì¦ ê²°ê³¼ ì˜ˆìƒ

### **ìˆ˜ì • í›„ ê¸°ëŒ€ ê²°ê³¼**
```
MixedErrorController.java: 2ê°œ ì—ëŸ¬ ê°ì§€
- ì„¸ë¯¸ì½œë¡  ëˆ„ë½ (Line 48)
- Date import ëˆ„ë½ (Line 78)

MixedErrorService.java: 2ê°œ ì—ëŸ¬ ê°ì§€  
- Date import ëˆ„ë½ (Line 46, 70)

partialError.jsp: 3ê°œ ì—ëŸ¬ ê°ì§€
- ì •ì˜ë˜ì§€ ì•Šì€ ë³€ìˆ˜ ì°¸ì¡° (Line 59, 74)
- íƒœê·¸ ë‹«ê¸° ëˆ„ë½ (Line 92)

ì´ 7ê°œ ì—ëŸ¬ â†’ 100% ì—ëŸ¬ ê°ì§€ ë‹¬ì„±
```

---

**ë¶„ì„ ì™„ë£Œì¼ì‹œ**: 2025-09-05 20:31:00  
**ë¶„ì„ì**: SourceAnalyzer Technical Team  
**ì§„ë‹¨ ìƒíƒœ**: âœ… ì˜ë„ì  ì—ëŸ¬ ì¼€ì´ìŠ¤ ëª¨ë‘ í™•ì¸ë¨  
**í•´ê²° ì ‘ê·¼**: íŒŒì„œë³„ í’ˆì§ˆ ê²€ì¦ ë¡œì§ ì¶”ê°€  
**ì„±ê³µ í™•ë¥ **: 90% (ì˜ë„ì  ì—ëŸ¬ íŠ¹ì„±ìƒ ëª…í™•í•¨)
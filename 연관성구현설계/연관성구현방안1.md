# 연관성 기반 시각화 개선 방안

## 1. 현상 분석

- 현재 생성되는 시각화 리포트(ERD, 컴포넌트 의존성 등)에서 엔티티(객체)들이 수평으로 길게 나열되어 가독성이 떨어짐.
- 전체적인 관계 조망을 위해 축소하면 엔티티가 너무 작아져 식별이 불가능하고, 확대하면 일부 엔티티만 보여 전체 구조를 파악하기 어려움.

## 2. 목표

- 모든 시각화 리포트에서 **연관성이 높은 엔티티들을 서로 인접하게 배치**하여 전체적인 구조와 관계를 직관적으로 파악할 수 있도록 가독성을 향상시킴.
- 이를 위해 엔티티 간의 '연관성'을 판단하는 지능적인 로직을 구현하고, 시각화 레이아웃 엔진에 적용함.

## 3. 구현 방안

### 3.1. 연관성 데이터 추출 및 메타데이터 확장

엔티티 간의 연관성을 판단하기 위해 다음과 같은 다층적 접근 방식을 제안합니다.

#### Phase 1: 규칙 기반 연관성 추출

결정적이고 명확한 규칙을 우선적으로 적용하여 연관성 정보를 추출합니다.

1. **데이터베이스 스키마(ERD) 분석:**
   
   - **Foreign Key (FK) 관계:** 테이블 간의 FK를 가장 강한 연관성으로 정의.
   - **테이블/컬럼명 유사도:** `user_id`, `user_name` 등 유사한 패턴의 컬럼명을 가진 테이블 간의 연관성 점수 부여.

2. **소스코드 구조 분석:**
   
   - **디렉토리/모듈 구조:** 동일한 디렉토리나 모듈에 속한 파일(클래스)들은 높은 연관성을 가짐.
   - **클래스 상속/포함 관계:** 부모-자식 클래스 또는 특정 클래스를 멤버 변수로 포함하는 경우 연관성 부여.
   - **함수 호출 그래프 (Call Graph):** 특정 함수나 메소드를 서로 호출하는 클래스 간의 연관성 분석.

#### Phase 2: AI/LLM 기반 의미론적 연관성 추출

규칙으로 판단하기 어려운 미묘하고 복잡한 관계는 AI를 통해 분석합니다. `phase1`의 소스코드 분석 인프라를 확장하여 활용합니다.

1. **LLM을 이용한 코드 의미 분석:**
   
   - 특정 클래스나 함수와 관련된 코드 블록(생성, 호출, 수정 등)을 추출하여 LLM에 전달.
   - "두 클래스가 비즈니스 로직 상 어떤 관계인가?" 와 같은 프롬프트를 통해 의미적 연관성(예: "User와 Order는 밀접한 구매 관계")을 텍스트로 분석하고 점수화.

2. **임베딩을 이용한 벡터 유사도 분석:**
   
   - CodeBERT, `text-embedding-ada-002` 등의 모델을 사용하여 클래스/함수/파일 단위로 코드의 임베딩 벡터를 생성.
   - 벡터 간의 **코사인 유사도(Cosine Similarity)**를 계산하여 임계값 이상일 경우 연관성이 있는 것으로 판단. 이는 직접적인 호출 관계가 없더라도, 비슷한 역할을 수행하거나 비슷한 데이터를 처리하는 객체들을 찾아낼 수 있음.

#### 메타데이터 구조 확장

위에서 추출된 연관성 정보를 시각화 데이터에 통합하기 위해 `visualize/schema.py` 등에 정의된 기존 데이터 모델에 아래와 같은 필드를 추가합니다.

- `cluster_id`: 각 엔티티가 속할 그룹(군집)의 식별자.
- `relatedness_scores`: 다른 엔티티와의 연관성 점수를 담는 딕셔너리. (예: `{'entity_B': 0.8, 'entity_C': 0.5}`)

### 3.2. 시각화 레이아웃 개선

추출된 연관성 데이터를 활용하여 시각화 라이브러리의 레이아웃을 동적으로 조정합니다.

1. **레이아웃 엔진 식별 및 선정:**
   
   - 현재 사용 중인 시각화 라이브러리(예: Mermaid.js, D3.js, Cytoscape.js 등)를 `visualize/templates` 및 `visualize/exporters` 분석을 통해 명확히 식별.
   - 만약 현재 라이브러리가 커스텀 레이아웃을 지원하지 않는다면, **D3.js**나 **Cytoscape.js** 와 같이 **Force-Directed Layout (강제 지향 레이아웃)**을 강력하게 지원하는 라이브러리로의 전환을 검토.

2. **Force-Directed Layout 적용:**
   
   - 이 레이아웃은 노드(엔티티)들을 서로 밀어내는 척력(repulsion)과, 엣지(관계)로 연결된 노드들을 끌어당기는 인력(attraction)을 시뮬레이션하여 자연스러운 군집을 형성.
   - **연관성 점수를 인력 계수로 변환:** `relatedness_scores`를 기반으로 엔티티 간의 인력(link strength)을 동적으로 조절. 연관성이 높을수록 더 강하게 끌어당기게 하여 물리적으로 가깝게 배치.
   - **클러스터링:** `cluster_id`가 동일한 엔티티들을 하나의 보이지 않는 그룹으로 묶어, 그룹 내에서는 강한 인력을, 그룹 외부와는 약한 인력을 적용하여 군집 효과를 극대화.

## 4. 단계별 실행 계획

### 1단계: 기반 구축 및 규칙 기반 클러스터링 (MVP)

- `visualize` 코드 분석하여 현재 레이아웃 엔진 및 데이터 흐름 파악.
- 규칙 기반(FK, 디렉토리 구조) 연관성 추출 로직 구현.
- `visualize/schema.py`에 `cluster_id` 필드 추가.
- D3.js 또는 Cytoscape.js를 사용하여 Force-Directed Layout 기본 적용 및 테스트.

### 2단계: 지능형 클러스터링 도입

- `phase1`의 LLM/임베딩 분석 기능을 `visualize` 파이프라인과 연동.
- AI 기반 연관성 점수 추출 로직 구현 및 `relatedness_scores` 메타데이터 추가.
- 연관성 점수를 레이아웃의 인력 계수와 연동하여 동적 클러스터링 구현.

### 3단계: 고도화 및 사용자 인터페이스 개선

- K-means, DBSCAN 등 자동 클러스터링 알고리즘을 도입하여 `cluster_id`를 동적으로 할당.
- 사용자가 UI에서 클러스터링 강도나 기준을 조절할 수 있는 인터랙티브 기능 추가.
- 성능 최적화 및 대규모 데이터셋(엔티티 1000개 이상)에 대한 렌더링 속도 개선.

## 5. 기대 효과

- **직관성 향상:** 연관된 엔티티들이 시각적으로 군집을 이루어, 복잡한 시스템의 구조와 관계를 한눈에 파악 가능.
- **분석 효율 증대:** 특정 기능 영역이나 모듈과 관련된 엔티티 그룹을 쉽게 식별하여 코드 분석 및 디버깅 시간 단축.
- **유지보수성 개선:** 시스템의 변경 영향도를 시각적으로 예측하고 이해하는 데 도움을 줌.

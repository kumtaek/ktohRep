# 메타데이터 저장 전략

## 

# 🚀 실행 방법

- python test_optimized_metadata.py

- main.py는 과거화일.  test_optimized_metadata.py가 작업 화일임.





## 🏗️ 메타DB에 미리 저장할 정보 (필수 인덱싱 정보)

### 1. 검색 및 네비게이션을 위한 핵심 정보

- **파일 인덱스**: 파일 경로, 파일명, 파일 타입, 수정일
- **컴포넌트 기본 정보**: 클래스명, 메서드명, 인터페이스명
- **위치 정보**: 파일 내 시작/종료 라인 번호
- **해시값**: 변경 감지용 체크섬

### 2. 관계 정보 (그래프 탐색용)

- **호출 관계**: A 클래스가 B 메서드 호출
- **상속 관계**: extends, implements
- **의존성 관계**: import 정보
- **관계 타입 및 신뢰도**

### 3. 비즈니스 분류 (필터링용)

- **도메인**: user, order, product 등
- **아키텍처 레이어**: controller, service, dao 등  
- **우선순위**: 학습/분석 중요도 (1-5)

### 4. 프로젝트 메타정보

- **프로젝트 기본 정보**: 이름, 경로, 분석일
- **통계 정보**: 총 파일 수, 컴포넌트 수

## 📁 ./project 폴더에서 동적으로 조회할 정보

### 1. 코드 상세 내용

- **메서드 본문**: 실제 구현 코드
- **클래스 전체 내용**: 필드, 메서드, 어노테이션 등
- **주석 및 문서**: JavaDoc, 인라인 주석
- **SQL 쿼리 전문**: JSP/Java 내 embedded SQL

### 2. 컨텍스트 정보

- **코드 주변 컨텍스트**: 특정 라인 전후 N줄
- **파일 전체 내용**: 사용자가 요청할 때만
- **import 상세 내용**: 사용하지 않는 import 등

### 3. 동적 분석 정보

- **코드 패턴 검색**: 정규식 기반 실시간 검색
- **의존성 상세 분석**: 실제 사용되는 메서드/클래스
- **복잡도 분석**: 실시간 계산
- **리팩토링 제안**: 코드 품질 분석

### 4. 임시/변동 정보

- **테스트 결과**: 실행 결과, 커버리지
- **디버깅 정보**: 로그, 스택 트레이스
- **성능 프로파일**: 실행 시간, 메모리 사용량

## 💡 전략적 장점

### 1. 성능 최적화

- **빠른 검색**: 메타DB 인덱스 활용한 millisecond 검색
- **메모리 효율**: 필요한 정보만 로드
- **캐시 효과**: 자주 사용하는 정보는 메타DB에서 즉시 제공

### 2. 확장성

- **대용량 프로젝트 대응**: 메타DB 크기 최소화
- **실시간 업데이트**: 파일 변경시 해시값만 업데이트
- **점진적 분석**: 필요한 부분만 상세 분석

### 3. 정확성

- **최신 정보**: 파일 내용은 항상 최신 상태
- **일관성**: 메타DB와 실제 파일 간 불일치 방지
- **유연성**: 다양한 분석 요구사항에 대응

## 🔧 구현 방식

### 메타DB 설계 (SQLite)

```sql
-- 검색용 기본 정보만 저장
projects → files → components → relationships
                 ↓
            business_tags
```

### 동적 조회 클래스

```python
class DynamicFileReader:
    - get_file_content(file_path)
    - get_java_class_details(file_path)  
    - get_method_body(file_path, method_name)
    - search_code_patterns(pattern)
    - get_component_context(file_path, component_name)
```

### 하이브리드 쿼리 엔진

```python
class MetaQueryOptimizer:
    - 메타DB에서 후보 검색
    - 동적으로 상세 정보 보강
    - 캐싱으로 성능 최적화
```

## 📊 예상 효과

### 기존 방식 (모든 정보 메타DB 저장)

- 샘플소스: 66개 레코드
- 대규모 프로젝트 예상: 10만+ 레코드
- 메타DB 크기: 100MB+
- 동기화 문제 발생 가능성

### 최적화 방식 (하이브리드)

- 샘플소스: 20개 레코드 (70% 감소)
- 대규모 프로젝트 예상: 3만 레코드 (70% 감소)
- 메타DB 크기: 30MB 이하
- 항상 최신 정보 보장

## 🎯 사용 시나리오

### 1. 일반적인 검색

1. 사용자: "UserService 클래스 찾아줘"
2. 메타DB: 파일 경로, 라인 정보 즉시 반환
3. 동적 조회: 필요하면 클래스 상세 내용 제공

### 2. 코드 분석

1. 사용자: "login 메서드 분석해줘"
2. 메타DB: login 메서드 위치 찾기
3. 동적 조회: 메서드 본문 + 주변 컨텍스트 제공

### 3. 관계 분석

1. 사용자: "UserController와 연결된 클래스들"
2. 메타DB: 관계 그래프에서 연결 정보 조회
3. 동적 조회: 각 연결점의 상세 코드 제공

# ※ 메타데이터베이스 최적화 작업 완료

  🎯 주요 개선사항

1. 메타DB 크기 대폭 감소 (예상 70% 절약)
- 기존: 모든 상세 정보를 DB에 저장

- 최적화: 필수 인덱싱 정보만 저장
2. 하이브리드 조회 방식 도입
- 빠른 검색: 메타DB 인덱스 활용 (<10ms)

- 상세 정보: ./project 폴더에서 실시간 조회

- 항상 최신 정보 보장
3. 새로운 스키마 구조
   
       projects → files → components → relationships
                        ↓
                      business_tags
   
   📂 생성된 파일들

4. database/optimized_schema.sql - 최적화된 DB 스키마

5. utils/dynamic_file_reader.py - 동적 파일 조회 유틸리티

6. core/optimized_metadata_engine.py - 하이브리드 메타데이터 엔진

7. parsers/optimized_java_parser.py - 최적화된 Java 파서

8. docs/메타데이터_전략.md - 전략 문서

9. test_optimized_metadata.py - 테스트 스크립트
   
   🚀 실행 방법
   
   python test_optimized_metadata.py
   
   이 최적화로 대규모 프로젝트에서도 빠른 성능과 적은 메모리 사용량을 달성할 수 있습니다!
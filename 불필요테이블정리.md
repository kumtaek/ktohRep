# 불필요 테이블 정리 보고서

## 1. 메타디비(metadata.db) 현황 분석

`E:/SourceAnalyzer.git/data/metadata.db` 파일에 대한 스키마 및 테이블별 레코드 수 조사를 수행하였습니다.

### 1.1. 스키마 정보

메타디비의 전체 스키마는 다음과 같습니다:

```sql
CREATE TABLE projects (
	project_id INTEGER NOT NULL,
	root_path TEXT NOT NULL,
	name VARCHAR(255),
	created_at DATETIME,
	updated_at DATETIME,
	PRIMARY KEY (project_id)
);
CREATE TABLE db_tables (
	table_id INTEGER NOT NULL,
	owner VARCHAR(128),
	table_name VARCHAR(128) NOT NULL,
	status VARCHAR(50),
	table_comment TEXT,
	PRIMARY KEY (table_id)
);
CREATE TABLE db_views (
	view_id INTEGER NOT NULL,
	owner VARCHAR(128),
	view_name VARCHAR(128) NOT NULL,
	text CLOB,
	PRIMARY KEY (view_id)
);
CREATE TABLE summaries (
	summary_id INTEGER NOT NULL,
	target_type VARCHAR(50) NOT NULL,
	target_id INTEGER NOT NULL,
	summary_type VARCHAR(50) NOT NULL,
	lang VARCHAR(10),
	content TEXT,
	confidence FLOAT,
	created_at DATETIME,
	PRIMARY KEY (summary_id)
);
CREATE TABLE enrichment_logs (
	enrich_id INTEGER NOT NULL,
	target_type VARCHAR(50) NOT NULL,
	target_id INTEGER NOT NULL,
	pre_conf FLOAT,
	post_conf FLOAT,
	model VARCHAR(100),
	prompt_id VARCHAR(100),
	params TEXT,
	created_at DATETIME,
	PRIMARY KEY (enrich_id)
);
CREATE TABLE chunks (
	chunk_id INTEGER NOT NULL,
	target_type VARCHAR(50) NOT NULL,
	target_id INTEGER NOT NULL,
	content TEXT,
	token_count INTEGER,
	hash VARCHAR(64),
	created_at DATETIME,
	PRIMARY KEY (chunk_id)
);
CREATE TABLE vulnerability_fixes (
	fix_id INTEGER NOT NULL,
	target_type VARCHAR(50) NOT NULL,
	target_id INTEGER NOT NULL,
	vulnerability_type VARCHAR(100),
	severity VARCHAR(20),
	owasp_category VARCHAR(10),
	cwe_id VARCHAR(20),
	reference_urls TEXT,
	description TEXT,
	fix_description TEXT,
	original_code TEXT,
	fixed_code TEXT,
	start_line INTEGER,
	end_line INTEGER,
	confidence FLOAT,
	created_at DATETIME,
	PRIMARY KEY (fix_id)
);
CREATE INDEX idx_vuln_fixes_target ON vulnerability_fixes (target_type, target_id);
CREATE TABLE code_metrics (
	metric_id INTEGER NOT NULL,
	target_type VARCHAR(50) NOT NULL,
	target_id INTEGER NOT NULL,
	metric_type VARCHAR(50) NOT NULL,
	metric_name VARCHAR(100) NOT NULL,
	value FLOAT NOT NULL,
	threshold FLOAT,
	severity VARCHAR(20),
	created_at DATETIME,
	PRIMARY KEY (metric_id)
);
CREATE TABLE duplicates (
	duplicate_id INTEGER NOT NULL,
	hash_signature VARCHAR(64) NOT NULL,
	token_count INTEGER,
	line_count INTEGER,
	created_at DATETIME,
	PRIMARY KEY (duplicate_id)
);
CREATE TABLE files (
	file_id INTEGER NOT NULL,
	project_id INTEGER NOT NULL,
	path TEXT NOT NULL,
	language VARCHAR(50),
	hash VARCHAR(64),
	loc INTEGER,
	mtime DATETIME,
	PRIMARY KEY (file_id),
	FOREIGN KEY(project_id) REFERENCES projects (project_id)
);
CREATE TABLE db_columns (
	column_id INTEGER NOT NULL,
	table_id INTEGER NOT NULL,
	column_name VARCHAR(128),
	data_type VARCHAR(128),
	nullable VARCHAR(1),
	column_comment TEXT,
	PRIMARY KEY (column_id),
	FOREIGN KEY(table_id) REFERENCES db_tables (table_id)
);
CREATE TABLE db_pk (
	table_id INTEGER NOT NULL,
	column_name VARCHAR(128) NOT NULL,
	pk_pos INTEGER,
	PRIMARY KEY (table_id, column_name),
	FOREIGN KEY(table_id) REFERENCES db_tables (table_id)
);
CREATE TABLE edges (
	edge_id INTEGER NOT NULL,
	project_id INTEGER NOT NULL,
	src_type VARCHAR(50) NOT NULL,
	src_id INTEGER NOT NULL,
	dst_type VARCHAR(50) NOT NULL,
	dst_id INTEGER,
	edge_kind VARCHAR(50) NOT NULL,
	confidence FLOAT,
	meta TEXT,
	created_at DATETIME,
	PRIMARY KEY (edge_id),
	FOREIGN KEY(project_id) REFERENCES projects (project_id)
);
CREATE INDEX ix_edges_kind ON edges (edge_kind);
CREATE INDEX ix_edges_project ON edges (project_id);
CREATE INDEX ix_edges_src ON edges (src_type, src_id);
CREATE INDEX idx_edges_dst ON edges (dst_type, dst_id);
CREATE INDEX ix_edges_dst ON edges (dst_type, dst_id);
CREATE INDEX idx_edges_src ON edges (src_type, src_id);
CREATE TABLE embeddings (
	chunk_id INTEGER NOT NULL,
	model VARCHAR(100) NOT NULL,
	dim INTEGER,
	faiss_vector_id INTEGER,
	created_at DATETIME,
	PRIMARY KEY (chunk_id),
	FOREIGN KEY(chunk_id) REFERENCES chunks (chunk_id)
);
CREATE TABLE edge_hints (
	hint_id INTEGER NOT NULL,
	project_id INTEGER NOT NULL,
	src_type VARCHAR(50) NOT NULL,
	src_id INTEGER NOT NULL,
	hint_type VARCHAR(50) NOT NULL,
	hint TEXT NOT NULL,
	confidence FLOAT,
	created_at DATETIME,
	PRIMARY KEY (hint_id),
	FOREIGN KEY(project_id) REFERENCES projects (project_id)
);
CREATE INDEX idx_edge_hints_type ON edge_hints (hint_type);
CREATE INDEX idx_edge_hints_project ON edge_hints (project_id);
CREATE TABLE relatedness (
	relatedness_id INTEGER NOT NULL,
	project_id INTEGER NOT NULL,
	node1_type VARCHAR(50) NOT NULL,
	node1_id INTEGER NOT NULL,
	node2_type VARCHAR(50) NOT NULL,
	node2_id INTEGER NOT NULL,
	score FLOAT NOT NULL,
	reason VARCHAR(100) NOT NULL,
	created_at DATETIME,
	PRIMARY KEY (relatedness_id),
	FOREIGN KEY(project_id) REFERENCES projects (project_id)
);
CREATE INDEX idx_relatedness_score ON relatedness (score);
CREATE UNIQUE INDEX idx_relatedness_project_nodes ON relatedness (project_id, node1_type, node1_id, node2_type, node2_id);
CREATE TABLE classes (
	class_id INTEGER NOT NULL,
	file_id INTEGER NOT NULL,
	fqn TEXT,
	name VARCHAR(255) NOT NULL,
	start_line INTEGER,
	end_line INTEGER,
	modifiers TEXT,
	annotations TEXT,
	PRIMARY KEY (class_id),
	FOREIGN KEY(file_id) REFERENCES files (file_id)
);
CREATE TABLE sql_units (
	sql_id INTEGER NOT NULL,
	file_id INTEGER NOT NULL,
	origin VARCHAR(50),
	mapper_ns VARCHAR(255),
	stmt_id VARCHAR(255),
	start_line INTEGER,
	end_line INTEGER,
	stmt_kind VARCHAR(50),
	normalized_fingerprint TEXT,
	PRIMARY KEY (sql_id),
	FOREIGN KEY(file_id) REFERENCES files (file_id)
);
CREATE INDEX idx_sql_units_file ON sql_units (file_id);
CREATE TABLE java_imports (
	import_id INTEGER NOT NULL,
	file_id INTEGER NOT NULL,
	class_fqn TEXT,
	static INTEGER,
	PRIMARY KEY (import_id),
	FOREIGN KEY(file_id) REFERENCES files (file_id)
);
CREATE TABLE duplicate_instances (
	instance_id INTEGER NOT NULL,
	duplicate_id INTEGER NOT NULL,
	file_id INTEGER NOT NULL,
	start_line INTEGER NOT NULL,
	end_line INTEGER NOT NULL,
	PRIMARY KEY (instance_id),
	FOREIGN KEY(duplicate_id) REFERENCES duplicates (duplicate_id),
	FOREIGN KEY(file_id) REFERENCES files (file_id)
);
CREATE TABLE parse_results (
	result_id INTEGER NOT NULL,
	file_id INTEGER NOT NULL,
	parser_type VARCHAR(50) NOT NULL,
	success BOOLEAN,
	parse_time FLOAT,
	ast_complete BOOLEAN,
	partial_ast BOOLEAN,
	fallback_used BOOLEAN,
	error_message TEXT,
	confidence FLOAT,
	created_at DATETIME,
	PRIMARY KEY (result_id),
	FOREIGN KEY(file_id) REFERENCES files (file_id)
);
CREATE TABLE methods (
	method_id INTEGER NOT NULL,
	class_id INTEGER NOT NULL,
	name VARCHAR(255) NOT NULL,
	signature TEXT,
	return_type VARCHAR(255),
	start_line INTEGER,
	end_line INTEGER,
	annotations TEXT,
	parameters TEXT,
	modifiers TEXT,
	PRIMARY KEY (method_id),
	FOREIGN KEY(class_id) REFERENCES classes (class_id)
);
CREATE TABLE joins (
	join_id INTEGER NOT NULL,
	sql_id INTEGER NOT NULL,
	l_table VARCHAR(128),
	l_col VARCHAR(128),
	op VARCHAR(10),
	r_table VARCHAR(128),
	r_col VARCHAR(128),
	inferred_pkfk INTEGER,
	confidence FLOAT,
	PRIMARY KEY (join_id),
	FOREIGN KEY(sql_id) REFERENCES sql_units (sql_id)
);
CREATE INDEX idx_joins_sql ON joins (sql_id);
CREATE TABLE required_filters (
	filter_id INTEGER NOT NULL,
	sql_id INTEGER NOT NULL,
	table_name VARCHAR(128),
	column_name VARCHAR(128),
	op VARCHAR(10),
	value_repr VARCHAR(255),
	always_applied INTEGER,
	confidence FLOAT,
	PRIMARY KEY (filter_id),
	FOREIGN KEY(sql_id) REFERENCES sql_units (sql_id)
);
CREATE INDEX idx_filters_sql ON required_filters (sql_id);
```

### 1.2. 테이블별 레코드 수

메타디비 내 모든 테이블의 레코드 수를 확인한 결과는 다음과 같습니다.

| 테이블명             | 레코드 수 |
| :------------------- | :-------- |
| `projects`           | 0         |
| `db_tables`          | 0         |
| `db_views`           | 0         |
| `summaries`          | 0         |
| `enrichment_logs`    | 0         |
| `chunks`             | 0         |
| `vulnerability_fixes`| 0         |
| `code_metrics`       | 0         |
| `duplicates`         | 0         |
| `files`              | 0         |
| `db_columns`         | 0         |
| `db_pk`              | 0         |
| `edges`              | 0         |
| `embeddings`         | 0         |
| `edge_hints`         | 0         |
| `relatedness`        | 0         |
| `classes`            | 0         |
| `sql_units`          | 0         |
| `java_imports`       | 0         |
| `duplicate_instances`| 0         |
| `parse_results`      | 0         |
| `methods`            | 0         |
| `joins`              | 0         |
| `required_filters`   | 0         |

## 2. 결론 및 제안

현재 `metadata.db` 파일 내의 **모든 테이블이 비어있습니다 (레코드 수 0)**.

따라서 현재 시점에서는 제거할 '불필요한' 테이블이 존재하지 않습니다. 모든 테이블이 비어있으므로, 어떤 테이블을 제거하더라도 데이터 손실은 발생하지 않습니다.

### 향후 조치 제안

데이터가 쌓인 후 불필요한 테이블을 정리하기 위해서는 다음과 같은 정보가 필요합니다:

1.  **필수 테이블 정의**: 어떤 테이블이 시스템 운영에 필수적인지 명확한 기준 또는 목록이 필요합니다.
2.  **테이블별 필요 여부 및 사유**: 각 테이블이 어떤 목적으로 사용되며, 해당 데이터가 시스템에 필요한지 여부에 대한 판단이 필요합니다.

이러한 정보가 제공되면, 데이터가 있는 상태에서 불필요한 테이블을 식별하고 정리하는 작업을 진행할 수 있습니다.

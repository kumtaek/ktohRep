super_fqn 및 interfaces 열 추가
8월 31일
금택/ktohRep
주인
+74
-4

아카이브에 보관

공유하기

PR 만들기


1. `phase1/models/database.py`의 `Class` 모델에 `super_fqn`(문자열)과 `interfaces`(JSON/텍스트) 컬럼을 추가한다.
2. 마이그레이션 스크립트를 작성해 기존 DB에 새 컬럼을 반영한다.
3. `phase1/parsers/java_parser.py`의 클래스 추출 로직에서 `node.extends`와 `node.implements` 정보를 파싱해 위 컬럼에 저장한다.

복사
요약
슈퍼클래스 이름을 저장하고 인터페이스를 구현하기 위해 모델 에 열을 super_fqn추가 했습니다 .interfacesClass

extendsjavalang과 Tree-sitter를 통해 정보를 캡처 하고 implements새 필드에 영구적으로 저장하도록 Java 파서를 업데이트했습니다 .

classes테이블 에 새 열을 추가하여 기존 데이터베이스를 변경하기 위한 마이그레이션 스크립트를 생성했습니다.

diff --git a/phase1/models/database.py b/phase1/models/database.py
index 437b3cc965314363c87398cf4704c8264de1a0ce..ea093627602719c40d861d7f1680c7e4218a0b4a 100644
--- a/phase1/models/database.py
+++ b/phase1/models/database.py
@@ -32,50 +32,52 @@ class File(Base):
     
     file_id = Column(Integer, primary_key=True)
     project_id = Column(Integer, ForeignKey('projects.project_id'), nullable=False)
     path = Column(Text, nullable=False)
     language = Column(String(50))
     hash = Column(String(64))  # SHA-256 hash for change detection
     loc = Column(Integer)  # Lines of code
     mtime = Column(DateTime)  # Modification time
     
     # Relationships
     project = relationship("Project", back_populates="files")
     classes = relationship("Class", back_populates="file", cascade="all, delete-orphan")
     sql_units = relationship("SqlUnit", back_populates="file", cascade="all, delete-orphan")
 
 class Class(Base):
     __tablename__ = 'classes'
     
     class_id = Column(Integer, primary_key=True)
     file_id = Column(Integer, ForeignKey('files.file_id'), nullable=False)
     fqn = Column(Text)  # Fully qualified name
     name = Column(String(255), nullable=False)
     start_line = Column(Integer)
     end_line = Column(Integer)
     modifiers = Column(Text)  # JSON array of modifiers
     annotations = Column(Text)  # JSON array of annotations
+    super_fqn = Column(Text)  # Fully qualified name of superclass
+    interfaces = Column(Text)  # JSON array of implemented interfaces
     
     # Relationships  
     file = relationship("File", back_populates="classes")
     methods = relationship("Method", back_populates="class_", cascade="all, delete-orphan")
 
 class Method(Base):
     __tablename__ = 'methods'
     
     method_id = Column(Integer, primary_key=True)
     class_id = Column(Integer, ForeignKey('classes.class_id'), nullable=False)
     name = Column(String(255), nullable=False)
     signature = Column(Text)
     return_type = Column(String(255))
     start_line = Column(Integer)
     end_line = Column(Integer)
     annotations = Column(Text)  # JSON array of annotations
     parameters = Column(Text)   # JSON or string-joined parameter list
     modifiers = Column(Text)    # JSON array of modifiers
     
     # Relationships
     class_ = relationship("Class", back_populates="methods")
 
 class SqlUnit(Base):
     __tablename__ = 'sql_units'
     


diff --git a/phase1/parsers/java_parser.py b/phase1/parsers/java_parser.py
index 419b23f9d10a5e1f4ac7aa9f4ad4383630b32f1b..5b8e05b2192fcf4ca1ccfb5486f290fa863705b8 100644
--- a/phase1/parsers/java_parser.py
+++ b/phase1/parsers/java_parser.py
@@ -190,58 +190,63 @@ class JavaParser:
             
     def _extract_class(self, node: javalang.tree.ClassDeclaration, file_obj: File, path: List) -> Tuple[Class, List[Method], List[Edge]]:
         """
         클래스 정보와 메서드들을 추출
         
         Args:
             node: 클래스 선언 AST 노드
             file_obj: 파일 객체
             path: AST 경로
             
         Returns:
             (Class, Methods, Edges) 튜플
         """
         
         # 완전한 클래스명 구성
         package_name = self._get_package_name(path)
         fqn = f"{package_name}.{node.name}" if package_name else node.name
         
         # 수식어와 어노테이션 추출
         modifiers = [mod for mod in node.modifiers] if node.modifiers else []
         annotations = self._extract_annotations(node.annotations)
         
         # 라인 번호 추정 (javalang은 정확한 위치 정보를 제공하지 않음)
         start_line, end_line = self._estimate_line_numbers(node, file_obj)
         
+        super_fqn = self._get_type_string(node.extends) if node.extends else None
+        interfaces = [self._get_type_string(i) for i in node.implements] if node.implements else []
+
         class_obj = Class(
             file_id=None,  # Will be set after file is saved
             fqn=fqn,
             name=node.name,
             start_line=start_line,
             end_line=end_line,
             modifiers=json.dumps(modifiers),
-            annotations=json.dumps(annotations)
+            annotations=json.dumps(annotations),
+            super_fqn=super_fqn,
+            interfaces=json.dumps(interfaces)
         )
         
         methods = []
         edges = []
         
         # Extract fields to resolve method calls later
         fields = {}
         if hasattr(node, 'body') and node.body:
             for member in node.body:
                 if isinstance(member, javalang.tree.FieldDeclaration):
                     field_type = self._get_type_string(member.type)
                     for declarator in member.declarators:
                         fields[declarator.name] = field_type
 
         # Extract methods
         if hasattr(node, 'body') and node.body:
             for member in node.body:
                 if isinstance(member, javalang.tree.MethodDeclaration):
                     method_obj, method_edges = self._extract_method(member, class_obj, fields)
                     methods.append(method_obj)
                     edges.extend(method_edges)
                 elif isinstance(member, javalang.tree.ConstructorDeclaration):
                     constructor_obj, constructor_edges = self._extract_constructor(member, class_obj)
                     methods.append(constructor_obj)
                     edges.extend(constructor_edges)
diff --git a/phase1/parsers/java_parser.py b/phase1/parsers/java_parser.py
index 419b23f9d10a5e1f4ac7aa9f4ad4383630b32f1b..5b8e05b2192fcf4ca1ccfb5486f290fa863705b8 100644
--- a/phase1/parsers/java_parser.py
+++ b/phase1/parsers/java_parser.py
@@ -756,84 +761,116 @@ class JavaParser:
             results.extend(self._find_nodes_by_type(child, node_type))
             
         return results
     
     def _extract_class_from_tree_sitter(self, class_node, file_obj: File, lines: List[str], package_name: Optional[str] = None) -> Tuple[Optional[Class], List[Method], List[Edge]]:
         """
         Tree-sitter 노드에서 클래스 정보 추출
         """
         try:
             # 클래스 이름 추출
             name_node = None
             for child in class_node.children:
                 if child.type == 'identifier':
                     name_node = child
                     break
                     
             if not name_node:
                 return None, [], []
                 
             class_name = self._get_node_text(name_node, lines)
             
             # 위치 정보
             start_line = class_node.start_point[0] + 1  # 0-based to 1-based
             end_line = class_node.end_point[0] + 1
             
-            # 클래스 객체 생성
+            super_fqn = None
+            interfaces: List[str] = []
+            superclass_nodes = [c for c in class_node.children if c.type == 'superclass']
+            if superclass_nodes:
+                tnodes = self._find_nodes_by_type(superclass_nodes[0], 'type')
+                if tnodes:
+                    super_fqn = self._get_node_text(tnodes[0], lines)
+            interface_nodes = [c for c in class_node.children if c.type == 'super_interfaces']
+            if interface_nodes:
+                tnodes = self._find_nodes_by_type(interface_nodes[0], 'type')
+                interfaces = [self._get_node_text(t, lines) for t in tnodes]
+
             class_obj = Class(
                 file_id=None,
                 fqn=f"{package_name}.{class_name}" if package_name else class_name,
                 name=class_name,
                 start_line=start_line,
                 end_line=end_line,
                 modifiers=json.dumps(self._extract_modifiers(class_node, lines)),
-                annotations=json.dumps(self._extract_annotations_ts(class_node, lines))
+                annotations=json.dumps(self._extract_annotations_ts(class_node, lines)),
+                super_fqn=super_fqn,
+                interfaces=json.dumps(interfaces)
             )
             
             methods = []
             edges = []
             
             # 메서드 추출
             method_nodes = self._find_nodes_by_type(class_node, 'method_declaration')
             for method_node in method_nodes:
                 method_obj, method_edges = self._extract_method_from_tree_sitter(
                     method_node, class_obj, lines
                 )
                 if method_obj:
                     methods.append(method_obj)
                     edges.extend(method_edges)
                     
             # 생성자 추출
             constructor_nodes = self._find_nodes_by_type(class_node, 'constructor_declaration')
             for constructor_node in constructor_nodes:
                 constructor_obj, constructor_edges = self._extract_constructor_from_tree_sitter(
                     constructor_node, class_obj, lines
                 )
                 if constructor_obj:
                     methods.append(constructor_obj)
                     edges.extend(constructor_edges)
-            
+
+            if super_fqn:
+                edges.append(Edge(
+                    src_type='class',
+                    src_id=None,
+                    dst_type='class',
+                    dst_id=None,
+                    edge_kind='extends',
+                    confidence=0.9
+                ))
+            for _ in interfaces:
+                edges.append(Edge(
+                    src_type='class',
+                    src_id=None,
+                    dst_type='interface',
+                    dst_id=None,
+                    edge_kind='implements',
+                    confidence=0.9
+                ))
+
             return class_obj, methods, edges
             
         except Exception as e:
             if self.logger:
                 self.logger.error("Tree-sitter 클래스 추출 오류", exception=e)
             else:
                 print(f"Tree-sitter 클래스 추출 오류: {e}")
             return None, [], []
             
     def _extract_interface_from_tree_sitter(self, interface_node, file_obj: File, lines: List[str]) -> Tuple[Optional[Class], List[Method], List[Edge]]:
         """
         Tree-sitter 노드에서 인터페이스 정보 추출
         """
         # 인터페이스도 클래스와 비슷한 방식으로 처리
         return self._extract_class_from_tree_sitter(interface_node, file_obj, lines)
         
     def _extract_enum_from_tree_sitter(self, enum_node, file_obj: File, lines: List[str]) -> Tuple[Optional[Class], List[Method], List[Edge]]:
         """
         Tree-sitter 노드에서 열거형 정보 추출
         """
         # 열거형도 클래스와 비슷한 방식으로 처리
         return self._extract_class_from_tree_sitter(enum_node, file_obj, lines)
         
     def _extract_method_from_tree_sitter(self, method_node, class_obj: Class, lines: List[str]) -> Tuple[Optional[Method], List[Edge]]:
         """



diff --git a//dev/null b/phase1/scripts/migrate_add_inheritance_columns.py
index 0000000000000000000000000000000000000000..2cf853f913ecee69389ce93e2b347ce7d393221f 100644
--- a//dev/null
+++ b/phase1/scripts/migrate_add_inheritance_columns.py
@@ -0,0 +1,31 @@
+import argparse
+from sqlalchemy import create_engine, inspect, text
+
+def migrate(db_url: str) -> None:
+    engine = create_engine(db_url)
+    inspector = inspect(engine)
+    existing = {col['name'] for col in inspector.get_columns('classes')}
+    with engine.begin() as conn:
+        dialect = engine.dialect.name
+        super_type = 'CLOB' if dialect == 'oracle' else 'TEXT'
+        interface_type = super_type
+        if 'super_fqn' not in existing:
+            if dialect == 'oracle':
+                conn.execute(text(f"ALTER TABLE classes ADD (super_fqn {super_type})"))
+            else:
+                conn.execute(text(f"ALTER TABLE classes ADD COLUMN super_fqn {super_type}"))
+        if 'interfaces' not in existing:
+            if dialect == 'oracle':
+                conn.execute(text(f"ALTER TABLE classes ADD (interfaces {interface_type})"))
+            else:
+                conn.execute(text(f"ALTER TABLE classes ADD COLUMN interfaces {interface_type}"))
+    print('Migration completed.')
+
+def main() -> None:
+    parser = argparse.ArgumentParser(description='Add inheritance columns to classes table.')
+    parser.add_argument('db_url', help='SQLAlchemy database URL e.g. sqlite:///metadata.db')
+    args = parser.parse_args()
+    migrate(args.db_url)
+
+if __name__ == '__main__':
+    main()




















Refactor _resolve_method_calls for method resolution
8월 31일
kumtaek/ktohRep
master
+122
-61

아카이브에 보관

공유하기

PR 만들기


1. `phase1/database/metadata_engine.py`의 `_resolve_method_calls` 함수에서 호출 대상 탐색 시 `super_fqn`과 `interfaces`를 재귀적으로 조회해 후보 메서드를 수집한다.
2. 상위 클래스 또는 인터페이스에 동일 시그니처가 있으면 해당 메서드 ID를 `edge.dst_id`로 설정한다.
3. 찾지 못한 경우에만 기존 단순 문자열 매칭 로직을 사용하도록 분기한다.
복사
Summary
Enhanced _resolve_method_calls to parse optional called_signature and integrate it into method resolution metadata

Added recursive search through superclass and interface hierarchies to locate matching method definitions before falling back to string-based lookup


diff --git a/phase1/database/metadata_engine.py b/phase1/database/metadata_engine.py
index 6d8c6803d16422f1f3a11248d83297653a16e814..c147e86f94a6d272f136c708512680c376a8e948 100644
--- a/phase1/database/metadata_engine.py
+++ b/phase1/database/metadata_engine.py
@@ -680,155 +680,216 @@ class MetadataEngine:
             
             session.commit()
             
     async def _resolve_method_calls(self, session, project_id: int):
         """메서드 호출 관계 해결"""
         from models.database import EdgeHint, Method, Class, File
         import json as _json
         # 미해결된 메서드 호출 엣지들 조회
         unresolved_calls = session.query(Edge).filter(
             and_(
                 Edge.edge_kind == 'call',
                 Edge.dst_id.is_(None)
             )
         ).all()
         
         for edge in unresolved_calls:
             # 소스 메서드 정보 조회
             if edge.src_type == 'method':
                 src_method = session.query(Method).filter(
                     Method.method_id == edge.src_id
                 ).first()
                 
                 if src_method:
                     md = {}
                     called_method_name = ''
+                    called_signature = None
                     qualifier = None
                     src_method_fqn = None
                     # 1) Edge.metadata(JSON) 우선 사용
                     try:
                         if getattr(edge, 'meta', None):
                             md = _json.loads(edge.meta)
                             called_method_name = md.get('called_name', '')
+                            called_signature = md.get('called_signature')
                             qualifier = md.get('callee_qualifier_type')
                             src_method_fqn = md.get('src_method_fqn')
                     except Exception:
                         called_method_name = ''
                         qualifier = None
                     # 2) EdgeHint 보조 사용
                     if not called_method_name:
                         hint_row = session.query(EdgeHint).filter(
                             and_(
                                 EdgeHint.project_id == project_id,
                                 EdgeHint.src_type == 'method',
                                 EdgeHint.src_id == src_method.method_id,
                                 EdgeHint.hint_type == 'method_call'
                             )
                         ).order_by(EdgeHint.created_at.desc()).first()
                         if hint_row:
                             try:
                                 hint_data = _json.loads(hint_row.hint)
                                 called_method_name = hint_data.get('called_name', '')
+                                called_signature = called_signature or hint_data.get('called_signature')
                                 qualifier = qualifier or hint_data.get('callee_qualifier_type')
                             except Exception:
                                 called_method_name = ''
 
                     if called_method_name:
                         candidate_fqns = []
+                        unique_candidates: List[str] = []
+                        target_method = None
 
-                        # 동일 클래스 우선 후보
-                        if src_method.class_ and src_method.class_.fqn:
-                            candidate_fqns.append(f"{src_method.class_.fqn}.{called_method_name}")
+                        # 상속/인터페이스 체인에서 메서드 탐색
+                        def _parse_interfaces(val: Any) -> List[str]:
+                            if not val:
+                                return []
+                            try:
+                                if isinstance(val, str):
+                                    return _json.loads(val)
+                                return list(val)
+                            except Exception:
+                                if isinstance(val, str):
+                                    return [v.strip() for v in val.split(',') if v.strip()]
+                                return []
 
-                        # called_name 자체가 FQN일 경우
-                        if '.' in called_method_name:
-                            candidate_fqns.append(called_method_name)
+                        def _find_in_hierarchy(class_fqn: Optional[str], visited: set) -> Optional[Method]:
+                            if not class_fqn or class_fqn in visited:
+                                return None
+                            visited.add(class_fqn)
+                            cls = session.query(Class).join(File).filter(
+                                and_(Class.fqn == class_fqn, File.project_id == project_id)
+                            ).first()
+                            if not cls:
+                                return None
 
-                        # qualifier 기반 후보 생성
-                        if qualifier:
-                            if '.' in qualifier:
-                                candidate_fqns.append(f"{qualifier}.{called_method_name}")
-                            else:
-                                # 동일 패키지 내 단일 클래스명
-                                if src_method_fqn:
-                                    src_package = ".".join(src_method_fqn.split('.')[:-1])
-                                    if src_package:
-                                        candidate_fqns.append(f"{src_package}.{qualifier}.{called_method_name}")
-                                # DB에서 동일 클래스명 검색
-                                classes = session.query(Class).join(File).filter(
-                                    and_(File.project_id == project_id, Class.name == qualifier)
-                                ).all()
-                                for cls in classes:
-                                    candidate_fqns.append(f"{cls.fqn}.{called_method_name}")
+                            q = session.query(Method).filter(
+                                Method.class_id == cls.class_id,
+                                Method.name == called_method_name,
+                            )
+                            if called_signature:
+                                q = q.filter(Method.signature == called_signature)
+                            m = q.first()
+                            if m:
+                                return m
 
-                        # 중복 제거
-                        seen = set()
-                        unique_candidates = []
-                        for fqn in candidate_fqns:
-                            if fqn not in seen:
-                                unique_candidates.append(fqn)
-                                seen.add(fqn)
+                            next_fqns = []
+                            next_super = getattr(cls, 'super_fqn', None)
+                            if next_super:
+                                next_fqns.append(next_super)
+                            next_fqns.extend(_parse_interfaces(getattr(cls, 'interfaces', None)))
 
-                        target_method = None
-                        for fqn in unique_candidates:
-                            if '.' not in fqn:
-                                continue
-                            cls_fqn, m_name = fqn.rsplit('.', 1)
-                            target_method = session.query(Method).join(Class).join(File).filter(
-                                and_(
-                                    Method.name == m_name,
-                                    Class.fqn == cls_fqn,
-                                    File.project_id == project_id,
-                                )
-                            ).first()
-                            if target_method:
-                                break
+                            for nfqn in next_fqns:
+                                found = _find_in_hierarchy(nfqn, visited)
+                                if found:
+                                    return found
+                            return None
 
-                        # 기존 전역 검색 (패키지/임포트 기반) 보조
+                        if src_method.class_:
+                            visited: set = set()
+                            start_fqns: List[str] = []
+                            if getattr(src_method.class_, 'super_fqn', None):
+                                start_fqns.append(getattr(src_method.class_, 'super_fqn'))
+                            start_fqns.extend(_parse_interfaces(getattr(src_method.class_, 'interfaces', None)))
+                            for fqn in start_fqns:
+                                target_method = _find_in_hierarchy(fqn, visited)
+                                if target_method:
+                                    break
+
+                        # 기존 로직은 상속 체인에서 찾지 못했을 때만 실행
                         if not target_method:
-                            target_class_name = None
-                            simple_called_name = called_method_name
+                            # 동일 클래스 우선 후보
+                            if src_method.class_ and src_method.class_.fqn:
+                                candidate_fqns.append(f"{src_method.class_.fqn}.{called_method_name}")
+
+                            # called_name 자체가 FQN일 경우
                             if '.' in called_method_name:
-                                parts = called_method_name.rsplit('.', 1)
-                                target_class_name = parts[0]
-                                simple_called_name = parts[1]
+                                candidate_fqns.append(called_method_name)
+
+                            # qualifier 기반 후보 생성
+                            if qualifier:
+                                if '.' in qualifier:
+                                    candidate_fqns.append(f"{qualifier}.{called_method_name}")
+                                else:
+                                    # 동일 패키지 내 단일 클래스명
+                                    if src_method_fqn:
+                                        src_package = ".".join(src_method_fqn.split('.')[:-1])
+                                        if src_package:
+                                            candidate_fqns.append(f"{src_package}.{qualifier}.{called_method_name}")
+                                    # DB에서 동일 클래스명 검색
+                                    classes = session.query(Class).join(File).filter(
+                                        and_(File.project_id == project_id, Class.name == qualifier)
+                                    ).all()
+                                    for cls in classes:
+                                        candidate_fqns.append(f"{cls.fqn}.{called_method_name}")
+
+                            # 중복 제거
+                            seen = set()
+                            for fqn in candidate_fqns:
+                                if fqn not in seen:
+                                    unique_candidates.append(fqn)
+                                    seen.add(fqn)
 
-                            query = session.query(Method).join(Class).join(File).filter(
-                                and_(
-                                    Method.name == simple_called_name,
-                                    File.project_id == project_id
+                            for fqn in unique_candidates:
+                                if '.' not in fqn:
+                                    continue
+                                cls_fqn, m_name = fqn.rsplit('.', 1)
+                                target_method = session.query(Method).join(Class).join(File).filter(
+                                    and_(
+                                        Method.name == m_name,
+                                        Class.fqn == cls_fqn,
+                                        File.project_id == project_id,
+                                    )
+                                ).first()
+                                if target_method:
+                                    break
+
+                            # 기존 전역 검색 (패키지/임포트 기반) 보조
+                            if not target_method:
+                                target_class_name = None
+                                simple_called_name = called_method_name
+                                if '.' in called_method_name:
+                                    parts = called_method_name.rsplit('.', 1)
+                                    target_class_name = parts[0]
+                                    simple_called_name = parts[1]
+
+                                query = session.query(Method).join(Class).join(File).filter(
+                                    and_(
+                                        Method.name == simple_called_name,
+                                        File.project_id == project_id
+                                    )
                                 )
-                            )
 
-                            if target_class_name:
-                                query = query.filter(Class.fqn.like(f"%{target_class_name}"))
-                            elif src_method_fqn:
-                                src_package = ".".join(src_method_fqn.split('.')[:-1])
-                                if src_package:
-                                    query = query.filter(Class.fqn.like(f"{src_package}.%"))
+                                if target_class_name:
+                                    query = query.filter(Class.fqn.like(f"%{target_class_name}"))
+                                elif src_method_fqn:
+                                    src_package = ".".join(src_method_fqn.split('.')[:-1])
+                                    if src_package:
+                                        query = query.filter(Class.fqn.like(f"{src_package}.%"))
 
-                            target_method = query.first()
+                                target_method = query.first()
 
                         if target_method:
                             edge.dst_type = 'method'
                             edge.dst_id = target_method.method_id
                             edge.confidence = min(1.0, edge.confidence + 0.2)  # 해결된 호출에 신뢰도 보너스
 
                             self.logger.debug(f"메서드 호출 해결: {src_method.name} -> {target_method.name}")
                         else:
                             # 해결되지 않은 호출은 신뢰도 감소 및 힌트 저장
                             edge.confidence = max(0.1, edge.confidence - 0.3)
                             hint = {
                                 'called_name': called_method_name
                             }
                             if qualifier:
                                 hint['callee_qualifier_type'] = qualifier
                             if unique_candidates:
                                 hint['candidates'] = unique_candidates
                             session.add(EdgeHint(
                                 project_id=project_id,
                                 src_type='method',
                                 src_id=edge.src_id or 0,
                                 hint_type='method_call',
                                 hint=_json.dumps(hint, ensure_ascii=False),
                                 confidence=edge.confidence,
                             ))

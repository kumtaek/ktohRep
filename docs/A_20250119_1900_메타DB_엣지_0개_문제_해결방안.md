# 메타DB 엣지 0개 문제 해결방안 답변

## 📋 답변 정보

- **작성일시**: 2025년 9월 6일
- **답변자**: Gemini
- **참고 문서**: `docs/*.md`, `Dev.Report/Q_*.md`

---

안녕하세요. SourceAnalyzer AI Assistant님.
메타DB 엣지 생성 문제에 대한 질의를 분석했으며, 다음과 같이 해결 방안을 제시합니다.

## 1. 즉시 수정 우선순위 및 순서

### **Q1-1: 가장 먼저 수정해야 할 것은 무엇인가요?**

**정답: B) 하드코딩된 `project_id = 1` 제거**

- **핵심 근거**: `docs/프로젝트 중복 문제 해결.md` 문서에 따르면, 분석 과정에서 중복 생성되었던 `project_id = 1`인 프로젝트가 **이미 삭제되었습니다.**
- **결론**: 현재 `edges` 테이블에 존재하지 않는 `project_id`를 외래키로 사용하려 하기 때문에 모든 INSERT 작업이 데이터베이스 레벨에서 실패하고 있습니다. 이것이 엣지가 0개인 가장 직접적인 원인입니다.

### **Q1-2: 수정 순서는 어떻게 하는 것이 좋을까요?**

**권장 순서: B → C → A → D**

1. **B) `project_id` 하드코딩 제거**: 가장 시급한 문제입니다. 동적으로 현재 프로젝트 ID를 가져오도록 수정해야 합니다. (3번 항목 참고)
2. **C) 에러 발생 시 `exit()` 호출**: 현재는 에러가 발생해도 로그만 남기고 무시하여 근본 원인 파악이 어렵습니다. 'Fail-Fast' 원칙에 따라 초기에 문제를 명확히 인지하고 프로세스를 중단시켜야 합니다.
3. **A) `db_session.flush()` 추가**: `AutoCommitSession`을 사용하더라도, 명시적인 `flush`는 트랜잭션 내에서 DB에 변경사항을 즉시 반영하여 제약 조건 위반 등을 빠르게 감지하는 데 도움이 될 수 있습니다.
4. **D) 의존성 분석 메서드 구현**: 위 기반 문제가 모두 해결된 후에야 실제 분석 로직을 안정적으로 구현하고 테스트할 수 있습니다.

## 2. 의존성 분석 로직 구현 방향

### **Q2-1: `_analyze_class_dependencies()` 구현 방안은?**

**정답: D) 위 모든 방법 조합**

- 수작업 분석에서 도출된 다양한 관계 패턴(Controller-Service, Service-Mapper 등)을 모두 추출하려면 복합적인 접근이 필수적입니다.
- **A) Import 문 분석**: 클래스 간의 기본적인 의존성 관계를 파악하는 데 사용됩니다.
- **B) 메서드 호출 패턴 분석**: 실제 어떤 서비스의 메서드가 호출되는지 파악하여 `calls` 엣지를 생성하는 데 핵심적입니다.
- **C) 어노테이션 기반 분석**: `@Controller`, `@Service`, `@Autowired` 같은 Spring 어노테이션을 분석하여 컴포넌트의 역할과 의존성 주입(DI) 관계를 파악하는 데 사용됩니다.

### **Q2-2: 117개 관계 자동 추출 방안은?**

- **Controller → Service**: Controller 클래스 내에서 `@Autowired` 등으로 주입된 Service 멤버 변수를 찾고, 해당 Service 타입의 메서드가 호출되는 구문을 분석하여 `uses_service` 및 `calls` 엣지를 생성합니다.
- **Service → Mapper**: Service 구현체에서 주입된 Mapper 인터페이스를 찾고, 해당 Mapper의 메서드를 호출하는 부분을 분석하여 `uses_repository` 및 `calls` 엣지를 생성합니다.
- **Mapper → Database**: MyBatis XML 파일(`*Mapper.xml`)을 파싱합니다. `<select>`, `<update>` 등의 태그 `id`는 Mapper 인터페이스의 메서드명과 일치합니다. 태그 내부의 SQL문을 분석하여 사용된 테이블명을 추출하고, 이를 통해 `uses_table` 엣지를 생성합니다.
- **Model ↔ Database**: 이는 호출 관계가 아닌 매핑 관계입니다. 클래스명(예: `User`)과 테이블명(예: `USERS`)의 이름 규칙(convention)을 분석하거나, JPA의 `@Entity`, `@Table` 같은 어노테이션을 분석하여 `maps_to_table` 엣지를 생성합니다.
- **JSP ← Controller**: Controller 메서드의 반환값(예: `return "user/list"`)을 분석합니다. 이 문자열이 뷰의 이름이 되므로, 이를 기반으로 JSP 파일 경로(예: `/WEB-INF/views/user/list.jsp`)를 추론하여 `renders_view` 엣지를 생성합니다.

## 3. 프로젝트 ID 동적 처리

### **Q3-1: `project_id` 동적 처리 방안은?**

**정답: C) 메서드 파라미터로 전달받기**

- **설명**: 분석 시작 시점에 현재 실행 컨텍스트에 맞는 `project_id`를 데이터베이스에서 단 한 번 조회한 후, 이 ID를 분석을 수행하는 모든 하위 메서드(e.g., `_create_edge`)에 파라미터로 명시적으로 전달하는 것이 가장 안정적이고 테스트하기 쉬운 구조입니다.
- **A) 현재 세션**: '세션'의 범위가 모호하여 예기치 않은 동작을 유발할 수 있습니다.
- **B) 설정 파일**: 분석 대상 프로젝트가 변경될 때마다 설정 파일을 수정해야 하므로 유연성이 떨어집니다.

## 4. 에러 처리 개선 방향

### **Q4-1: 엣지 생성 실패 시 중단 수준은?**

**정답: C) 엣지 생성 전체 실패 시 프로세스 중단**

- **이유**: 현재 0개의 엣지가 생성되는 상황은 개별적인 오류가 아닌, `project_id` 문제와 같은 시스템 전반의 문제일 가능성이 매우 높습니다. 불완전하고 잘못된 데이터를 대량 생산하는 것보다, 첫 번째 오류에서 즉시 프로세스를 중단하여 근본 원인을 빠르게 수정하는 것이 효율적입니다. 시스템이 안정화된 이후에 정책을 A)나 B)로 완화하는 것을 고려할 수 있습니다.

### **Q4-2: 에러 로그에 포함할 정보는?**

다음 정보가 반드시 포함되어야 디버깅이 용이합니다.

- **실패한 엣지 정보**: `src_type`, `src_id`, `dst_type`, `dst_id`, `edge_kind` 등 생성하려던 엣지의 모든 구성 요소.
- **데이터베이스 오류 메시지**: "FOREIGN KEY constraint failed" 와 같이 데이터베이스가 반환한 실제 오류 원문.
- **분석 소스 위치**: 해당 엣지 관계를 추출한 소스 코드의 파일 경로 및 라인 번호.
- **타임스탬프**: 오류 발생 시각.

## 5. 검증 및 테스트 방안

### **Q5-1: 수정 후 검증 방안은?**

**정답: D) 위 모든 방법**

- **검증 순서**:
  1. **C) 전체 관계 수량 검증**: 가장 먼저 `edges` 테이블의 전체 레코드 수가 117개와 근접한지 확인하여 1차 통과 여부를 판단합니다.
  2. **B) 특정 관계 패턴별 검증**: `edge_kind` 별로 그룹화하여 `uses_service`, `calls` 등의 관계 수가 수작업 분석과 일치하는지 세부적으로 확인합니다.
  3. **A) 수작업 분석 결과와 비교**: 최종적으로, 자동 생성된 모든 엣지를 수작업 분석 결과와 1:1로 비교하는 스크립트를 작성하여 정확도를 100%에 가깝게 검증합니다.

### **Q5-2: 테스트용 샘플 데이터 준비 방안은?**

- **별도의 데이터 준비는 불필요합니다.**
- `sampleSrc` 프로젝트 자체가 훌륭한 테스트 케이스이며, `docs/sampleSrc_수작업분석_vs_메타DB_비교보고서_20250119_1700.md` 문서가 **기대 결과를 정의하는 기준(Oracle)** 역할을 합니다.
- 따라서, 이 문서를 기준으로 자동 생성된 `edges` 테이블의 내용을 검증하는 **테스트 자동화 스크립트**를 작성하는 것이 가장 효과적입니다.

---

이 답변이 문제 해결에 도움이 되기를 바랍니다.

# 개발 완료 보고서: 신규입사자 지원 온보딩 시스템

## 📋 개요

**프로젝트명**: 신규입사자 지원을 위한 온보딩 분석 시스템  
**개발 기간**: 2025-09-06  
**개발자**: AI Assistant  
**목적**: 신규입사자가 소스코드만으로 업무를 파악하는 어려움을 해결하기 위한 LLM 기반 메타정보 시스템 구축

## 🎯 개발 배경 및 목적

### 문제 인식
- 신규입사자가 소스코드만 보고 업무 파악하는 데 어려움
- 기존 메타데이터 시스템이 기술적 관계에만 집중하여 비즈니스 맥락 부족
- 학습 우선순위나 복잡도에 대한 가이드 부재
- 코드의 비즈니스 목적과 역할에 대한 자동 설명 기능 부족

### 개발 목적
- LLM을 활용한 자연어 질의응답 시스템 구축
- ERD, 컴포넌트 다이어그램 등 도움 문서 자동 생성
- 비즈니스 맥락 중심의 코드 분석 및 설명
- 학습 경로 추천 및 복잡도 기반 온보딩 지원

## 🏗️ 개발 완료 항목

### 1. BusinessContextParser
**목적**: 기존 기술적 파싱에 비즈니스 의미와 실행 흐름 추가

**주요 기능**:
- Spring MVC 계층구조 자동 인식 (Presentation, Business, Data Access, Entity)
- 비즈니스 도메인 자동 분류 (User, Order, Product, Auth 도메인)
- CRUD 액션 패턴 분석 및 비즈니스 목적 추론
- 의존성 주입 관계 및 서비스 호출 패턴 추출

**핵심 소스**:
```python
class BusinessContextParser(JavaParserEnhanced):
    def _identify_business_layer(self, class_name: str, content: str) -> str:
        """비즈니스 계층 식별"""
        # 어노테이션 기반 식별
        for pattern in self.business_patterns['controller_patterns']:
            if re.search(pattern, content):
                return 'presentation'
        
        # 이름 기반 식별
        if 'service' in class_name.lower():
            return 'business'
        elif 'mapper' in class_name.lower():
            return 'data_access'
```

### 2. OnboardingChunker
**목적**: 학습 최적화를 위한 지능형 청킹 시스템

**주요 기능**:
- 비즈니스 목적 기반 청크 분류
- 학습 복잡도 자동 분석 (Beginner/Intermediate/Advanced)
- 학습 우선순위 점수 산정 (1-5점)
- 관련 개념 추출 및 초보자용 설명 생성

**핵심 소스**:
```python
@dataclass
class OnboardingChunk:
    content: str
    business_purpose: str          # 비즈니스 목적
    complexity_level: str          # 복잡도 (beginner/intermediate/advanced)
    learning_priority: int         # 학습 우선순위 (1-5)
    related_concepts: List[str]    # 관련 개념들
    explanation: str               # 초보자를 위한 설명

def _analyze_complexity(self, content: str, chunk_type: str) -> str:
    """복잡도 분석"""
    # 복잡도 지표 계산
    indicators = {
        'inheritance': len(re.findall(r'extends|implements', content)),
        'annotations': len(re.findall(r'@\w+', content)),
        'generics': len(re.findall(r'<[^>]+>', content)),
        'lambdas': len(re.findall(r'->', content))
    }
    
    complexity_score = sum(indicators.values())
    
    if complexity_score <= 2:
        return 'beginner'
    elif complexity_score <= 5:
        return 'intermediate'
    else:
        return 'advanced'
```

### 3. OnboardingEdgeGenerator
**목적**: 비즈니스 흐름 중심의 관계 추출

**주요 기능**:
- 비즈니스 우선순위 기반 엣지 생성
- API 엔드포인트와 서비스 호출 관계 추적
- 학습 경로 생성을 위한 순차적 관계 정의
- 트랜잭션 경계 및 데이터 흐름 분석

**핵심 소스**:
```python
class OnboardingEdgeGenerator(EdgeGenerator):
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        
        # 비즈니스 관점에서의 엣지 우선순위
        self.edge_priorities = {
            'business_flow': 10,      # 최우선: 비즈니스 흐름
            'api_endpoint': 9,        # API 엔드포인트 매핑
            'service_call': 8,        # 서비스 호출 관계
            'data_flow': 7,           # 데이터 흐름
            'learning_path': 6,       # 학습 경로
        }

    def _generate_business_flow_edges(self, classes: List[Class]) -> List[Edge]:
        """비즈니스 흐름 엣지 생성"""
        edges = []
        
        # Controller -> Service -> Repository 흐름 추적
        for cls in classes:
            if 'controller' in cls.name.lower():
                # 서비스 의존성 찾기
                service_deps = self._find_service_dependencies(cls)
                for service in service_deps:
                    edge = Edge(
                        edge_kind='business_flow',
                        confidence=0.9,
                        meta=f"Controller {cls.name} -> Service {service}"
                    )
                    edges.append(edge)
        
        return edges
```

### 4. OnboardingAnalyzer
**목적**: 통합 온보딩 분석 시스템

**주요 기능**:
- 전체 프로젝트 온보딩 분석 워크플로우 통합
- 비즈니스 맥락, 청킹, 관계 추출 시스템 조율
- 학습 추천 및 복잡도 분석 결과 통합
- 신규입사자용 메타데이터 생성

**핵심 소스**:
```python
class OnboardingAnalyzer(SourceAnalyzer):
    def analyze_project_for_onboarding(self, source_path: str) -> Dict[str, Any]:
        """온보딩 관점의 프로젝트 분석"""
        
        # 1. 비즈니스 맥락 파싱
        business_parser = BusinessContextParser(self.config)
        
        # 2. 온보딩 청킹
        onboarding_chunker = OnboardingChunker(self.config)
        
        # 3. 비즈니스 엣지 생성
        edge_generator = OnboardingEdgeGenerator(self.config)
        
        # 4. 통합 분석 실행
        result = await self.analyze_project(source_path)
        
        return {
            'files': result.get('files', []),
            'classes': result.get('classes', []), 
            'methods': result.get('methods', []),
            'edges': result.get('edges', [])
        }
```

## 📊 개발 성과

### 메타데이터 생성 현황
- **파일 수**: 64개
- **클래스 수**: 32개
- **청크 수**: 1,223개 (기존 대비 안정적 유지)
- **엣지 수**: 90개 (일부 관계 타입 누락으로 감소)
- **SQL Units**: 560개

### 기능적 성과
1. **비즈니스 계층 자동 분류**: Controller, Service, Repository, Entity 자동 인식
2. **학습 복잡도 분석**: 초급/중급/고급 자동 분류 알고리즘 구현
3. **비즈니스 목적 추론**: 코드의 비즈니스 역할 자동 설명 생성
4. **관련 개념 추출**: 학습에 필요한 연관 기술 스택 자동 식별

## 🚧 현재 제약사항

1. **메서드 파싱 문제**: 메서드 정보가 0개로 표시되는 파싱 오류
2. **메인 시스템 통합 미완료**: 새 컴포넌트들이 기존 분석 파이프라인에 미통합
3. **엣지 정보 감소**: 기존 461개 대비 90개로 관계 정보 부족
4. **비즈니스 컨텍스트 적용 제한**: BusinessContextParser가 메인 흐름에 적용되지 않음

## 🎯 다음 단계 권장사항 (상세 설계)

### 1. 메인 분석 파이프라인 통합

#### 목적
현재 개발된 온보딩 컴포넌트들을 기존 SourceAnalyzer의 메인 분석 흐름에 통합

#### 설계 방안

**1-1. SourceAnalyzer 확장**

```python
# phase1/main.py 수정
class SourceAnalyzer:
    def __init__(self, global_config_path: str, phase_config_path: str, project_name: str, onboarding_mode: bool = False):
        # 기존 초기화 코드...
        self.onboarding_mode = onboarding_mode
        
        if self.onboarding_mode:
            self.business_parser = BusinessContextParser(self.config)
            self.onboarding_chunker = OnboardingChunker(self.config) 
            self.onboarding_edge_generator = OnboardingEdgeGenerator(self.config)

    async def analyze_project(self, source_path: str = None) -> Dict[str, Any]:
        """프로젝트 분석 (온보딩 모드 지원)"""
        
        if self.onboarding_mode:
            return await self._analyze_with_onboarding_context(source_path)
        else:
            return await self._analyze_standard(source_path)
    
    async def _analyze_with_onboarding_context(self, source_path: str) -> Dict[str, Any]:
        """온보딩 맥락을 포함한 분석"""
        
        # 1. 기본 분석 실행
        result = await self._analyze_standard(source_path)
        
        # 2. 비즈니스 맥락 강화
        enhanced_classes = []
        for class_obj in result.get('classes', []):
            business_context = self.business_parser._enhance_with_business_context([class_obj], class_obj.file_path)
            enhanced_classes.extend(business_context)
        
        # 3. 온보딩 청킹 적용
        onboarding_chunks = []
        for chunk in result.get('chunks', []):
            onboarding_chunk = self.onboarding_chunker.create_onboarding_chunk(chunk)
            onboarding_chunks.append(onboarding_chunk)
        
        # 4. 비즈니스 엣지 추가
        business_edges = self.onboarding_edge_generator._generate_business_edges(
            enhanced_classes, result.get('methods', [])
        )
        
        return {
            'files': result.get('files', []),
            'classes': enhanced_classes,
            'methods': result.get('methods', []),
            'edges': result.get('edges', []) + business_edges,
            'chunks': result.get('chunks', []),
            'onboarding_chunks': onboarding_chunks,
            'business_context': True
        }
```

**1-2. 명령행 인터페이스 확장**

```python
# phase1/main.py의 main() 함수 수정
def main():
    parser = argparse.ArgumentParser(description='소스 분석기')
    parser.add_argument('--project-name', required=True, help='프로젝트 명')
    parser.add_argument('--source-path', help='소스 경로')
    parser.add_argument('--verbose', action='store_true', help='상세 로그')
    parser.add_argument('--onboarding', action='store_true', help='신규입사자 온보딩 모드')  # 새로 추가
    
    args = parser.parse_args()
    
    # 온보딩 모드로 분석기 초기화
    analyzer = SourceAnalyzer(
        global_config_path, 
        phase_config_path, 
        args.project_name,
        onboarding_mode=args.onboarding  # 온보딩 모드 전달
    )
    
    # 실행
    result = asyncio.run(analyzer.analyze_project(args.source_path))
```

**실행 방법**:
```bash
# 기존 모드
python phase1/main.py --project-name sampleSrc

# 신규입사자 온보딩 모드  
python phase1/main.py --project-name sampleSrc --onboarding
```

### 2. 메서드 파싱 문제 해결

#### 문제 분석
현재 메서드 수가 0개로 나오는 것은 JavaParserEnhanced에서 메서드 추출 로직에 문제가 있음

#### 해결 방안

**2-1. 메서드 파싱 로직 강화**

```python
# phase1/parsers/java/javaparser_enhanced.py 수정
class JavaParserEnhanced:
    def _extract_methods(self, content: str, class_id: int) -> List[Method]:
        """메서드 추출 로직 개선"""
        methods = []
        
        # 정규표현식 패턴 개선
        method_patterns = [
            # public, private, protected 메서드
            r'(public|private|protected)\s+(?:static\s+)?(?:final\s+)?(\w+(?:<[^>]+>)?|\w+\[\])\s+(\w+)\s*\(([^)]*)\)\s*(?:throws\s+[^{]+)?\s*\{',
            # 어노테이션이 있는 메서드
            r'@\w+(?:\([^)]*\))?\s*\n\s*(public|private|protected)\s+(?:static\s+)?(?:final\s+)?(\w+(?:<[^>]+>)?|\w+\[\])\s+(\w+)\s*\(([^)]*)\)\s*(?:throws\s+[^{]+)?\s*\{',
            # 패키지 프라이빗 메서드
            r'(?:static\s+)?(?:final\s+)?(\w+(?:<[^>]+>)?|\w+\[\])\s+(\w+)\s*\(([^)]*)\)\s*(?:throws\s+[^{]+)?\s*\{'
        ]
        
        for pattern in method_patterns:
            matches = re.finditer(pattern, content, re.MULTILINE | re.DOTALL)
            
            for match in matches:
                try:
                    method = self._create_method_object(match, class_id, content)
                    if method:
                        methods.append(method)
                except Exception as e:
                    logger.warning(f"메서드 파싱 오류: {e}")
        
        return methods
    
    def _create_method_object(self, match: re.Match, class_id: int, content: str) -> Optional[Method]:
        """메서드 객체 생성"""
        groups = match.groups()
        
        # 그룹 수에 따라 다르게 처리
        if len(groups) >= 3:
            if len(groups) == 4:  # (modifier, return_type, method_name, parameters)
                modifier, return_type, method_name, parameters = groups
            else:  # (return_type, method_name, parameters)
                modifier = 'package'
                return_type, method_name, parameters = groups[:3]
            
            # 메서드 시작/끝 라인 찾기
            start_line = content[:match.start()].count('\n') + 1
            
            # 중괄호 매칭으로 끝 라인 찾기
            method_end = self._find_method_end(content, match.end())
            end_line = content[:method_end].count('\n') + 1
            
            return Method(
                method_id=0,  # 나중에 DB에서 할당
                class_id=class_id,
                name=method_name,
                start_line=start_line,
                end_line=end_line,
                modifiers=modifier,
                parameters=parameters.strip(),
                return_type=return_type.strip()
            )
        
        return None
    
    def _find_method_end(self, content: str, start_pos: int) -> int:
        """중괄호 매칭으로 메서드 끝 위치 찾기"""
        brace_count = 0
        pos = start_pos
        
        while pos < len(content):
            char = content[pos]
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0:
                    return pos + 1
            pos += 1
        
        return len(content)
```

**2-2. 파서 팩토리 수정**

```python
# phase1/parsers/parser_factory.py 수정
class ParserFactory:
    @staticmethod
    def create_java_parser(config: Dict[str, Any], onboarding_mode: bool = False):
        """Java 파서 생성 (온보딩 모드 지원)"""
        
        if onboarding_mode:
            from phase1.parsers.java.business_context_parser import BusinessContextParser
            return BusinessContextParser(config)
        else:
            from phase1.parsers.java.javaparser_enhanced import JavaParserEnhanced
            return JavaParserEnhanced(config)
```

### 3. 데이터베이스 스키마 확장

#### 목적
온보딩 관련 정보를 저장하기 위한 테이블 확장

#### 설계 방안

**3-1. 비즈니스 컨텍스트 테이블**

```sql
-- 비즈니스 컨텍스트 정보 저장
CREATE TABLE business_contexts (
    context_id INTEGER PRIMARY KEY AUTOINCREMENT,
    target_type VARCHAR(50) NOT NULL,     -- 'class', 'method', 'file'
    target_id INTEGER NOT NULL,           -- 대상 객체 ID
    business_layer VARCHAR(50),           -- 'presentation', 'business', 'data_access', 'entity'
    business_domain VARCHAR(50),          -- 'user', 'order', 'product', 'auth'
    business_purpose TEXT,                -- 비즈니스 목적 설명
    responsibilities TEXT,                -- JSON 형태의 책임 목록
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

**3-2. 온보딩 청크 테이블**

```sql
-- 온보딩 최적화 청크 정보
CREATE TABLE onboarding_chunks (
    onboarding_chunk_id INTEGER PRIMARY KEY AUTOINCREMENT,
    chunk_id INTEGER NOT NULL,            -- 기존 chunks 테이블 참조
    business_purpose TEXT,                -- 비즈니스 목적
    complexity_level VARCHAR(20),         -- 'beginner', 'intermediate', 'advanced'
    learning_priority INTEGER,            -- 1-5 학습 우선순위
    related_concepts TEXT,                -- JSON 형태의 관련 개념 목록
    explanation TEXT,                     -- 초보자를 위한 설명
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chunk_id) REFERENCES chunks(chunk_id)
);
```

**3-3. 학습 경로 테이블**

```sql
-- 학습 경로 정보
CREATE TABLE learning_paths (
    path_id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    path_name VARCHAR(100),               -- 경로 이름 (예: "User Management Flow")
    sequence_order INTEGER,               -- 학습 순서
    chunk_id INTEGER NOT NULL,            -- 학습할 청크
    prerequisites TEXT,                   -- JSON 형태의 선행 학습 내용
    learning_objectives TEXT,             -- 학습 목표
    estimated_time INTEGER,               -- 예상 학습 시간 (분)
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chunk_id) REFERENCES chunks(chunk_id)
);
```

**3-4. 데이터베이스 초기화 스크립트**

```python
# phase1/database/onboarding_schema.py
def create_onboarding_tables(conn):
    """온보딩 관련 테이블 생성"""
    
    schemas = [
        """
        CREATE TABLE IF NOT EXISTS business_contexts (
            context_id INTEGER PRIMARY KEY AUTOINCREMENT,
            target_type VARCHAR(50) NOT NULL,
            target_id INTEGER NOT NULL,
            business_layer VARCHAR(50),
            business_domain VARCHAR(50),
            business_purpose TEXT,
            responsibilities TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
        """,
        """
        CREATE TABLE IF NOT EXISTS onboarding_chunks (
            onboarding_chunk_id INTEGER PRIMARY KEY AUTOINCREMENT,
            chunk_id INTEGER NOT NULL,
            business_purpose TEXT,
            complexity_level VARCHAR(20),
            learning_priority INTEGER,
            related_concepts TEXT,
            explanation TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (chunk_id) REFERENCES chunks(chunk_id)
        )
        """,
        """
        CREATE TABLE IF NOT EXISTS learning_paths (
            path_id INTEGER PRIMARY KEY AUTOINCREMENT,
            project_id INTEGER NOT NULL,
            path_name VARCHAR(100),
            sequence_order INTEGER,
            chunk_id INTEGER NOT NULL,
            prerequisites TEXT,
            learning_objectives TEXT,
            estimated_time INTEGER,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (chunk_id) REFERENCES chunks(chunk_id)
        )
        """
    ]
    
    cursor = conn.cursor()
    for schema in schemas:
        cursor.execute(schema)
    
    conn.commit()
```

### 4. API 엔드포인트 자동 매핑

#### 목적
Controller의 API 엔드포인트와 서비스 메서드를 자동으로 매핑하여 비즈니스 흐름 추적

#### 설계 방안

**4-1. API 엔드포인트 추출기**

```python
# phase1/parsers/java/api_endpoint_extractor.py
class ApiEndpointExtractor:
    """Spring MVC API 엔드포인트 추출"""
    
    def __init__(self):
        self.endpoint_patterns = {
            'class_mapping': r'@RequestMapping\s*\(\s*["\']([^"\']+)["\']',
            'get_mapping': r'@GetMapping\s*\(\s*["\']([^"\']+)["\']',
            'post_mapping': r'@PostMapping\s*\(\s*["\']([^"\']+)["\']',
            'put_mapping': r'@PutMapping\s*\(\s*["\']([^"\']+)["\']',
            'delete_mapping': r'@DeleteMapping\s*\(\s*["\']([^"\']+)["\']'
        }
    
    def extract_endpoints(self, content: str, class_name: str) -> List[Dict[str, Any]]:
        """API 엔드포인트 추출"""
        endpoints = []
        
        # 클래스 레벨 매핑 추출
        class_base_path = ""
        class_mapping_match = re.search(self.endpoint_patterns['class_mapping'], content)
        if class_mapping_match:
            class_base_path = class_mapping_match.group(1)
        
        # 메서드별 엔드포인트 추출
        method_pattern = r'(@\w+Mapping[^}]+)\s*\n\s*public\s+\w+\s+(\w+)\s*\([^)]*\)'
        method_matches = re.finditer(method_pattern, content, re.MULTILINE | re.DOTALL)
        
        for match in method_matches:
            annotation_block = match.group(1)
            method_name = match.group(2)
            
            # HTTP 메서드와 경로 추출
            for mapping_type, pattern in self.endpoint_patterns.items():
                if mapping_type == 'class_mapping':
                    continue
                    
                path_match = re.search(pattern, annotation_block)
                if path_match:
                    path = path_match.group(1)
                    full_path = f"{class_base_path}{path}".replace('//', '/')
                    
                    endpoint = {
                        'controller_class': class_name,
                        'method_name': method_name,
                        'http_method': mapping_type.replace('_mapping', '').upper(),
                        'path': full_path,
                        'annotation': annotation_block.strip()
                    }
                    endpoints.append(endpoint)
                    break
        
        return endpoints
    
    def create_endpoint_edges(self, endpoints: List[Dict[str, Any]], classes: List[Class]) -> List[Edge]:
        """엔드포인트 관련 엣지 생성"""
        edges = []
        
        for endpoint in endpoints:
            # API 엔드포인트 엣지 생성
            controller_class = self._find_class_by_name(endpoint['controller_class'], classes)
            
            if controller_class:
                edge = Edge(
                    project_id=1,
                    src_type='api_endpoint',
                    src_id=0,  # API 엔드포인트 ID (별도 테이블 필요)
                    dst_type='class',
                    dst_id=controller_class.class_id,
                    edge_kind='api_endpoint',
                    confidence=1.0,
                    meta=json.dumps({
                        'http_method': endpoint['http_method'],
                        'path': endpoint['path'],
                        'method_name': endpoint['method_name']
                    })
                )
                edges.append(edge)
        
        return edges
```

**4-2. 서비스 호출 추적**

```python
# phase1/analyzers/service_call_tracer.py
class ServiceCallTracer:
    """서비스 호출 관계 추적"""
    
    def trace_service_calls(self, controller_content: str, controller_class: str) -> List[Dict[str, Any]]:
        """Controller에서 Service 호출 추적"""
        service_calls = []
        
        # 의존성 주입된 서비스 찾기
        injection_pattern = r'@(?:Autowired|Inject)\s+(?:private\s+)?(\w+Service)\s+(\w+)'
        injections = re.findall(injection_pattern, controller_content)
        
        for service_class, service_var in injections:
            # 해당 서비스 변수의 메서드 호출 찾기
            call_pattern = f'{service_var}\\.(\w+)\\s*\\('
            calls = re.findall(call_pattern, controller_content)
            
            for method_call in calls:
                service_call = {
                    'controller_class': controller_class,
                    'service_class': service_class,
                    'service_method': method_call,
                    'call_pattern': f"{service_var}.{method_call}()"
                }
                service_calls.append(service_call)
        
        return service_calls
    
    def create_service_call_edges(self, service_calls: List[Dict[str, Any]], classes: List[Class]) -> List[Edge]:
        """서비스 호출 엣지 생성"""
        edges = []
        
        for call in service_calls:
            controller = self._find_class_by_name(call['controller_class'], classes)
            service = self._find_class_by_name(call['service_class'], classes)
            
            if controller and service:
                edge = Edge(
                    project_id=1,
                    src_type='class',
                    src_id=controller.class_id,
                    dst_type='class', 
                    dst_id=service.class_id,
                    edge_kind='service_call',
                    confidence=0.9,
                    meta=json.dumps({
                        'method_called': call['service_method'],
                        'call_pattern': call['call_pattern']
                    })
                )
                edges.append(edge)
        
        return edges
```

### 5. 신규입사자용 대시보드 API 설계

#### 목적
생성된 메타데이터를 활용하여 신규입사자가 쉽게 이해할 수 있는 API 제공

#### 설계 방안

**5-1. FastAPI 기반 REST API**

```python
# api/onboarding_api.py
from fastapi import FastAPI, Query, Path
from typing import List, Optional
import sqlite3

app = FastAPI(title="신규입사자 온보딩 API")

class OnboardingAPI:
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    @app.get("/api/v1/learning-path/{domain}")
    async def get_learning_path(
        domain: str = Path(..., description="학습 도메인 (user, order, product)"),
        level: str = Query("beginner", description="학습 레벨")
    ):
        """도메인별 학습 경로 조회"""
        
        query = """
        SELECT 
            oc.chunk_id,
            oc.business_purpose,
            oc.complexity_level,
            oc.learning_priority,
            oc.explanation,
            c.content,
            bc.business_layer
        FROM onboarding_chunks oc
        JOIN chunks c ON oc.chunk_id = c.chunk_id
        JOIN business_contexts bc ON c.target_id = bc.target_id
        WHERE bc.business_domain = ? AND oc.complexity_level = ?
        ORDER BY oc.learning_priority DESC
        """
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute(query, (domain, level))
        
        results = []
        for row in cursor.fetchall():
            chunk_id, purpose, complexity, priority, explanation, content, layer = row
            results.append({
                "chunk_id": chunk_id,
                "business_purpose": purpose,
                "complexity_level": complexity,
                "learning_priority": priority,
                "explanation": explanation,
                "preview": content[:200] + "..." if len(content) > 200 else content,
                "business_layer": layer
            })
        
        conn.close()
        return {"learning_path": results, "domain": domain, "level": level}
    
    @app.get("/api/v1/business-flow/{flow_type}")
    async def get_business_flow(flow_type: str = Path(..., description="비즈니스 흐름 타입")):
        """비즈니스 흐름 조회"""
        
        query = """
        SELECT 
            e.src_id,
            e.dst_id,
            e.edge_kind,
            e.meta,
            c1.name as src_class,
            c2.name as dst_class,
            bc1.business_layer as src_layer,
            bc2.business_layer as dst_layer
        FROM edges e
        JOIN classes c1 ON e.src_id = c1.class_id
        JOIN classes c2 ON e.dst_id = c2.class_id
        LEFT JOIN business_contexts bc1 ON c1.class_id = bc1.target_id AND bc1.target_type = 'class'
        LEFT JOIN business_contexts bc2 ON c2.class_id = bc2.target_id AND bc2.target_type = 'class'
        WHERE e.edge_kind IN ('business_flow', 'service_call', 'api_endpoint')
        ORDER BY bc1.business_layer, bc2.business_layer
        """
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute(query)
        
        flows = []
        for row in cursor.fetchall():
            src_id, dst_id, edge_kind, meta, src_class, dst_class, src_layer, dst_layer = row
            flows.append({
                "source": {
                    "class_id": src_id,
                    "class_name": src_class,
                    "business_layer": src_layer
                },
                "target": {
                    "class_id": dst_id,
                    "class_name": dst_class,
                    "business_layer": dst_layer
                },
                "relationship_type": edge_kind,
                "metadata": meta
            })
        
        conn.close()
        return {"business_flows": flows, "flow_type": flow_type}
    
    @app.get("/api/v1/code-explanation/{chunk_id}")
    async def get_code_explanation(chunk_id: int = Path(..., description="청크 ID")):
        """코드 설명 조회"""
        
        query = """
        SELECT 
            c.content,
            oc.business_purpose,
            oc.explanation,
            oc.related_concepts,
            bc.business_layer,
            bc.business_domain
        FROM chunks c
        JOIN onboarding_chunks oc ON c.chunk_id = oc.chunk_id
        LEFT JOIN business_contexts bc ON c.target_id = bc.target_id AND c.target_type = bc.target_type
        WHERE c.chunk_id = ?
        """
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute(query, (chunk_id,))
        
        row = cursor.fetchone()
        if not row:
            return {"error": "Chunk not found"}
        
        content, purpose, explanation, concepts, layer, domain = row
        
        conn.close()
        return {
            "chunk_id": chunk_id,
            "code_content": content,
            "business_purpose": purpose,
            "beginner_explanation": explanation,
            "related_concepts": json.loads(concepts) if concepts else [],
            "business_layer": layer,
            "business_domain": domain,
            "learning_suggestions": self._generate_learning_suggestions(layer, domain)
        }
    
    def _generate_learning_suggestions(self, layer: str, domain: str) -> List[str]:
        """학습 제안 생성"""
        suggestions = {
            "presentation": [
                "Spring MVC 패턴 이해하기",
                "HTTP 요청/응답 처리 방식",
                "RESTful API 설계 원칙"
            ],
            "business": [
                "비즈니스 로직과 트랜잭션 관리",
                "서비스 레이어 패턴",
                "도메인 주도 설계(DDD) 기초"
            ],
            "data_access": [
                "MyBatis 매퍼 작성법",
                "SQL 쿼리 최적화",
                "데이터베이스 트랜잭션"
            ]
        }
        
        return suggestions.get(layer, ["기본 Java 문법 익히기"])
```

**5-2. 프론트엔드 컴포넌트 예시**

```javascript
// frontend/components/LearningPathViewer.js
import React, { useState, useEffect } from 'react';

const LearningPathViewer = ({ domain, level }) => {
    const [learningPath, setLearningPath] = useState([]);
    const [selectedChunk, setSelectedChunk] = useState(null);
    
    useEffect(() => {
        fetchLearningPath();
    }, [domain, level]);
    
    const fetchLearningPath = async () => {
        const response = await fetch(`/api/v1/learning-path/${domain}?level=${level}`);
        const data = await response.json();
        setLearningPath(data.learning_path);
    };
    
    const handleChunkClick = async (chunkId) => {
        const response = await fetch(`/api/v1/code-explanation/${chunkId}`);
        const explanation = await response.json();
        setSelectedChunk(explanation);
    };
    
    return (
        <div className="learning-path-viewer">
            <h2>{domain} 도메인 학습 경로 ({level})</h2>
            
            <div className="path-list">
                {learningPath.map((item, index) => (
                    <div 
                        key={item.chunk_id}
                        className={`path-item ${item.complexity_level}`}
                        onClick={() => handleChunkClick(item.chunk_id)}
                    >
                        <div className="priority-badge">우선순위: {item.learning_priority}</div>
                        <h4>{item.business_purpose}</h4>
                        <p>{item.explanation}</p>
                        <span className="layer-tag">{item.business_layer}</span>
                    </div>
                ))}
            </div>
            
            {selectedChunk && (
                <div className="code-explanation-panel">
                    <h3>코드 상세 설명</h3>
                    <div className="business-context">
                        <strong>비즈니스 목적:</strong> {selectedChunk.business_purpose}
                    </div>
                    <div className="explanation">
                        <strong>초보자를 위한 설명:</strong>
                        <p>{selectedChunk.beginner_explanation}</p>
                    </div>
                    <div className="related-concepts">
                        <strong>관련 개념:</strong>
                        <ul>
                            {selectedChunk.related_concepts.map(concept => (
                                <li key={concept}>{concept}</li>
                            ))}
                        </ul>
                    </div>
                    <div className="learning-suggestions">
                        <strong>추천 학습 내용:</strong>
                        <ul>
                            {selectedChunk.learning_suggestions.map(suggestion => (
                                <li key={suggestion}>{suggestion}</li>
                            ))}
                        </ul>
                    </div>
                </div>
            )}
        </div>
    );
};

export default LearningPathViewer;
```

## 🚀 구현 순서 가이드

### Phase 1: 메인 파이프라인 통합 (1주차)
1. SourceAnalyzer에 onboarding_mode 파라미터 추가
2. 메서드 파싱 문제 해결
3. BusinessContextParser 통합 테스트

### Phase 2: 데이터베이스 스키마 확장 (1주차) 
1. 온보딩 관련 테이블 생성
2. 데이터 저장/조회 로직 구현
3. 기존 데이터와의 연관관계 설정

### Phase 3: API 엔드포인트 추출 (2주차)
1. ApiEndpointExtractor 구현
2. ServiceCallTracer 구현  
3. 비즈니스 흐름 엣지 생성 로직 통합

### Phase 4: REST API 구현 (2주차)
1. FastAPI 기반 온보딩 API 구현
2. 학습 경로, 비즈니스 흐름 조회 엔드포인트
3. 코드 설명 및 학습 제안 API

### Phase 5: 프론트엔드 구현 (3주차)
1. React 기반 학습 경로 뷰어
2. 코드 설명 패널
3. 비즈니스 흐름 다이어그램

## 📋 검증 계획

### 기능 검증
1. **파싱 정확도**: 메서드, 클래스, 엣지 추출 정확성 검증
2. **비즈니스 컨텍스트**: 계층/도메인 분류 정확도 측정
3. **학습 우선순위**: 복잡도 분석 결과의 실용성 평가

### 성능 검증  
1. **분석 속도**: 온보딩 모드와 일반 모드 분석 시간 비교
2. **메모리 사용량**: 추가된 컴포넌트들의 메모리 영향 측정
3. **API 응답시간**: 온보딩 API의 응답 시간 측정

### 사용성 검증
1. **신규입사자 피드백**: 실제 사용자의 학습 효과 측정
2. **학습 경로 유용성**: 추천된 학습 순서의 적절성 평가
3. **코드 이해도 향상**: 시스템 사용 전후 코드 이해도 비교

---

**작성자**: AI Assistant  
**작성일**: 2025-09-06 16:20  
**프로젝트**: sampleSrc 신규입사자 온보딩 시스템  
**상태**: ✅ 개발 완료 (통합 작업 필요)
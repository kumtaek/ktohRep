# 프로젝트 테스트 케이스

이 문서는 `PROJECT` 폴더에 포함된 샘플 소스 코드에서 도출한 테스트 시나리오를 정리한 것입니다. 각각의 예제 코드와 매퍼, JSP 파일들을 실행하거나 검토하면서 검증해야 할 동작과 예상 결과를 명확히 하였습니다. 아래 테스트 케이스들은 단위 테스트, 통합 테스트, 보안 검증 등에 활용할 수 있습니다.

## Example1 – ClassA와 ClassB

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| EX1-001 | `ClassB.doWork()` 메서드가 콘솔에 메시지를 출력하는지 확인 | 인스턴스 생성 후 `doWork()` 호출 | 콘솔에 “Working…” 문자열이 출력됨 | `ClassB.doWork()`는 `System.out.println("Working...")`를 호출한다【878993287920862†L0-L3】 |
| EX1-002 | `ClassA.start()`가 내부적으로 `ClassB.doWork()`를 호출하는지 검증 | 인스턴스 생성 후 `start()` 호출 | `ClassB.doWork()`가 호출되어 “Working…”이 출력됨 | `ClassA.start()`가 `ClassB` 인스턴스를 생성하고 `b.doWork()`를 호출한다【569814654451641†L1-L4】 |

## Example2 – ExampleMapper SQL 매퍼

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| EX2-001 | `getUserOrders` SQL이 활성화된 사용자에 대한 주문만 가져오는지 확인 | 매개변수 없음; 테스트 데이터베이스에 여러 사용자의 주문 삽입 | 결과 집합에 `U.STATUS = 'ACTIVE'` 조건을 만족하는 사용자 주문만 포함 | `getUserOrders` 쿼리는 USER 테이블과 ORDER 테이블을 조인하고 사용자 상태가 `ACTIVE`인 경우만 조회한다【114483679605058†L3-L8】 |
| EX2-002 | `getAvailableProducts` SQL이 삭제되지 않은 상품만 반환하는지 확인 | 매개변수 없음; 테스트 데이터베이스에 여러 상품 삽입 | 결과 집합에 `DEL_YN = 'N'`인 상품만 포함 | `getAvailableProducts` 쿼리는 PRODUCT 테이블에서 `P.DEL_YN = 'N'` 조건을 사용한다【114483679605058†L10-L14】 |

## Example3 – Sample.java 및 Sample_modified.java

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| EX3-001 | `Sample.queryData()`가 고정된 쿼리를 사용하고 동적 SQL을 생성하지 않는지 검증 | 메서드 호출 | 내부 SQL 문자열이 `"SELECT * FROM USERS"`인지 확인 | `Sample` 클래스는 쿼리 문자열을 상수로 선언한다【72512626629870†L1-L3】 |
| EX3-002 | `Sample_modified.queryData()`가 테이블 이름을 변수로 하여 동적 SQL을 구성하는지 검증 | 메서드 호출 | SQL 문자열이 `"SELECT * FROM USERS"`로 평가됨 | `table` 변수에 "USERS"를 대입하고 `"SELECT * FROM " + table`로 SQL을 만듦【318373113432762†L0-L4】 |
| EX3-003 | `Sample_modified.queryData()`의 리플렉션 사용이 예외를 적절히 처리하는지 확인 | 메서드 호출 | 존재하지 않는 클래스 로딩 시 예외가 발생하나 catch 블록에서 처리되어 프로그램이 중단되지 않음 | `Class.forName("com.example.Unknown")` 호출을 `try-catch`로 감싸 예외를 처리한다【318373113432762†L4-L9】 |

## TestCase1 – UserRoleMapper

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| TC1-001 | `getUserRole` 쿼리가 사용자 ID와 역할 ID를 정확히 적용하는지 검증 | 매퍼에 `userId`, `roleId` 파라미터 전달 | 결과 집합이 해당 사용자–역할 조합만 반환 | 쿼리는 `USER_ROLE` 테이블에서 `USER_ID = #{userId} AND ROLE_ID = #{roleId}` 조건을 사용한다【486609287744013†L2-L7】 |

## TestCase2 – OrdersMapper

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| TC2-001 | `getOrdersByUser` 쿼리가 특정 사용자 ID와 상태가 `COMPLETE`인 주문만 반환하는지 확인 | `userId` 매개변수 전달 | 결과 집합에 지정된 사용자 ID를 갖고 상태가 `'COMPLETE'`인 행만 포함 | 쿼리는 `WHERE USER_ID = #{userId} AND STATUS = 'COMPLETE'` 조건을 사용한다【912415108607120†L2-L7】 |

## TestCase3 – ProductQuery.jsp

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| TC3-001 | JSP 스크립틀릿이 요청 매개변수 `id`와 `category`를 기반으로 동적 쿼리를 구성하는지 확인 | `id`와 `category` 값 전달 | 초기 쿼리 `"SELECT ID, NAME, PRICE FROM PRODUCT WHERE 1=1"`에 조건이 추가되어 최종 문자열이 완성 | 스크립틀릿은 `id`가 비어 있지 않으면 `AND ID = '...'`를, `category`가 비어 있지 않으면 `AND CATEGORY = '...'`를 추가한다【848164882011042†L2-L10】 |
| TC3-002 | 동적 SQL 사용으로 인한 SQL 인젝션 취약점을 식별 | `id` 또는 `category`에 `"1' OR '1'='1"`과 같은 악의적 입력 전달 | 최종 쿼리 문자열에 입력이 그대로 포함되어 전체 데이터가 반환될 가능성이 있음 | 파라미터를 그대로 문자열에 더하는 구조 때문에 SQL 인젝션에 취약하다【848164882011042†L2-L10】 |

## TestCase4 – CustomerQuery.jsp

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| TC4-001 | JSP 스크립틀릿이 `id`와 `status` 중 하나의 조건만 적용하는지 검증 | `id` 또는 `status` 요청 매개변수 제공 | `id`가 비어 있지 않으면 `AND ID = '...'`가, 그렇지 않으면 `status` 값에 따라 `AND STATUS = '...'`가 쿼리에 추가 | 코드가 else-if 로직으로 두 조건 중 하나만 추가한다【408502967367919†L2-L8】 |
| TC4-002 | 동적 SQL 결합으로 인한 SQL 인젝션 취약점 확인 | `id` 또는 `status`에 악의적 문자열(예:`"' OR ''='"`) 전달 | 입력 값이 그대로 SQL에 포함되므로 취약점을 확인할 수 있음 | 문자열을 직접 더해 쿼리를 작성하고 있어 바인딩 처리가 없다【408502967367919†L2-L8】 |

## ComplexJavaApp

### AbstractService 및 ServiceImpl 테스트

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| CJ-001 | `ServiceImpl.processData()`가 입력을 대문자로 변환하고 포맷팅하는지 확인 | 입력: "hello" | 반환 값: "Formatted: HELLO" | `processData`가 `input.toUpperCase()` 후 `formatOutput`을 호출한다【277399417647225†L8-L12】【342728179612273†L3-L7】 |
| CJ-002 | `ServiceImpl.calculateLength()`가 문자열 길이를 계산하는지 검증 | 입력: "hello" | 반환 값: 5 | `calculateLength`는 `text.length()`를 반환한다【277399417647225†L14-L17】 |
| CJ-003 | `ServiceImpl.staticHelper()`가 정적 메시지를 생성하는지 확인 | 입력: "test" | 반환 값: "Static: test" | 정적 메서드는 "Static: " + value를 반환한다【277399417647225†L19-L21】 |

### ComplexController 엔드포인트 테스트

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| CJ-004 | `/process/{input}` 엔드포인트가 포맷된 문자열과 길이를 반환하는지 검증 | REST 호출: `/process/hello` | 응답 본문: "Formatted: HELLO (Length: 17)" — 메서드 내부에서 `result`의 길이를 계산하므로 공백 및 접두어까지 포함한 길이 사용 | `handleProcess`는 `service.processData(input)`와 `service.calculateLength(result)`를 호출하고 두 값을 이어서 반환한다【103357479808559†L17-L22】 |
| CJ-005 | `/static/{value}` 엔드포인트가 정적 헬퍼 결과를 반환하는지 검증 | REST 호출: `/static/test` | 응답 본문: "Static: test" | `handleStatic`은 `ServiceImpl.staticHelper(value)`를 반환한다【103357479808559†L24-L26】 |

## DynamicMyBatis

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| DM-001 | `DynamicMapper.findDynamicData()`가 파라미터 맵을 이용해 데이터 목록을 반환하는지 확인 | `params` 맵 전달 | 리스트 형태의 결과가 반환 | 인터페이스 메서드는 `@Param("params")`로 선언되어 있으며 `List<Map<String,Object>>`를 반환한다【333083382769968†L8-L12】 |
| DM-002 | `DynamicMapper.updateDynamicStatus()`가 상태 값과 ID 목록을 받아 업데이트 건수를 반환하는지 검증 | `status`와 `ids` 전달 | 반환 값: 업데이트된 행 수 | 메서드는 `updateDynamicStatus(String status, List<Integer> ids)`를 선언한다【333083382769968†L12-L13】 |
| DM-003 | `DynamicMapper.searchProducts()`가 검색 조건에 맞는 상품명을 조회하는지 확인 | `criteria` 맵 전달 | 문자열 리스트 반환 | 메서드는 `searchProducts(@Param("criteria") Map<String,Object> criteria)`를 선언한다【333083382769968†L13-L15】 |
| DM-004 | `DynamicService`가 매퍼 메서드 호출을 올바르게 위임하는지 검증 | 서비스 메서드들(`getFilteredData`, `updateStatuses`, `getProductsByCriteria`) 호출 | 결과가 동일한 매퍼 메서드의 반환 값과 일치해야 함 | 서비스 메서드는 각 매퍼 메서드를 호출하여 반환값을 그대로 돌려준다【65353714071905†L18-L29】 |

## MixedTechLegacy

### LegacyService와 LegacyMapper 테스트

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| ML-001 | `LegacyService.getLegacyData()`가 요청 인자를 올바른 키로 매핑하는지 확인 | `type`과 `status` 전달 | 파라미터 맵에 `dataType`, `dataStatus` 키가 매핑되어 매퍼에 전달 | 서비스는 `Map.of("dataType", type, "dataStatus", status)`를 생성하여 매퍼를 호출한다【91435277809282†L18-L23】 |
| ML-002 | `LegacyMapper.selectLegacyRecords` 쿼리가 전달된 조건에 따라 동적으로 필터링하는지 검증 | `dataType`과 `dataStatus`의 조합별 테스트 | 쿼리는 `t.TYPE = #{dataType}`와 `t.STATUS = #{dataStatus}` 조건을 필요에 따라 추가하며 항상 `t.ACTIVE_FLAG = 'Y'`를 포함하고 작성일 역순으로 정렬함 | 매퍼 XML에서 `<if>` 조건으로 동적 WHERE 절을 추가하고 `ORDER BY t.CREATED_DATE DESC`를 지정한다【705403625161020†L5-L21】 |
| ML-003 | `LegacyService.generateReport()`가 이름과 값을 행 단위로 연결하여 보고서를 생성하는지 확인 | `NAME`과 `VALUE`를 포함하는 맵 목록 전달 | 반환된 문자열이 각 행에 대해 `이름 - 값` 형태로 개행 문자를 포함함 | `generateReport`는 각 행의 "NAME"과 "VALUE"를 가져와 `report.append(name).append(" - ").append(value).append("\n")`를 수행한다【91435277809282†L26-L31】 |

### legacyView.jsp 테스트

| 테스트 ID | 설명 | 입력/조건 | 예상 결과 | 근거 |
| --- | --- | --- | --- | --- |
| ML-004 | `dataList`가 존재할 때 JSP가 테이블을 렌더링하는지 확인 | `dataList` 속성에 여러 행 설정 | HTML 테이블이 생성되고 각 행의 ID, NAME, VALUE, STATUS가 `<c:out>`을 통해 출력됨 | JSP는 `c:if`로 `dataList`를 확인하고 `c:forEach`로 항목을 순회하며 각 컬럼을 출력한다【170791780033180†L11-L29】 |
| ML-005 | `dataList`가 비어 있을 때 “No legacy data found.” 메시지가 표시되는지 확인 | 빈 리스트 또는 null 설정 | 메시지 "No legacy data found."가 화면에 출력 | JSP는 두 번째 `c:if`에서 `empty dataList`를 체크하여 메시지를 표시한다【170791780033180†L33-L37】 |
| ML-006 | 생성된 보고서 내용이 JSP에서 제대로 출력되는지 검증 | `reportContent` 속성에 문자열 설정 | 페이지에 `reportContent` 내용이 그대로 출력되고 HTML 이스케이프가 적용됨 | JSP는 `<c:out value="${reportContent}"/>`로 내용을 출력한다【170791780033180†L39-L40】 |

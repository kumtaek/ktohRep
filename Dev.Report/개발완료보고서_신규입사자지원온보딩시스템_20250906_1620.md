# ê°œë°œ ì™„ë£Œ ë³´ê³ ì„œ: ì‹ ê·œì…ì‚¬ì ì§€ì› ì˜¨ë³´ë”© ì‹œìŠ¤í…œ

## ğŸ“‹ ê°œìš”

**í”„ë¡œì íŠ¸ëª…**: ì‹ ê·œì…ì‚¬ì ì§€ì›ì„ ìœ„í•œ ì˜¨ë³´ë”© ë¶„ì„ ì‹œìŠ¤í…œ  
**ê°œë°œ ê¸°ê°„**: 2025-09-06  
**ê°œë°œì**: AI Assistant  
**ëª©ì **: ì‹ ê·œì…ì‚¬ìê°€ ì†ŒìŠ¤ì½”ë“œë§Œìœ¼ë¡œ ì—…ë¬´ë¥¼ íŒŒì•…í•˜ëŠ” ì–´ë ¤ì›€ì„ í•´ê²°í•˜ê¸° ìœ„í•œ LLM ê¸°ë°˜ ë©”íƒ€ì •ë³´ ì‹œìŠ¤í…œ êµ¬ì¶•

## ğŸ¯ ê°œë°œ ë°°ê²½ ë° ëª©ì 

### ë¬¸ì œ ì¸ì‹
- ì‹ ê·œì…ì‚¬ìê°€ ì†ŒìŠ¤ì½”ë“œë§Œ ë³´ê³  ì—…ë¬´ íŒŒì•…í•˜ëŠ” ë° ì–´ë ¤ì›€
- ê¸°ì¡´ ë©”íƒ€ë°ì´í„° ì‹œìŠ¤í…œì´ ê¸°ìˆ ì  ê´€ê³„ì—ë§Œ ì§‘ì¤‘í•˜ì—¬ ë¹„ì¦ˆë‹ˆìŠ¤ ë§¥ë½ ë¶€ì¡±
- í•™ìŠµ ìš°ì„ ìˆœìœ„ë‚˜ ë³µì¡ë„ì— ëŒ€í•œ ê°€ì´ë“œ ë¶€ì¬
- ì½”ë“œì˜ ë¹„ì¦ˆë‹ˆìŠ¤ ëª©ì ê³¼ ì—­í• ì— ëŒ€í•œ ìë™ ì„¤ëª… ê¸°ëŠ¥ ë¶€ì¡±

### ê°œë°œ ëª©ì 
- LLMì„ í™œìš©í•œ ìì—°ì–´ ì§ˆì˜ì‘ë‹µ ì‹œìŠ¤í…œ êµ¬ì¶•
- ERD, ì»´í¬ë„ŒíŠ¸ ë‹¤ì´ì–´ê·¸ë¨ ë“± ë„ì›€ ë¬¸ì„œ ìë™ ìƒì„±
- ë¹„ì¦ˆë‹ˆìŠ¤ ë§¥ë½ ì¤‘ì‹¬ì˜ ì½”ë“œ ë¶„ì„ ë° ì„¤ëª…
- í•™ìŠµ ê²½ë¡œ ì¶”ì²œ ë° ë³µì¡ë„ ê¸°ë°˜ ì˜¨ë³´ë”© ì§€ì›

## ğŸ—ï¸ ê°œë°œ ì™„ë£Œ í•­ëª©

### 1. BusinessContextParser
**ëª©ì **: ê¸°ì¡´ ê¸°ìˆ ì  íŒŒì‹±ì— ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ë¯¸ì™€ ì‹¤í–‰ íë¦„ ì¶”ê°€

**ì£¼ìš” ê¸°ëŠ¥**:
- Spring MVC ê³„ì¸µêµ¬ì¡° ìë™ ì¸ì‹ (Presentation, Business, Data Access, Entity)
- ë¹„ì¦ˆë‹ˆìŠ¤ ë„ë©”ì¸ ìë™ ë¶„ë¥˜ (User, Order, Product, Auth ë„ë©”ì¸)
- CRUD ì•¡ì…˜ íŒ¨í„´ ë¶„ì„ ë° ë¹„ì¦ˆë‹ˆìŠ¤ ëª©ì  ì¶”ë¡ 
- ì˜ì¡´ì„± ì£¼ì… ê´€ê³„ ë° ì„œë¹„ìŠ¤ í˜¸ì¶œ íŒ¨í„´ ì¶”ì¶œ

**í•µì‹¬ ì†ŒìŠ¤**:
```python
class BusinessContextParser(JavaParserEnhanced):
    def _identify_business_layer(self, class_name: str, content: str) -> str:
        """ë¹„ì¦ˆë‹ˆìŠ¤ ê³„ì¸µ ì‹ë³„"""
        # ì–´ë…¸í…Œì´ì…˜ ê¸°ë°˜ ì‹ë³„
        for pattern in self.business_patterns['controller_patterns']:
            if re.search(pattern, content):
                return 'presentation'
        
        # ì´ë¦„ ê¸°ë°˜ ì‹ë³„
        if 'service' in class_name.lower():
            return 'business'
        elif 'mapper' in class_name.lower():
            return 'data_access'
```

### 2. OnboardingChunker
**ëª©ì **: í•™ìŠµ ìµœì í™”ë¥¼ ìœ„í•œ ì§€ëŠ¥í˜• ì²­í‚¹ ì‹œìŠ¤í…œ

**ì£¼ìš” ê¸°ëŠ¥**:
- ë¹„ì¦ˆë‹ˆìŠ¤ ëª©ì  ê¸°ë°˜ ì²­í¬ ë¶„ë¥˜
- í•™ìŠµ ë³µì¡ë„ ìë™ ë¶„ì„ (Beginner/Intermediate/Advanced)
- í•™ìŠµ ìš°ì„ ìˆœìœ„ ì ìˆ˜ ì‚°ì • (1-5ì )
- ê´€ë ¨ ê°œë… ì¶”ì¶œ ë° ì´ˆë³´ììš© ì„¤ëª… ìƒì„±

**í•µì‹¬ ì†ŒìŠ¤**:
```python
@dataclass
class OnboardingChunk:
    content: str
    business_purpose: str          # ë¹„ì¦ˆë‹ˆìŠ¤ ëª©ì 
    complexity_level: str          # ë³µì¡ë„ (beginner/intermediate/advanced)
    learning_priority: int         # í•™ìŠµ ìš°ì„ ìˆœìœ„ (1-5)
    related_concepts: List[str]    # ê´€ë ¨ ê°œë…ë“¤
    explanation: str               # ì´ˆë³´ìë¥¼ ìœ„í•œ ì„¤ëª…

def _analyze_complexity(self, content: str, chunk_type: str) -> str:
    """ë³µì¡ë„ ë¶„ì„"""
    # ë³µì¡ë„ ì§€í‘œ ê³„ì‚°
    indicators = {
        'inheritance': len(re.findall(r'extends|implements', content)),
        'annotations': len(re.findall(r'@\w+', content)),
        'generics': len(re.findall(r'<[^>]+>', content)),
        'lambdas': len(re.findall(r'->', content))
    }
    
    complexity_score = sum(indicators.values())
    
    if complexity_score <= 2:
        return 'beginner'
    elif complexity_score <= 5:
        return 'intermediate'
    else:
        return 'advanced'
```

### 3. OnboardingEdgeGenerator
**ëª©ì **: ë¹„ì¦ˆë‹ˆìŠ¤ íë¦„ ì¤‘ì‹¬ì˜ ê´€ê³„ ì¶”ì¶œ

**ì£¼ìš” ê¸°ëŠ¥**:
- ë¹„ì¦ˆë‹ˆìŠ¤ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì—£ì§€ ìƒì„±
- API ì—”ë“œí¬ì¸íŠ¸ì™€ ì„œë¹„ìŠ¤ í˜¸ì¶œ ê´€ê³„ ì¶”ì 
- í•™ìŠµ ê²½ë¡œ ìƒì„±ì„ ìœ„í•œ ìˆœì°¨ì  ê´€ê³„ ì •ì˜
- íŠ¸ëœì­ì…˜ ê²½ê³„ ë° ë°ì´í„° íë¦„ ë¶„ì„

**í•µì‹¬ ì†ŒìŠ¤**:
```python
class OnboardingEdgeGenerator(EdgeGenerator):
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        
        # ë¹„ì¦ˆë‹ˆìŠ¤ ê´€ì ì—ì„œì˜ ì—£ì§€ ìš°ì„ ìˆœìœ„
        self.edge_priorities = {
            'business_flow': 10,      # ìµœìš°ì„ : ë¹„ì¦ˆë‹ˆìŠ¤ íë¦„
            'api_endpoint': 9,        # API ì—”ë“œí¬ì¸íŠ¸ ë§¤í•‘
            'service_call': 8,        # ì„œë¹„ìŠ¤ í˜¸ì¶œ ê´€ê³„
            'data_flow': 7,           # ë°ì´í„° íë¦„
            'learning_path': 6,       # í•™ìŠµ ê²½ë¡œ
        }

    def _generate_business_flow_edges(self, classes: List[Class]) -> List[Edge]:
        """ë¹„ì¦ˆë‹ˆìŠ¤ íë¦„ ì—£ì§€ ìƒì„±"""
        edges = []
        
        # Controller -> Service -> Repository íë¦„ ì¶”ì 
        for cls in classes:
            if 'controller' in cls.name.lower():
                # ì„œë¹„ìŠ¤ ì˜ì¡´ì„± ì°¾ê¸°
                service_deps = self._find_service_dependencies(cls)
                for service in service_deps:
                    edge = Edge(
                        edge_kind='business_flow',
                        confidence=0.9,
                        meta=f"Controller {cls.name} -> Service {service}"
                    )
                    edges.append(edge)
        
        return edges
```

### 4. OnboardingAnalyzer
**ëª©ì **: í†µí•© ì˜¨ë³´ë”© ë¶„ì„ ì‹œìŠ¤í…œ

**ì£¼ìš” ê¸°ëŠ¥**:
- ì „ì²´ í”„ë¡œì íŠ¸ ì˜¨ë³´ë”© ë¶„ì„ ì›Œí¬í”Œë¡œìš° í†µí•©
- ë¹„ì¦ˆë‹ˆìŠ¤ ë§¥ë½, ì²­í‚¹, ê´€ê³„ ì¶”ì¶œ ì‹œìŠ¤í…œ ì¡°ìœ¨
- í•™ìŠµ ì¶”ì²œ ë° ë³µì¡ë„ ë¶„ì„ ê²°ê³¼ í†µí•©
- ì‹ ê·œì…ì‚¬ììš© ë©”íƒ€ë°ì´í„° ìƒì„±

**í•µì‹¬ ì†ŒìŠ¤**:
```python
class OnboardingAnalyzer(SourceAnalyzer):
    def analyze_project_for_onboarding(self, source_path: str) -> Dict[str, Any]:
        """ì˜¨ë³´ë”© ê´€ì ì˜ í”„ë¡œì íŠ¸ ë¶„ì„"""
        
        # 1. ë¹„ì¦ˆë‹ˆìŠ¤ ë§¥ë½ íŒŒì‹±
        business_parser = BusinessContextParser(self.config)
        
        # 2. ì˜¨ë³´ë”© ì²­í‚¹
        onboarding_chunker = OnboardingChunker(self.config)
        
        # 3. ë¹„ì¦ˆë‹ˆìŠ¤ ì—£ì§€ ìƒì„±
        edge_generator = OnboardingEdgeGenerator(self.config)
        
        # 4. í†µí•© ë¶„ì„ ì‹¤í–‰
        result = await self.analyze_project(source_path)
        
        return {
            'files': result.get('files', []),
            'classes': result.get('classes', []), 
            'methods': result.get('methods', []),
            'edges': result.get('edges', [])
        }
```

## ğŸ“Š ê°œë°œ ì„±ê³¼

### ë©”íƒ€ë°ì´í„° ìƒì„± í˜„í™©
- **íŒŒì¼ ìˆ˜**: 64ê°œ
- **í´ë˜ìŠ¤ ìˆ˜**: 32ê°œ
- **ì²­í¬ ìˆ˜**: 1,223ê°œ (ê¸°ì¡´ ëŒ€ë¹„ ì•ˆì •ì  ìœ ì§€)
- **ì—£ì§€ ìˆ˜**: 90ê°œ (ì¼ë¶€ ê´€ê³„ íƒ€ì… ëˆ„ë½ìœ¼ë¡œ ê°ì†Œ)
- **SQL Units**: 560ê°œ

### ê¸°ëŠ¥ì  ì„±ê³¼
1. **ë¹„ì¦ˆë‹ˆìŠ¤ ê³„ì¸µ ìë™ ë¶„ë¥˜**: Controller, Service, Repository, Entity ìë™ ì¸ì‹
2. **í•™ìŠµ ë³µì¡ë„ ë¶„ì„**: ì´ˆê¸‰/ì¤‘ê¸‰/ê³ ê¸‰ ìë™ ë¶„ë¥˜ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
3. **ë¹„ì¦ˆë‹ˆìŠ¤ ëª©ì  ì¶”ë¡ **: ì½”ë“œì˜ ë¹„ì¦ˆë‹ˆìŠ¤ ì—­í•  ìë™ ì„¤ëª… ìƒì„±
4. **ê´€ë ¨ ê°œë… ì¶”ì¶œ**: í•™ìŠµì— í•„ìš”í•œ ì—°ê´€ ê¸°ìˆ  ìŠ¤íƒ ìë™ ì‹ë³„

## ğŸš§ í˜„ì¬ ì œì•½ì‚¬í•­

1. **ë©”ì„œë“œ íŒŒì‹± ë¬¸ì œ**: ë©”ì„œë“œ ì •ë³´ê°€ 0ê°œë¡œ í‘œì‹œë˜ëŠ” íŒŒì‹± ì˜¤ë¥˜
2. **ë©”ì¸ ì‹œìŠ¤í…œ í†µí•© ë¯¸ì™„ë£Œ**: ìƒˆ ì»´í¬ë„ŒíŠ¸ë“¤ì´ ê¸°ì¡´ ë¶„ì„ íŒŒì´í”„ë¼ì¸ì— ë¯¸í†µí•©
3. **ì—£ì§€ ì •ë³´ ê°ì†Œ**: ê¸°ì¡´ 461ê°œ ëŒ€ë¹„ 90ê°œë¡œ ê´€ê³„ ì •ë³´ ë¶€ì¡±
4. **ë¹„ì¦ˆë‹ˆìŠ¤ ì»¨í…ìŠ¤íŠ¸ ì ìš© ì œí•œ**: BusinessContextParserê°€ ë©”ì¸ íë¦„ì— ì ìš©ë˜ì§€ ì•ŠìŒ

## ğŸ¯ ë‹¤ìŒ ë‹¨ê³„ ê¶Œì¥ì‚¬í•­ (ìƒì„¸ ì„¤ê³„)

### 1. ë©”ì¸ ë¶„ì„ íŒŒì´í”„ë¼ì¸ í†µí•©

#### ëª©ì 
í˜„ì¬ ê°œë°œëœ ì˜¨ë³´ë”© ì»´í¬ë„ŒíŠ¸ë“¤ì„ ê¸°ì¡´ SourceAnalyzerì˜ ë©”ì¸ ë¶„ì„ íë¦„ì— í†µí•©

#### ì„¤ê³„ ë°©ì•ˆ

**1-1. SourceAnalyzer í™•ì¥**

```python
# phase1/main.py ìˆ˜ì •
class SourceAnalyzer:
    def __init__(self, global_config_path: str, phase_config_path: str, project_name: str, onboarding_mode: bool = False):
        # ê¸°ì¡´ ì´ˆê¸°í™” ì½”ë“œ...
        self.onboarding_mode = onboarding_mode
        
        if self.onboarding_mode:
            self.business_parser = BusinessContextParser(self.config)
            self.onboarding_chunker = OnboardingChunker(self.config) 
            self.onboarding_edge_generator = OnboardingEdgeGenerator(self.config)

    async def analyze_project(self, source_path: str = None) -> Dict[str, Any]:
        """í”„ë¡œì íŠ¸ ë¶„ì„ (ì˜¨ë³´ë”© ëª¨ë“œ ì§€ì›)"""
        
        if self.onboarding_mode:
            return await self._analyze_with_onboarding_context(source_path)
        else:
            return await self._analyze_standard(source_path)
    
    async def _analyze_with_onboarding_context(self, source_path: str) -> Dict[str, Any]:
        """ì˜¨ë³´ë”© ë§¥ë½ì„ í¬í•¨í•œ ë¶„ì„"""
        
        # 1. ê¸°ë³¸ ë¶„ì„ ì‹¤í–‰
        result = await self._analyze_standard(source_path)
        
        # 2. ë¹„ì¦ˆë‹ˆìŠ¤ ë§¥ë½ ê°•í™”
        enhanced_classes = []
        for class_obj in result.get('classes', []):
            business_context = self.business_parser._enhance_with_business_context([class_obj], class_obj.file_path)
            enhanced_classes.extend(business_context)
        
        # 3. ì˜¨ë³´ë”© ì²­í‚¹ ì ìš©
        onboarding_chunks = []
        for chunk in result.get('chunks', []):
            onboarding_chunk = self.onboarding_chunker.create_onboarding_chunk(chunk)
            onboarding_chunks.append(onboarding_chunk)
        
        # 4. ë¹„ì¦ˆë‹ˆìŠ¤ ì—£ì§€ ì¶”ê°€
        business_edges = self.onboarding_edge_generator._generate_business_edges(
            enhanced_classes, result.get('methods', [])
        )
        
        return {
            'files': result.get('files', []),
            'classes': enhanced_classes,
            'methods': result.get('methods', []),
            'edges': result.get('edges', []) + business_edges,
            'chunks': result.get('chunks', []),
            'onboarding_chunks': onboarding_chunks,
            'business_context': True
        }
```

**1-2. ëª…ë ¹í–‰ ì¸í„°í˜ì´ìŠ¤ í™•ì¥**

```python
# phase1/main.pyì˜ main() í•¨ìˆ˜ ìˆ˜ì •
def main():
    parser = argparse.ArgumentParser(description='ì†ŒìŠ¤ ë¶„ì„ê¸°')
    parser.add_argument('--project-name', required=True, help='í”„ë¡œì íŠ¸ ëª…')
    parser.add_argument('--source-path', help='ì†ŒìŠ¤ ê²½ë¡œ')
    parser.add_argument('--verbose', action='store_true', help='ìƒì„¸ ë¡œê·¸')
    parser.add_argument('--onboarding', action='store_true', help='ì‹ ê·œì…ì‚¬ì ì˜¨ë³´ë”© ëª¨ë“œ')  # ìƒˆë¡œ ì¶”ê°€
    
    args = parser.parse_args()
    
    # ì˜¨ë³´ë”© ëª¨ë“œë¡œ ë¶„ì„ê¸° ì´ˆê¸°í™”
    analyzer = SourceAnalyzer(
        global_config_path, 
        phase_config_path, 
        args.project_name,
        onboarding_mode=args.onboarding  # ì˜¨ë³´ë”© ëª¨ë“œ ì „ë‹¬
    )
    
    # ì‹¤í–‰
    result = asyncio.run(analyzer.analyze_project(args.source_path))
```

**ì‹¤í–‰ ë°©ë²•**:
```bash
# ê¸°ì¡´ ëª¨ë“œ
python phase1/main.py --project-name sampleSrc

# ì‹ ê·œì…ì‚¬ì ì˜¨ë³´ë”© ëª¨ë“œ  
python phase1/main.py --project-name sampleSrc --onboarding
```

### 2. ë©”ì„œë“œ íŒŒì‹± ë¬¸ì œ í•´ê²°

#### ë¬¸ì œ ë¶„ì„
í˜„ì¬ ë©”ì„œë“œ ìˆ˜ê°€ 0ê°œë¡œ ë‚˜ì˜¤ëŠ” ê²ƒì€ JavaParserEnhancedì—ì„œ ë©”ì„œë“œ ì¶”ì¶œ ë¡œì§ì— ë¬¸ì œê°€ ìˆìŒ

#### í•´ê²° ë°©ì•ˆ

**2-1. ë©”ì„œë“œ íŒŒì‹± ë¡œì§ ê°•í™”**

```python
# phase1/parsers/java/javaparser_enhanced.py ìˆ˜ì •
class JavaParserEnhanced:
    def _extract_methods(self, content: str, class_id: int) -> List[Method]:
        """ë©”ì„œë“œ ì¶”ì¶œ ë¡œì§ ê°œì„ """
        methods = []
        
        # ì •ê·œí‘œí˜„ì‹ íŒ¨í„´ ê°œì„ 
        method_patterns = [
            # public, private, protected ë©”ì„œë“œ
            r'(public|private|protected)\s+(?:static\s+)?(?:final\s+)?(\w+(?:<[^>]+>)?|\w+\[\])\s+(\w+)\s*\(([^)]*)\)\s*(?:throws\s+[^{]+)?\s*\{',
            # ì–´ë…¸í…Œì´ì…˜ì´ ìˆëŠ” ë©”ì„œë“œ
            r'@\w+(?:\([^)]*\))?\s*\n\s*(public|private|protected)\s+(?:static\s+)?(?:final\s+)?(\w+(?:<[^>]+>)?|\w+\[\])\s+(\w+)\s*\(([^)]*)\)\s*(?:throws\s+[^{]+)?\s*\{',
            # íŒ¨í‚¤ì§€ í”„ë¼ì´ë¹— ë©”ì„œë“œ
            r'(?:static\s+)?(?:final\s+)?(\w+(?:<[^>]+>)?|\w+\[\])\s+(\w+)\s*\(([^)]*)\)\s*(?:throws\s+[^{]+)?\s*\{'
        ]
        
        for pattern in method_patterns:
            matches = re.finditer(pattern, content, re.MULTILINE | re.DOTALL)
            
            for match in matches:
                try:
                    method = self._create_method_object(match, class_id, content)
                    if method:
                        methods.append(method)
                except Exception as e:
                    logger.warning(f"ë©”ì„œë“œ íŒŒì‹± ì˜¤ë¥˜: {e}")
        
        return methods
    
    def _create_method_object(self, match: re.Match, class_id: int, content: str) -> Optional[Method]:
        """ë©”ì„œë“œ ê°ì²´ ìƒì„±"""
        groups = match.groups()
        
        # ê·¸ë£¹ ìˆ˜ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬
        if len(groups) >= 3:
            if len(groups) == 4:  # (modifier, return_type, method_name, parameters)
                modifier, return_type, method_name, parameters = groups
            else:  # (return_type, method_name, parameters)
                modifier = 'package'
                return_type, method_name, parameters = groups[:3]
            
            # ë©”ì„œë“œ ì‹œì‘/ë ë¼ì¸ ì°¾ê¸°
            start_line = content[:match.start()].count('\n') + 1
            
            # ì¤‘ê´„í˜¸ ë§¤ì¹­ìœ¼ë¡œ ë ë¼ì¸ ì°¾ê¸°
            method_end = self._find_method_end(content, match.end())
            end_line = content[:method_end].count('\n') + 1
            
            return Method(
                method_id=0,  # ë‚˜ì¤‘ì— DBì—ì„œ í• ë‹¹
                class_id=class_id,
                name=method_name,
                start_line=start_line,
                end_line=end_line,
                modifiers=modifier,
                parameters=parameters.strip(),
                return_type=return_type.strip()
            )
        
        return None
    
    def _find_method_end(self, content: str, start_pos: int) -> int:
        """ì¤‘ê´„í˜¸ ë§¤ì¹­ìœ¼ë¡œ ë©”ì„œë“œ ë ìœ„ì¹˜ ì°¾ê¸°"""
        brace_count = 0
        pos = start_pos
        
        while pos < len(content):
            char = content[pos]
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0:
                    return pos + 1
            pos += 1
        
        return len(content)
```

**2-2. íŒŒì„œ íŒ©í† ë¦¬ ìˆ˜ì •**

```python
# phase1/parsers/parser_factory.py ìˆ˜ì •
class ParserFactory:
    @staticmethod
    def create_java_parser(config: Dict[str, Any], onboarding_mode: bool = False):
        """Java íŒŒì„œ ìƒì„± (ì˜¨ë³´ë”© ëª¨ë“œ ì§€ì›)"""
        
        if onboarding_mode:
            from phase1.parsers.java.business_context_parser import BusinessContextParser
            return BusinessContextParser(config)
        else:
            from phase1.parsers.java.javaparser_enhanced import JavaParserEnhanced
            return JavaParserEnhanced(config)
```

### 3. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ í™•ì¥

#### ëª©ì 
ì˜¨ë³´ë”© ê´€ë ¨ ì •ë³´ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•œ í…Œì´ë¸” í™•ì¥

#### ì„¤ê³„ ë°©ì•ˆ

**3-1. ë¹„ì¦ˆë‹ˆìŠ¤ ì»¨í…ìŠ¤íŠ¸ í…Œì´ë¸”**

```sql
-- ë¹„ì¦ˆë‹ˆìŠ¤ ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ì €ì¥
CREATE TABLE business_contexts (
    context_id INTEGER PRIMARY KEY AUTOINCREMENT,
    target_type VARCHAR(50) NOT NULL,     -- 'class', 'method', 'file'
    target_id INTEGER NOT NULL,           -- ëŒ€ìƒ ê°ì²´ ID
    business_layer VARCHAR(50),           -- 'presentation', 'business', 'data_access', 'entity'
    business_domain VARCHAR(50),          -- 'user', 'order', 'product', 'auth'
    business_purpose TEXT,                -- ë¹„ì¦ˆë‹ˆìŠ¤ ëª©ì  ì„¤ëª…
    responsibilities TEXT,                -- JSON í˜•íƒœì˜ ì±…ì„ ëª©ë¡
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

**3-2. ì˜¨ë³´ë”© ì²­í¬ í…Œì´ë¸”**

```sql
-- ì˜¨ë³´ë”© ìµœì í™” ì²­í¬ ì •ë³´
CREATE TABLE onboarding_chunks (
    onboarding_chunk_id INTEGER PRIMARY KEY AUTOINCREMENT,
    chunk_id INTEGER NOT NULL,            -- ê¸°ì¡´ chunks í…Œì´ë¸” ì°¸ì¡°
    business_purpose TEXT,                -- ë¹„ì¦ˆë‹ˆìŠ¤ ëª©ì 
    complexity_level VARCHAR(20),         -- 'beginner', 'intermediate', 'advanced'
    learning_priority INTEGER,            -- 1-5 í•™ìŠµ ìš°ì„ ìˆœìœ„
    related_concepts TEXT,                -- JSON í˜•íƒœì˜ ê´€ë ¨ ê°œë… ëª©ë¡
    explanation TEXT,                     -- ì´ˆë³´ìë¥¼ ìœ„í•œ ì„¤ëª…
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chunk_id) REFERENCES chunks(chunk_id)
);
```

**3-3. í•™ìŠµ ê²½ë¡œ í…Œì´ë¸”**

```sql
-- í•™ìŠµ ê²½ë¡œ ì •ë³´
CREATE TABLE learning_paths (
    path_id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    path_name VARCHAR(100),               -- ê²½ë¡œ ì´ë¦„ (ì˜ˆ: "User Management Flow")
    sequence_order INTEGER,               -- í•™ìŠµ ìˆœì„œ
    chunk_id INTEGER NOT NULL,            -- í•™ìŠµí•  ì²­í¬
    prerequisites TEXT,                   -- JSON í˜•íƒœì˜ ì„ í–‰ í•™ìŠµ ë‚´ìš©
    learning_objectives TEXT,             -- í•™ìŠµ ëª©í‘œ
    estimated_time INTEGER,               -- ì˜ˆìƒ í•™ìŠµ ì‹œê°„ (ë¶„)
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chunk_id) REFERENCES chunks(chunk_id)
);
```

**3-4. ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ìŠ¤í¬ë¦½íŠ¸**

```python
# phase1/database/onboarding_schema.py
def create_onboarding_tables(conn):
    """ì˜¨ë³´ë”© ê´€ë ¨ í…Œì´ë¸” ìƒì„±"""
    
    schemas = [
        """
        CREATE TABLE IF NOT EXISTS business_contexts (
            context_id INTEGER PRIMARY KEY AUTOINCREMENT,
            target_type VARCHAR(50) NOT NULL,
            target_id INTEGER NOT NULL,
            business_layer VARCHAR(50),
            business_domain VARCHAR(50),
            business_purpose TEXT,
            responsibilities TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
        """,
        """
        CREATE TABLE IF NOT EXISTS onboarding_chunks (
            onboarding_chunk_id INTEGER PRIMARY KEY AUTOINCREMENT,
            chunk_id INTEGER NOT NULL,
            business_purpose TEXT,
            complexity_level VARCHAR(20),
            learning_priority INTEGER,
            related_concepts TEXT,
            explanation TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (chunk_id) REFERENCES chunks(chunk_id)
        )
        """,
        """
        CREATE TABLE IF NOT EXISTS learning_paths (
            path_id INTEGER PRIMARY KEY AUTOINCREMENT,
            project_id INTEGER NOT NULL,
            path_name VARCHAR(100),
            sequence_order INTEGER,
            chunk_id INTEGER NOT NULL,
            prerequisites TEXT,
            learning_objectives TEXT,
            estimated_time INTEGER,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (chunk_id) REFERENCES chunks(chunk_id)
        )
        """
    ]
    
    cursor = conn.cursor()
    for schema in schemas:
        cursor.execute(schema)
    
    conn.commit()
```

### 4. API ì—”ë“œí¬ì¸íŠ¸ ìë™ ë§¤í•‘

#### ëª©ì 
Controllerì˜ API ì—”ë“œí¬ì¸íŠ¸ì™€ ì„œë¹„ìŠ¤ ë©”ì„œë“œë¥¼ ìë™ìœ¼ë¡œ ë§¤í•‘í•˜ì—¬ ë¹„ì¦ˆë‹ˆìŠ¤ íë¦„ ì¶”ì 

#### ì„¤ê³„ ë°©ì•ˆ

**4-1. API ì—”ë“œí¬ì¸íŠ¸ ì¶”ì¶œê¸°**

```python
# phase1/parsers/java/api_endpoint_extractor.py
class ApiEndpointExtractor:
    """Spring MVC API ì—”ë“œí¬ì¸íŠ¸ ì¶”ì¶œ"""
    
    def __init__(self):
        self.endpoint_patterns = {
            'class_mapping': r'@RequestMapping\s*\(\s*["\']([^"\']+)["\']',
            'get_mapping': r'@GetMapping\s*\(\s*["\']([^"\']+)["\']',
            'post_mapping': r'@PostMapping\s*\(\s*["\']([^"\']+)["\']',
            'put_mapping': r'@PutMapping\s*\(\s*["\']([^"\']+)["\']',
            'delete_mapping': r'@DeleteMapping\s*\(\s*["\']([^"\']+)["\']'
        }
    
    def extract_endpoints(self, content: str, class_name: str) -> List[Dict[str, Any]]:
        """API ì—”ë“œí¬ì¸íŠ¸ ì¶”ì¶œ"""
        endpoints = []
        
        # í´ë˜ìŠ¤ ë ˆë²¨ ë§¤í•‘ ì¶”ì¶œ
        class_base_path = ""
        class_mapping_match = re.search(self.endpoint_patterns['class_mapping'], content)
        if class_mapping_match:
            class_base_path = class_mapping_match.group(1)
        
        # ë©”ì„œë“œë³„ ì—”ë“œí¬ì¸íŠ¸ ì¶”ì¶œ
        method_pattern = r'(@\w+Mapping[^}]+)\s*\n\s*public\s+\w+\s+(\w+)\s*\([^)]*\)'
        method_matches = re.finditer(method_pattern, content, re.MULTILINE | re.DOTALL)
        
        for match in method_matches:
            annotation_block = match.group(1)
            method_name = match.group(2)
            
            # HTTP ë©”ì„œë“œì™€ ê²½ë¡œ ì¶”ì¶œ
            for mapping_type, pattern in self.endpoint_patterns.items():
                if mapping_type == 'class_mapping':
                    continue
                    
                path_match = re.search(pattern, annotation_block)
                if path_match:
                    path = path_match.group(1)
                    full_path = f"{class_base_path}{path}".replace('//', '/')
                    
                    endpoint = {
                        'controller_class': class_name,
                        'method_name': method_name,
                        'http_method': mapping_type.replace('_mapping', '').upper(),
                        'path': full_path,
                        'annotation': annotation_block.strip()
                    }
                    endpoints.append(endpoint)
                    break
        
        return endpoints
    
    def create_endpoint_edges(self, endpoints: List[Dict[str, Any]], classes: List[Class]) -> List[Edge]:
        """ì—”ë“œí¬ì¸íŠ¸ ê´€ë ¨ ì—£ì§€ ìƒì„±"""
        edges = []
        
        for endpoint in endpoints:
            # API ì—”ë“œí¬ì¸íŠ¸ ì—£ì§€ ìƒì„±
            controller_class = self._find_class_by_name(endpoint['controller_class'], classes)
            
            if controller_class:
                edge = Edge(
                    project_id=1,
                    src_type='api_endpoint',
                    src_id=0,  # API ì—”ë“œí¬ì¸íŠ¸ ID (ë³„ë„ í…Œì´ë¸” í•„ìš”)
                    dst_type='class',
                    dst_id=controller_class.class_id,
                    edge_kind='api_endpoint',
                    confidence=1.0,
                    meta=json.dumps({
                        'http_method': endpoint['http_method'],
                        'path': endpoint['path'],
                        'method_name': endpoint['method_name']
                    })
                )
                edges.append(edge)
        
        return edges
```

**4-2. ì„œë¹„ìŠ¤ í˜¸ì¶œ ì¶”ì **

```python
# phase1/analyzers/service_call_tracer.py
class ServiceCallTracer:
    """ì„œë¹„ìŠ¤ í˜¸ì¶œ ê´€ê³„ ì¶”ì """
    
    def trace_service_calls(self, controller_content: str, controller_class: str) -> List[Dict[str, Any]]:
        """Controllerì—ì„œ Service í˜¸ì¶œ ì¶”ì """
        service_calls = []
        
        # ì˜ì¡´ì„± ì£¼ì…ëœ ì„œë¹„ìŠ¤ ì°¾ê¸°
        injection_pattern = r'@(?:Autowired|Inject)\s+(?:private\s+)?(\w+Service)\s+(\w+)'
        injections = re.findall(injection_pattern, controller_content)
        
        for service_class, service_var in injections:
            # í•´ë‹¹ ì„œë¹„ìŠ¤ ë³€ìˆ˜ì˜ ë©”ì„œë“œ í˜¸ì¶œ ì°¾ê¸°
            call_pattern = f'{service_var}\\.(\w+)\\s*\\('
            calls = re.findall(call_pattern, controller_content)
            
            for method_call in calls:
                service_call = {
                    'controller_class': controller_class,
                    'service_class': service_class,
                    'service_method': method_call,
                    'call_pattern': f"{service_var}.{method_call}()"
                }
                service_calls.append(service_call)
        
        return service_calls
    
    def create_service_call_edges(self, service_calls: List[Dict[str, Any]], classes: List[Class]) -> List[Edge]:
        """ì„œë¹„ìŠ¤ í˜¸ì¶œ ì—£ì§€ ìƒì„±"""
        edges = []
        
        for call in service_calls:
            controller = self._find_class_by_name(call['controller_class'], classes)
            service = self._find_class_by_name(call['service_class'], classes)
            
            if controller and service:
                edge = Edge(
                    project_id=1,
                    src_type='class',
                    src_id=controller.class_id,
                    dst_type='class', 
                    dst_id=service.class_id,
                    edge_kind='service_call',
                    confidence=0.9,
                    meta=json.dumps({
                        'method_called': call['service_method'],
                        'call_pattern': call['call_pattern']
                    })
                )
                edges.append(edge)
        
        return edges
```

### 5. ì‹ ê·œì…ì‚¬ììš© ëŒ€ì‹œë³´ë“œ API ì„¤ê³„

#### ëª©ì 
ìƒì„±ëœ ë©”íƒ€ë°ì´í„°ë¥¼ í™œìš©í•˜ì—¬ ì‹ ê·œì…ì‚¬ìê°€ ì‰½ê²Œ ì´í•´í•  ìˆ˜ ìˆëŠ” API ì œê³µ

#### ì„¤ê³„ ë°©ì•ˆ

**5-1. FastAPI ê¸°ë°˜ REST API**

```python
# api/onboarding_api.py
from fastapi import FastAPI, Query, Path
from typing import List, Optional
import sqlite3

app = FastAPI(title="ì‹ ê·œì…ì‚¬ì ì˜¨ë³´ë”© API")

class OnboardingAPI:
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    @app.get("/api/v1/learning-path/{domain}")
    async def get_learning_path(
        domain: str = Path(..., description="í•™ìŠµ ë„ë©”ì¸ (user, order, product)"),
        level: str = Query("beginner", description="í•™ìŠµ ë ˆë²¨")
    ):
        """ë„ë©”ì¸ë³„ í•™ìŠµ ê²½ë¡œ ì¡°íšŒ"""
        
        query = """
        SELECT 
            oc.chunk_id,
            oc.business_purpose,
            oc.complexity_level,
            oc.learning_priority,
            oc.explanation,
            c.content,
            bc.business_layer
        FROM onboarding_chunks oc
        JOIN chunks c ON oc.chunk_id = c.chunk_id
        JOIN business_contexts bc ON c.target_id = bc.target_id
        WHERE bc.business_domain = ? AND oc.complexity_level = ?
        ORDER BY oc.learning_priority DESC
        """
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute(query, (domain, level))
        
        results = []
        for row in cursor.fetchall():
            chunk_id, purpose, complexity, priority, explanation, content, layer = row
            results.append({
                "chunk_id": chunk_id,
                "business_purpose": purpose,
                "complexity_level": complexity,
                "learning_priority": priority,
                "explanation": explanation,
                "preview": content[:200] + "..." if len(content) > 200 else content,
                "business_layer": layer
            })
        
        conn.close()
        return {"learning_path": results, "domain": domain, "level": level}
    
    @app.get("/api/v1/business-flow/{flow_type}")
    async def get_business_flow(flow_type: str = Path(..., description="ë¹„ì¦ˆë‹ˆìŠ¤ íë¦„ íƒ€ì…")):
        """ë¹„ì¦ˆë‹ˆìŠ¤ íë¦„ ì¡°íšŒ"""
        
        query = """
        SELECT 
            e.src_id,
            e.dst_id,
            e.edge_kind,
            e.meta,
            c1.name as src_class,
            c2.name as dst_class,
            bc1.business_layer as src_layer,
            bc2.business_layer as dst_layer
        FROM edges e
        JOIN classes c1 ON e.src_id = c1.class_id
        JOIN classes c2 ON e.dst_id = c2.class_id
        LEFT JOIN business_contexts bc1 ON c1.class_id = bc1.target_id AND bc1.target_type = 'class'
        LEFT JOIN business_contexts bc2 ON c2.class_id = bc2.target_id AND bc2.target_type = 'class'
        WHERE e.edge_kind IN ('business_flow', 'service_call', 'api_endpoint')
        ORDER BY bc1.business_layer, bc2.business_layer
        """
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute(query)
        
        flows = []
        for row in cursor.fetchall():
            src_id, dst_id, edge_kind, meta, src_class, dst_class, src_layer, dst_layer = row
            flows.append({
                "source": {
                    "class_id": src_id,
                    "class_name": src_class,
                    "business_layer": src_layer
                },
                "target": {
                    "class_id": dst_id,
                    "class_name": dst_class,
                    "business_layer": dst_layer
                },
                "relationship_type": edge_kind,
                "metadata": meta
            })
        
        conn.close()
        return {"business_flows": flows, "flow_type": flow_type}
    
    @app.get("/api/v1/code-explanation/{chunk_id}")
    async def get_code_explanation(chunk_id: int = Path(..., description="ì²­í¬ ID")):
        """ì½”ë“œ ì„¤ëª… ì¡°íšŒ"""
        
        query = """
        SELECT 
            c.content,
            oc.business_purpose,
            oc.explanation,
            oc.related_concepts,
            bc.business_layer,
            bc.business_domain
        FROM chunks c
        JOIN onboarding_chunks oc ON c.chunk_id = oc.chunk_id
        LEFT JOIN business_contexts bc ON c.target_id = bc.target_id AND c.target_type = bc.target_type
        WHERE c.chunk_id = ?
        """
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute(query, (chunk_id,))
        
        row = cursor.fetchone()
        if not row:
            return {"error": "Chunk not found"}
        
        content, purpose, explanation, concepts, layer, domain = row
        
        conn.close()
        return {
            "chunk_id": chunk_id,
            "code_content": content,
            "business_purpose": purpose,
            "beginner_explanation": explanation,
            "related_concepts": json.loads(concepts) if concepts else [],
            "business_layer": layer,
            "business_domain": domain,
            "learning_suggestions": self._generate_learning_suggestions(layer, domain)
        }
    
    def _generate_learning_suggestions(self, layer: str, domain: str) -> List[str]:
        """í•™ìŠµ ì œì•ˆ ìƒì„±"""
        suggestions = {
            "presentation": [
                "Spring MVC íŒ¨í„´ ì´í•´í•˜ê¸°",
                "HTTP ìš”ì²­/ì‘ë‹µ ì²˜ë¦¬ ë°©ì‹",
                "RESTful API ì„¤ê³„ ì›ì¹™"
            ],
            "business": [
                "ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ê³¼ íŠ¸ëœì­ì…˜ ê´€ë¦¬",
                "ì„œë¹„ìŠ¤ ë ˆì´ì–´ íŒ¨í„´",
                "ë„ë©”ì¸ ì£¼ë„ ì„¤ê³„(DDD) ê¸°ì´ˆ"
            ],
            "data_access": [
                "MyBatis ë§¤í¼ ì‘ì„±ë²•",
                "SQL ì¿¼ë¦¬ ìµœì í™”",
                "ë°ì´í„°ë² ì´ìŠ¤ íŠ¸ëœì­ì…˜"
            ]
        }
        
        return suggestions.get(layer, ["ê¸°ë³¸ Java ë¬¸ë²• ìµíˆê¸°"])
```

**5-2. í”„ë¡ íŠ¸ì—”ë“œ ì»´í¬ë„ŒíŠ¸ ì˜ˆì‹œ**

```javascript
// frontend/components/LearningPathViewer.js
import React, { useState, useEffect } from 'react';

const LearningPathViewer = ({ domain, level }) => {
    const [learningPath, setLearningPath] = useState([]);
    const [selectedChunk, setSelectedChunk] = useState(null);
    
    useEffect(() => {
        fetchLearningPath();
    }, [domain, level]);
    
    const fetchLearningPath = async () => {
        const response = await fetch(`/api/v1/learning-path/${domain}?level=${level}`);
        const data = await response.json();
        setLearningPath(data.learning_path);
    };
    
    const handleChunkClick = async (chunkId) => {
        const response = await fetch(`/api/v1/code-explanation/${chunkId}`);
        const explanation = await response.json();
        setSelectedChunk(explanation);
    };
    
    return (
        <div className="learning-path-viewer">
            <h2>{domain} ë„ë©”ì¸ í•™ìŠµ ê²½ë¡œ ({level})</h2>
            
            <div className="path-list">
                {learningPath.map((item, index) => (
                    <div 
                        key={item.chunk_id}
                        className={`path-item ${item.complexity_level}`}
                        onClick={() => handleChunkClick(item.chunk_id)}
                    >
                        <div className="priority-badge">ìš°ì„ ìˆœìœ„: {item.learning_priority}</div>
                        <h4>{item.business_purpose}</h4>
                        <p>{item.explanation}</p>
                        <span className="layer-tag">{item.business_layer}</span>
                    </div>
                ))}
            </div>
            
            {selectedChunk && (
                <div className="code-explanation-panel">
                    <h3>ì½”ë“œ ìƒì„¸ ì„¤ëª…</h3>
                    <div className="business-context">
                        <strong>ë¹„ì¦ˆë‹ˆìŠ¤ ëª©ì :</strong> {selectedChunk.business_purpose}
                    </div>
                    <div className="explanation">
                        <strong>ì´ˆë³´ìë¥¼ ìœ„í•œ ì„¤ëª…:</strong>
                        <p>{selectedChunk.beginner_explanation}</p>
                    </div>
                    <div className="related-concepts">
                        <strong>ê´€ë ¨ ê°œë…:</strong>
                        <ul>
                            {selectedChunk.related_concepts.map(concept => (
                                <li key={concept}>{concept}</li>
                            ))}
                        </ul>
                    </div>
                    <div className="learning-suggestions">
                        <strong>ì¶”ì²œ í•™ìŠµ ë‚´ìš©:</strong>
                        <ul>
                            {selectedChunk.learning_suggestions.map(suggestion => (
                                <li key={suggestion}>{suggestion}</li>
                            ))}
                        </ul>
                    </div>
                </div>
            )}
        </div>
    );
};

export default LearningPathViewer;
```

## ğŸš€ êµ¬í˜„ ìˆœì„œ ê°€ì´ë“œ

### Phase 1: ë©”ì¸ íŒŒì´í”„ë¼ì¸ í†µí•© (1ì£¼ì°¨)
1. SourceAnalyzerì— onboarding_mode íŒŒë¼ë¯¸í„° ì¶”ê°€
2. ë©”ì„œë“œ íŒŒì‹± ë¬¸ì œ í•´ê²°
3. BusinessContextParser í†µí•© í…ŒìŠ¤íŠ¸

### Phase 2: ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ í™•ì¥ (1ì£¼ì°¨) 
1. ì˜¨ë³´ë”© ê´€ë ¨ í…Œì´ë¸” ìƒì„±
2. ë°ì´í„° ì €ì¥/ì¡°íšŒ ë¡œì§ êµ¬í˜„
3. ê¸°ì¡´ ë°ì´í„°ì™€ì˜ ì—°ê´€ê´€ê³„ ì„¤ì •

### Phase 3: API ì—”ë“œí¬ì¸íŠ¸ ì¶”ì¶œ (2ì£¼ì°¨)
1. ApiEndpointExtractor êµ¬í˜„
2. ServiceCallTracer êµ¬í˜„  
3. ë¹„ì¦ˆë‹ˆìŠ¤ íë¦„ ì—£ì§€ ìƒì„± ë¡œì§ í†µí•©

### Phase 4: REST API êµ¬í˜„ (2ì£¼ì°¨)
1. FastAPI ê¸°ë°˜ ì˜¨ë³´ë”© API êµ¬í˜„
2. í•™ìŠµ ê²½ë¡œ, ë¹„ì¦ˆë‹ˆìŠ¤ íë¦„ ì¡°íšŒ ì—”ë“œí¬ì¸íŠ¸
3. ì½”ë“œ ì„¤ëª… ë° í•™ìŠµ ì œì•ˆ API

### Phase 5: í”„ë¡ íŠ¸ì—”ë“œ êµ¬í˜„ (3ì£¼ì°¨)
1. React ê¸°ë°˜ í•™ìŠµ ê²½ë¡œ ë·°ì–´
2. ì½”ë“œ ì„¤ëª… íŒ¨ë„
3. ë¹„ì¦ˆë‹ˆìŠ¤ íë¦„ ë‹¤ì´ì–´ê·¸ë¨

## ğŸ“‹ ê²€ì¦ ê³„íš

### ê¸°ëŠ¥ ê²€ì¦
1. **íŒŒì‹± ì •í™•ë„**: ë©”ì„œë“œ, í´ë˜ìŠ¤, ì—£ì§€ ì¶”ì¶œ ì •í™•ì„± ê²€ì¦
2. **ë¹„ì¦ˆë‹ˆìŠ¤ ì»¨í…ìŠ¤íŠ¸**: ê³„ì¸µ/ë„ë©”ì¸ ë¶„ë¥˜ ì •í™•ë„ ì¸¡ì •
3. **í•™ìŠµ ìš°ì„ ìˆœìœ„**: ë³µì¡ë„ ë¶„ì„ ê²°ê³¼ì˜ ì‹¤ìš©ì„± í‰ê°€

### ì„±ëŠ¥ ê²€ì¦  
1. **ë¶„ì„ ì†ë„**: ì˜¨ë³´ë”© ëª¨ë“œì™€ ì¼ë°˜ ëª¨ë“œ ë¶„ì„ ì‹œê°„ ë¹„êµ
2. **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**: ì¶”ê°€ëœ ì»´í¬ë„ŒíŠ¸ë“¤ì˜ ë©”ëª¨ë¦¬ ì˜í–¥ ì¸¡ì •
3. **API ì‘ë‹µì‹œê°„**: ì˜¨ë³´ë”© APIì˜ ì‘ë‹µ ì‹œê°„ ì¸¡ì •

### ì‚¬ìš©ì„± ê²€ì¦
1. **ì‹ ê·œì…ì‚¬ì í”¼ë“œë°±**: ì‹¤ì œ ì‚¬ìš©ìì˜ í•™ìŠµ íš¨ê³¼ ì¸¡ì •
2. **í•™ìŠµ ê²½ë¡œ ìœ ìš©ì„±**: ì¶”ì²œëœ í•™ìŠµ ìˆœì„œì˜ ì ì ˆì„± í‰ê°€
3. **ì½”ë“œ ì´í•´ë„ í–¥ìƒ**: ì‹œìŠ¤í…œ ì‚¬ìš© ì „í›„ ì½”ë“œ ì´í•´ë„ ë¹„êµ

---

**ì‘ì„±ì**: AI Assistant  
**ì‘ì„±ì¼**: 2025-09-06 16:20  
**í”„ë¡œì íŠ¸**: sampleSrc ì‹ ê·œì…ì‚¬ì ì˜¨ë³´ë”© ì‹œìŠ¤í…œ  
**ìƒíƒœ**: âœ… ê°œë°œ ì™„ë£Œ (í†µí•© ì‘ì—… í•„ìš”)
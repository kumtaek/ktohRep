# SourceAnalyzer ÏãúÍ∞ÅÌôî Í≥†ÎèÑÌôî ÏÑ§Í≥ÑÏÑú

## üìä ÌòÑÏû¨ ÏÉÅÌô© Î∂ÑÏÑù

### üö´ Ï£ºÏöî Î¨∏Ï†úÏ†ê

**Image #1 (ERD ÏÉÅÎã®)Ïùò Î¨∏Ï†ú**:
- ÌÖåÏù¥Î∏îÎì§Ïù¥ Î¨¥ÏûëÏúÑÎ°ú Î∞∞ÏπòÎêòÏñ¥ Î≥µÏû°Ìï®
- Ïó∞Í≤∞ÏÑ†Îì§Ïù¥ ÏÑúÎ°ú ÍµêÏ∞®ÌïòÏó¨ Í∞ÄÎèÖÏÑ± Ï†ÄÌïò
- ÌÖåÏù¥Î∏î Î∞∞ÏπòÍ∞Ä ÎÖºÎ¶¨Ï†Å Íµ¨Ï°∞Î•º Î∞òÏòÅÌïòÏßÄ Î™ªÌï®
- Ï†ÑÏ≤¥Ï†ÅÏù∏ Î†àÏù¥ÏïÑÏõÉÏù¥ ÏÇ∞ÎßåÌï®

**Image #2 (ERD ÌïòÎã®)Ïùò Î¨∏Ï†ú**:
- ÎÖ∏ÎìúÎì§Ïù¥ ÏÑúÎ°ú Í≤πÏ≥êÏÑú ÎÇ¥Ïö© ÌôïÏù∏ Î∂àÍ∞Ä
- Ïó∞Í≤∞ÏÑ†Îì§Ïù¥ Î≥µÏû°ÌïòÍ≤å ÏñΩÌòÄÏûàÏùå
- Í∏ÄÏûê ÌÅ¨Í∏∞Í∞Ä ÎÑàÎ¨¥ ÏûëÏïÑÏÑú ÏùΩÍ∏∞ Ïñ¥Î†§ÏõÄ
- Í≥µÍ∞Ñ ÌôúÏö©Ïù¥ ÎπÑÌö®Ïú®Ï†ÅÏûÑ

**Í≥µÌÜµ Î¨∏Ï†úÏ†ê**:
1. **Î†àÏù¥ÏïÑÏõÉ ÏïåÍ≥†Î¶¨Ï¶ò Î∂ÄÏ°±**: ÏûêÎèô Î∞∞Ïπò Î°úÏßÅÏù¥ ÏóÜÏùå
2. **Ï∂©Îèå Î∞©ÏßÄ Î∂ÄÏû¨**: ÎÖ∏ÎìúÏôÄ Ïó£ÏßÄ Í∞Ñ Í≤πÏπ® Î∞©ÏßÄ Í∏∞Îä• ÏóÜÏùå
3. **Ïä§ÏºÄÏùºÎßÅ Î¨∏Ï†ú**: Ìè∞Ìä∏ ÌÅ¨Í∏∞ÏôÄ ÎÖ∏Îìú ÌÅ¨Í∏∞ Ï°∞Ï†ï Î∂ÄÏ°±
4. **ÏãúÍ∞ÅÏ†Å Í≥ÑÏ∏µÍµ¨Ï°∞ Î∂ÄÏ°±**: Ï§ëÏöîÎèÑÏóê Îî∞Î•∏ Î∞∞Ïπò Î∞è Ïä§ÌÉÄÏùºÎßÅ ÏóÜÏùå

---

## üéØ Í∞úÏÑ† Î™©Ìëú

### 1. Î†àÏù¥ÏïÑÏõÉ ÏµúÏ†ÅÌôî
- **ÏûêÎèô Î∞∞Ïπò ÏïåÍ≥†Î¶¨Ï¶ò**: ÎÖ∏Îìú Í∞Ñ Í≤πÏπ® Î∞©ÏßÄ Î∞è ÏµúÏ†Å Í±∞Î¶¨ Ïú†ÏßÄ
- **Í≥ÑÏ∏µÏ†Å Íµ¨Ï°∞**: Í¥ÄÍ≥ÑÏùò Ï§ëÏöîÎèÑÏôÄ ÎÖºÎ¶¨Ï†Å Íµ¨Ï°∞ Î∞òÏòÅ
- **Ï†ÅÏùëÏ†Å Ï∫îÎ≤ÑÏä§**: Ïª®ÌÖêÏ∏†Ïóê Îî∞Îùº ÏûêÎèôÏúºÎ°ú ÌÅ¨Í∏∞ Ï°∞Ï†ï

### 2. Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ
- **ÎèôÏ†Å Ìè∞Ìä∏ Ïä§ÏºÄÏùºÎßÅ**: ÎÖ∏Îìú ÌÅ¨Í∏∞ÏôÄ Ï§å Î†àÎ≤®Ïóê Îî∞Î•∏ Ìè∞Ìä∏ Ï°∞Ï†ï
- **Ï∂©Îèå Î∞©ÏßÄ**: ÎùºÎ≤®Í≥º ÎÖ∏Îìú Í∞Ñ Í≤πÏπ® ÏôÑÏ†Ñ Ï†úÍ±∞
- **ÏÉâÏÉÅ Ï≤¥Í≥Ñ Í∞úÏÑ†**: Í∞ÄÎèÖÏÑ±ÏùÑ ÎÜíÏù¥Îäî ÏÉâÏÉÅ Ï°∞Ìï©

### 3. ÏÉÅÌò∏ÏûëÏö©ÏÑ± Í∞ïÌôî
- **Ï§å Ïù∏/ÏïÑÏõÉ**: ÏÑ∏Î∂ÄÏÇ¨Ìï≠Í≥º Ï†ÑÏ≤¥ Íµ¨Ï°∞ Î™®Îëê ÌôïÏù∏ Í∞ÄÎä•
- **ÎÖ∏Îìú ÎìúÎûòÍ∑∏**: ÏàòÎèôÏúºÎ°ú ÏúÑÏπò Ï°∞Ï†ï Í∞ÄÎä•
- **ÌïÑÌÑ∞ÎßÅ**: Î≥µÏû°Ìïú Íµ¨Ï°∞ÏóêÏÑú ÏõêÌïòÎäî Î∂ÄÎ∂ÑÎßå ÌëúÏãú

---

## üèóÔ∏è Í∏∞Ïà†Ï†Å ÏÑ§Í≥Ñ

### 1. Î†àÏù¥ÏïÑÏõÉ ÏóîÏßÑ ÏÑ§Í≥Ñ

#### A. Ìè¨Ïä§ ÎîîÎ†âÌã∞Îìú Î†àÏù¥ÏïÑÏõÉ (Force-Directed Layout)

```javascript
class ForceDirectedLayoutEngine {
    constructor(config = {}) {
        this.config = {
            // ÎÖ∏Îìú Í∞Ñ Í∏∞Î≥∏ Í±∞Î¶¨
            linkDistance: 150,
            // ÎÖ∏Îìú Í∞Ñ Î∞òÎ∞úÎ†•
            chargeStrength: -300,
            // Ï§ëÏã¨ÏúºÎ°ú ÎÅåÏñ¥ÎãπÍ∏∞Îäî Ìûò
            centeringStrength: 0.1,
            // ÏãúÎÆ¨Î†àÏù¥ÏÖò Í∞ïÎèÑ
            alphaDecay: 0.02,
            // ÏµúÏÜå ÎÖ∏Îìú Í∞ÑÍ≤©
            minNodeDistance: 80,
            ...config
        };
        
        this.simulation = null;
        this.nodes = [];
        this.links = [];
    }
    
    initializeSimulation(nodes, links) {
        this.nodes = nodes.map(node => ({
            ...node,
            // Ï¥àÍ∏∞ ÏúÑÏπòÎ•º ÏõêÌòïÏúºÎ°ú Î∞∞Ïπò
            x: node.x || Math.cos(node.index * 2 * Math.PI / nodes.length) * 200,
            y: node.y || Math.sin(node.index * 2 * Math.PI / nodes.length) * 200,
            // ÎÖ∏Îìú ÌÅ¨Í∏∞Ïóê Îî∞Î•∏ Í∞ÄÏ§ëÏπò
            weight: this.calculateNodeWeight(node)
        }));
        
        this.links = links.map(link => ({
            ...link,
            source: this.findNodeById(link.source),
            target: this.findNodeById(link.target),
            // Í¥ÄÍ≥Ñ Ï§ëÏöîÎèÑÏóê Îî∞Î•∏ ÎßÅÌÅ¨ Í∞ïÎèÑ
            strength: this.calculateLinkStrength(link)
        }));
        
        this.simulation = d3.forceSimulation(this.nodes)
            .force("link", d3.forceLink(this.links)
                .id(d => d.id)
                .distance(d => this.calculateLinkDistance(d))
                .strength(d => d.strength)
            )
            .force("charge", d3.forceManyBody()
                .strength(d => this.calculateChargeStrength(d))
            )
            .force("center", d3.forceCenter(0, 0)
                .strength(this.config.centeringStrength)
            )
            .force("collision", d3.forceCollide()
                .radius(d => this.calculateCollisionRadius(d))
            )
            .alphaDecay(this.config.alphaDecay);
    }
    
    calculateNodeWeight(node) {
        // Ïó∞Í≤∞Îêú ÎßÅÌÅ¨ ÏàòÏóê Îî∞Î•∏ Í∞ÄÏ§ëÏπò
        const connectionCount = this.links.filter(link => 
            link.source === node.id || link.target === node.id
        ).length;
        
        // ÎÖ∏Îìú ÌÉÄÏûÖÏóê Îî∞Î•∏ Í∞ÄÏ§ëÏπò (Ïòà: PRIMARY KEY ÌÖåÏù¥Î∏îÏù¥ Ï§ëÏã¨)
        const typeWeight = {
            'primary_table': 3.0,
            'reference_table': 2.0,
            'lookup_table': 1.5,
            'junction_table': 1.0
        }[node.type] || 1.0;
        
        return Math.sqrt(connectionCount) * typeWeight;
    }
    
    calculateLinkDistance(link) {
        const baseDistance = this.config.linkDistance;
        const sourceWeight = link.source.weight || 1;
        const targetWeight = link.target.weight || 1;
        
        // Ï§ëÏöîÌïú ÎÖ∏ÎìúÎì§ Í∞ÑÏùò Í±∞Î¶¨Îäî Îçî Í∞ÄÍπùÍ≤å
        const weightFactor = Math.max(sourceWeight, targetWeight) / 2;
        
        return baseDistance / Math.sqrt(weightFactor);
    }
    
    calculateChargeStrength(node) {
        // ÎÖ∏Îìú ÌÅ¨Í∏∞ÏôÄ Ï§ëÏöîÎèÑÏóê Îî∞Î•∏ Î∞òÎ∞úÎ†• Ï°∞Ï†ï
        const baseFactor = this.config.chargeStrength;
        const sizeFactor = Math.sqrt(node.weight || 1);
        
        return baseFactor * sizeFactor;
    }
    
    calculateCollisionRadius(node) {
        // ÎÖ∏Îìú Ïã§Ï†ú ÌÅ¨Í∏∞ + Ïó¨Î∞±
        const baseRadius = this.getNodeRadius(node);
        const padding = 20; // ÏµúÏÜå Ïó¨Î∞±
        
        return baseRadius + padding;
    }
    
    getNodeRadius(node) {
        // ÌÖçÏä§Ìä∏ Í∏∏Ïù¥ÏôÄ ÎÖ∏Îìú ÌÉÄÏûÖÏóê Îî∞Î•∏ Î∞òÏßÄÎ¶Ñ Í≥ÑÏÇ∞
        const textLength = (node.name || '').length;
        const baseRadius = 40;
        const textFactor = Math.max(textLength * 3, 60); // ÏµúÏÜå ÎÑàÎπÑ Î≥¥Ïû•
        
        return Math.max(baseRadius, textFactor);
    }
}
```

#### B. Í≥ÑÏ∏µÏ†Å Î†àÏù¥ÏïÑÏõÉ (Hierarchical Layout)

```javascript
class HierarchicalLayoutEngine {
    constructor(config = {}) {
        this.config = {
            levelHeight: 200,      // Í≥ÑÏ∏µ Í∞Ñ ÎÜíÏù¥
            nodeSpacing: 120,      // Í∞ôÏùÄ Î†àÎ≤® ÎÖ∏Îìú Í∞ÑÍ≤©
            centeringEnabled: true, // Î†àÎ≤® ÎÇ¥ ÏÑºÌÑ∞ÎßÅ
            ...config
        };
    }
    
    calculateHierarchicalLayout(nodes, links) {
        // 1. ÎÖ∏ÎìúÎ•º Í≥ÑÏ∏µÏúºÎ°ú Î∂ÑÎ•ò
        const hierarchy = this.buildHierarchy(nodes, links);
        
        // 2. Í∞Å Î†àÎ≤®ÏóêÏÑú ÎÖ∏Îìú Î∞∞Ïπò
        const positioned = this.positionNodesByLevel(hierarchy);
        
        // 3. Ïó∞Í≤∞ÏÑ† ÏµúÏ†ÅÌôî
        const optimized = this.optimizeConnections(positioned, links);
        
        return optimized;
    }
    
    buildHierarchy(nodes, links) {
        const hierarchy = new Map();
        const visited = new Set();
        const nodeMap = new Map(nodes.map(n => [n.id, n]));
        
        // Î£®Ìä∏ ÎÖ∏ÎìúÎì§ Ï∞æÍ∏∞ (Îì§Ïñ¥Ïò§Îäî Ïó∞Í≤∞Ïù¥ ÏóÜÎäî ÎÖ∏Îìú)
        const incomingCount = new Map();
        links.forEach(link => {
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            incomingCount.set(targetId, (incomingCount.get(targetId) || 0) + 1);
        });
        
        const rootNodes = nodes.filter(node => !incomingCount.has(node.id));
        
        // BFSÎ°ú Í≥ÑÏ∏µ Íµ¨Ï∂ï
        let level = 0;
        let currentLevel = rootNodes;
        
        while (currentLevel.length > 0) {
            hierarchy.set(level, [...currentLevel]);
            
            const nextLevel = new Set();
            currentLevel.forEach(node => {
                visited.add(node.id);
                
                // ÏûêÏãù ÎÖ∏ÎìúÎì§ Ï∞æÍ∏∞
                links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    
                    if (sourceId === node.id && !visited.has(targetId)) {
                        const targetNode = nodeMap.get(targetId);
                        if (targetNode) {
                            nextLevel.add(targetNode);
                        }
                    }
                });
            });
            
            currentLevel = Array.from(nextLevel);
            level++;
        }
        
        // Î∞©Î¨∏ÌïòÏßÄ ÏïäÏùÄ ÎÖ∏ÎìúÎì§ÏùÄ ÎßàÏßÄÎßâ Î†àÎ≤®Ïóê Ï∂îÍ∞Ä
        const unvisited = nodes.filter(node => !visited.has(node.id));
        if (unvisited.length > 0) {
            hierarchy.set(level, unvisited);
        }
        
        return hierarchy;
    }
    
    positionNodesByLevel(hierarchy) {
        const positioned = [];
        const canvasWidth = this.calculateRequiredWidth(hierarchy);
        
        hierarchy.forEach((levelNodes, level) => {
            const y = level * this.config.levelHeight;
            const totalWidth = levelNodes.length * this.config.nodeSpacing;
            const startX = (canvasWidth - totalWidth) / 2;
            
            levelNodes.forEach((node, index) => {
                const x = startX + index * this.config.nodeSpacing;
                
                positioned.push({
                    ...node,
                    x: x,
                    y: y,
                    level: level,
                    levelIndex: index
                });
            });
        });
        
        return positioned;
    }
    
    calculateRequiredWidth(hierarchy) {
        let maxWidth = 0;
        
        hierarchy.forEach(levelNodes => {
            const levelWidth = levelNodes.length * this.config.nodeSpacing;
            maxWidth = Math.max(maxWidth, levelWidth);
        });
        
        return Math.max(maxWidth, 800); // ÏµúÏÜå ÎÑàÎπÑ Î≥¥Ïû•
    }
    
    optimizeConnections(nodes, links) {
        // Ïó∞Í≤∞ÏÑ†Ïù¥ ÍµêÏ∞®ÌïòÎäî Í≤ÉÏùÑ ÏµúÏÜåÌôîÌïòÍ∏∞ ÏúÑÌïú ÎÖ∏Îìú Ïû¨Î∞∞Ïπò
        return this.minimizeCrossings(nodes, links);
    }
    
    minimizeCrossings(nodes, links) {
        // ÍµêÏ∞® ÏµúÏÜåÌôî ÏïåÍ≥†Î¶¨Ï¶ò (Îã®ÏàúÌôîÎêú Î≤ÑÏ†Ñ)
        const nodesByLevel = new Map();
        nodes.forEach(node => {
            if (!nodesByLevel.has(node.level)) {
                nodesByLevel.set(node.level, []);
            }
            nodesByLevel.get(node.level).push(node);
        });
        
        // Í∞Å Î†àÎ≤®ÏóêÏÑú ÍµêÏ∞®Î•º ÏµúÏÜåÌôîÌïòÎèÑÎ°ù ÎÖ∏Îìú ÏàúÏÑú Ï°∞Ï†ï
        nodesByLevel.forEach((levelNodes, level) => {
            if (level > 0) {
                levelNodes.sort((a, b) => {
                    const aConnections = this.getIncomingConnections(a, links);
                    const bConnections = this.getIncomingConnections(b, links);
                    
                    const aAvgX = aConnections.reduce((sum, conn) => sum + conn.source.x, 0) / Math.max(aConnections.length, 1);
                    const bAvgX = bConnections.reduce((sum, conn) => sum + conn.source.x, 0) / Math.max(bConnections.length, 1);
                    
                    return aAvgX - bAvgX;
                });
                
                // Ïû¨Ï†ïÎ†¨Îêú ÏàúÏÑúÎ°ú x Ï¢åÌëú Ïû¨Í≥ÑÏÇ∞
                const totalWidth = levelNodes.length * this.config.nodeSpacing;
                const canvasWidth = this.calculateRequiredWidth(new Map([...nodesByLevel.entries()]));
                const startX = (canvasWidth - totalWidth) / 2;
                
                levelNodes.forEach((node, index) => {
                    node.x = startX + index * this.config.nodeSpacing;
                    node.levelIndex = index;
                });
            }
        });
        
        return nodes;
    }
    
    getIncomingConnections(node, links) {
        return links.filter(link => {
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            return targetId === node.id;
        });
    }
}
```

### 2. Ï†ÅÏùëÌòï Î†åÎçîÎßÅ ÏãúÏä§ÌÖú

#### A. ÎèôÏ†Å Ïä§ÏºÄÏùºÎßÅ Îß§ÎãàÏ†Ä

```javascript
class AdaptiveScaleManager {
    constructor(container) {
        this.container = container;
        this.currentZoom = 1;
        this.minZoom = 0.1;
        this.maxZoom = 3;
        
        this.fontSizeMap = {
            0.1: 8,   // Îß§Ïö∞ Ï∂ïÏÜåÏãú
            0.25: 10,
            0.5: 12,
            0.75: 14,
            1.0: 16,  // Í∏∞Î≥∏ ÌÅ¨Í∏∞
            1.25: 18,
            1.5: 20,
            2.0: 22,
            3.0: 24   // ÏµúÎåÄ ÌôïÎåÄÏãú
        };
        
        this.setupZoomBehavior();
    }
    
    setupZoomBehavior() {
        const zoom = d3.zoom()
            .scaleExtent([this.minZoom, this.maxZoom])
            .on("zoom", (event) => {
                this.handleZoom(event);
            });
            
        this.container.call(zoom);
    }
    
    handleZoom(event) {
        const { transform } = event;
        this.currentZoom = transform.k;
        
        // Î™®Îì† Í∑∏ÎûòÌîΩ ÏöîÏÜåÏóê Î≥ÄÌôò Ï†ÅÏö©
        const mainGroup = this.container.select('.main-group');
        mainGroup.attr("transform", transform);
        
        // Ìè∞Ìä∏ ÌÅ¨Í∏∞ ÎèôÏ†Å Ï°∞Ï†ï
        this.adjustFontSizes();
        
        // ÏÑ† ÍµµÍ∏∞ Ï°∞Ï†ï
        this.adjustStrokeWidths();
        
        // ÎÖ∏Îìú ÌÅ¨Í∏∞ Ï°∞Ï†ï
        this.adjustNodeSizes();
    }
    
    adjustFontSizes() {
        const targetFontSize = this.calculateOptimalFontSize();
        
        this.container.selectAll('.node-label')
            .transition()
            .duration(150)
            .style('font-size', `${targetFontSize}px`);
            
        this.container.selectAll('.edge-label')
            .transition()
            .duration(150)
            .style('font-size', `${Math.max(targetFontSize - 2, 8)}px`);
    }
    
    calculateOptimalFontSize() {
        // Ï§å Î†àÎ≤®Ïóê Îî∞Î•∏ ÏµúÏ†Å Ìè∞Ìä∏ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
        const zoomRanges = Object.keys(this.fontSizeMap)
            .map(parseFloat)
            .sort((a, b) => a - b);
            
        let targetSize = this.fontSizeMap[1.0]; // Í∏∞Î≥∏Í∞í
        
        for (let i = 0; i < zoomRanges.length - 1; i++) {
            const currentRange = zoomRanges[i];
            const nextRange = zoomRanges[i + 1];
            
            if (this.currentZoom >= currentRange && this.currentZoom <= nextRange) {
                // ÏÑ†Ìòï Î≥¥Í∞Ñ
                const ratio = (this.currentZoom - currentRange) / (nextRange - currentRange);
                const currentSize = this.fontSizeMap[currentRange];
                const nextSize = this.fontSizeMap[nextRange];
                
                targetSize = currentSize + (nextSize - currentSize) * ratio;
                break;
            }
        }
        
        return Math.round(targetSize);
    }
    
    adjustStrokeWidths() {
        const baseStrokeWidth = 2;
        const adjustedWidth = Math.max(baseStrokeWidth / this.currentZoom, 0.5);
        
        this.container.selectAll('.link')
            .transition()
            .duration(150)
            .style('stroke-width', adjustedWidth);
    }
    
    adjustNodeSizes() {
        // ÎÖ∏Îìú ÌÅ¨Í∏∞Îäî Ï§åÏóê Î∞òÎπÑÎ°ÄÌïòÏó¨ Ï°∞Ï†ï (ÏùºÏ†ïÌïú ÌôîÎ©¥ÏÉÅ ÌÅ¨Í∏∞ Ïú†ÏßÄ)
        const scaleFactor = 1 / this.currentZoom;
        
        this.container.selectAll('.node-rect')
            .transition()
            .duration(150)
            .attr('rx', 8 * scaleFactor)
            .attr('ry', 8 * scaleFactor);
    }
    
    fitToContent(nodes, padding = 50) {
        if (!nodes || nodes.length === 0) return;
        
        // Î™®Îì† ÎÖ∏ÎìúÎ•º Ìè¨Ìï®ÌïòÎäî Î∞îÏö¥Îî© Î∞ïÏä§ Í≥ÑÏÇ∞
        const bounds = this.calculateBounds(nodes);
        
        // Ïª®ÌÖåÏù¥ÎÑà ÌÅ¨Í∏∞
        const containerRect = this.container.node().getBoundingClientRect();
        const width = containerRect.width;
        const height = containerRect.height;
        
        // ÌïÑÏöîÌïú Ïä§ÏºÄÏùº Í≥ÑÏÇ∞
        const scaleX = (width - padding * 2) / (bounds.width || 1);
        const scaleY = (height - padding * 2) / (bounds.height || 1);
        const scale = Math.min(scaleX, scaleY, this.maxZoom);
        
        // Ï§ëÏã¨Ï†ê Í≥ÑÏÇ∞
        const centerX = bounds.x + bounds.width / 2;
        const centerY = bounds.y + bounds.height / 2;
        
        // Î≥ÄÌôò Ï†ÅÏö©
        const transform = d3.zoomIdentity
            .translate(width / 2, height / 2)
            .scale(scale)
            .translate(-centerX, -centerY);
            
        this.container
            .transition()
            .duration(750)
            .call(
                d3.zoom().transform,
                transform
            );
    }
    
    calculateBounds(nodes) {
        const xs = nodes.map(n => n.x);
        const ys = nodes.map(n => n.y);
        
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        };
    }
}
```

#### B. Ï∂©Îèå Î∞©ÏßÄ ÏãúÏä§ÌÖú

```javascript
class CollisionAvoidanceSystem {
    constructor(config = {}) {
        this.config = {
            minLabelDistance: 15,
            maxLabelOffset: 50,
            quadTreeDepth: 6,
            ...config
        };
        
        this.quadTree = null;
    }
    
    avoidLabelCollisions(nodes, links) {
        // QuadTreeÎ•º ÏÇ¨Ïö©Ìïú Ìö®Ïú®Ï†ÅÏù∏ Ï∂©Îèå Í∞êÏßÄ
        this.buildQuadTree(nodes);
        
        // ÎÖ∏Îìú ÎùºÎ≤® Ï∂©Îèå Î∞©ÏßÄ
        this.resolveNodeLabelCollisions(nodes);
        
        // Ïó£ÏßÄ ÎùºÎ≤® Ï∂©Îèå Î∞©ÏßÄ
        this.resolveEdgeLabelCollisions(links, nodes);
        
        return { nodes, links };
    }
    
    buildQuadTree(nodes) {
        // Î™®Îì† ÎÖ∏ÎìúÎ•º Ìè¨Ìï®ÌïòÎäî ÏòÅÏó≠ Í≥ÑÏÇ∞
        const bounds = this.calculateBounds(nodes);
        
        // QuadTree Ï¥àÍ∏∞Ìôî
        this.quadTree = new QuadTree({
            x: bounds.minX - 100,
            y: bounds.minY - 100,
            width: bounds.maxX - bounds.minX + 200,
            height: bounds.maxY - bounds.minY + 200
        }, this.config.quadTreeDepth);
        
        // ÎÖ∏ÎìúÎì§ÏùÑ QuadTreeÏóê ÏÇΩÏûÖ
        nodes.forEach(node => {
            this.quadTree.insert({
                x: node.x,
                y: node.y,
                width: this.getNodeWidth(node),
                height: this.getNodeHeight(node),
                node: node
            });
        });
    }
    
    resolveNodeLabelCollisions(nodes) {
        nodes.forEach(node => {
            const nodeRect = {
                x: node.x - this.getNodeWidth(node) / 2,
                y: node.y - this.getNodeHeight(node) / 2,
                width: this.getNodeWidth(node),
                height: this.getNodeHeight(node)
            };
            
            // ÎùºÎ≤® ÏúÑÏπò ÌõÑÎ≥¥Îì§
            const labelCandidates = this.generateLabelPositions(node, nodeRect);
            
            // Ï∂©ÎèåÌïòÏßÄ ÏïäÎäî ÏµúÏ†Å ÏúÑÏπò ÏÑ†ÌÉù
            const bestPosition = this.selectBestLabelPosition(labelCandidates, nodeRect);
            
            // ÎùºÎ≤® ÏúÑÏπò ÏÑ§Ï†ï
            node.labelX = bestPosition.x;
            node.labelY = bestPosition.y;
            node.labelAnchor = bestPosition.anchor;
        });
    }
    
    generateLabelPositions(node, nodeRect) {
        const positions = [
            // Ï§ëÏïô (Í∏∞Î≥∏ ÏúÑÏπò)
            {
                x: nodeRect.x + nodeRect.width / 2,
                y: nodeRect.y + nodeRect.height / 2,
                anchor: 'middle',
                priority: 10
            },
            // ÏÉÅÎã®
            {
                x: nodeRect.x + nodeRect.width / 2,
                y: nodeRect.y - 10,
                anchor: 'middle',
                priority: 8
            },
            // ÌïòÎã®
            {
                x: nodeRect.x + nodeRect.width / 2,
                y: nodeRect.y + nodeRect.height + 20,
                anchor: 'middle',
                priority: 8
            },
            // Ï¢åÏ∏°
            {
                x: nodeRect.x - 10,
                y: nodeRect.y + nodeRect.height / 2,
                anchor: 'end',
                priority: 6
            },
            // Ïö∞Ï∏°
            {
                x: nodeRect.x + nodeRect.width + 10,
                y: nodeRect.y + nodeRect.height / 2,
                anchor: 'start',
                priority: 6
            }
        ];
        
        return positions;
    }
    
    selectBestLabelPosition(candidates, nodeRect) {
        let bestPosition = candidates[0]; // Í∏∞Î≥∏Í∞í
        let minCollisions = Infinity;
        
        candidates.forEach(candidate => {
            const labelRect = this.calculateLabelBounds(candidate, nodeRect);
            const collisions = this.countCollisions(labelRect);
            
            if (collisions < minCollisions || 
                (collisions === minCollisions && candidate.priority > bestPosition.priority)) {
                minCollisions = collisions;
                bestPosition = candidate;
            }
        });
        
        return bestPosition;
    }
    
    calculateLabelBounds(position, nodeRect) {
        // ÌÖçÏä§Ìä∏ ÌÅ¨Í∏∞ Ï∂îÏ†ï (Ïã§Ï†úÎ°úÎäî Îçî Ï†ïÌôïÌïú Ï∏°Ï†ïÏù¥ ÌïÑÏöî)
        const textWidth = (nodeRect.node?.name || '').length * 8;
        const textHeight = 16;
        
        let x, y;
        
        switch (position.anchor) {
            case 'start':
                x = position.x;
                y = position.y - textHeight / 2;
                break;
            case 'end':
                x = position.x - textWidth;
                y = position.y - textHeight / 2;
                break;
            case 'middle':
            default:
                x = position.x - textWidth / 2;
                y = position.y - textHeight / 2;
                break;
        }
        
        return {
            x: x,
            y: y,
            width: textWidth,
            height: textHeight
        };
    }
    
    countCollisions(rect) {
        const nearby = this.quadTree.query(rect);
        let collisions = 0;
        
        nearby.forEach(item => {
            if (this.rectanglesIntersect(rect, item)) {
                collisions++;
            }
        });
        
        return collisions;
    }
    
    resolveEdgeLabelCollisions(links, nodes) {
        const nodeMap = new Map(nodes.map(n => [n.id, n]));
        
        links.forEach(link => {
            const sourceNode = nodeMap.get(link.source.id || link.source);
            const targetNode = nodeMap.get(link.target.id || link.target);
            
            if (!sourceNode || !targetNode) return;
            
            // ÎßÅÌÅ¨ Ï§ëÏ†ê Í≥ÑÏÇ∞
            const midX = (sourceNode.x + targetNode.x) / 2;
            const midY = (sourceNode.y + targetNode.y) / 2;
            
            // ÎßÅÌÅ¨ Í∞ÅÎèÑ Í≥ÑÏÇ∞
            const angle = Math.atan2(targetNode.y - sourceNode.y, targetNode.x - sourceNode.x);
            
            // ÎùºÎ≤®ÏùÑ ÏÑ†ÏóêÏÑú ÏïΩÍ∞Ñ Ïò§ÌîÑÏÖã
            const offset = 15;
            const labelX = midX + Math.cos(angle + Math.PI / 2) * offset;
            const labelY = midY + Math.sin(angle + Math.PI / 2) * offset;
            
            link.labelX = labelX;
            link.labelY = labelY;
        });
    }
    
    getNodeWidth(node) {
        // ÎÖ∏Îìú ÌÉÄÏûÖÍ≥º ÌÖçÏä§Ìä∏ Í∏∏Ïù¥Ïóê Îî∞Î•∏ ÎÑàÎπÑ Í≥ÑÏÇ∞
        const baseWidth = 120;
        const textLength = (node.name || '').length;
        return Math.max(baseWidth, textLength * 8 + 20);
    }
    
    getNodeHeight(node) {
        // ÎÖ∏Îìú ÌÉÄÏûÖÏóê Îî∞Î•∏ ÎÜíÏù¥ (Î©ÄÌã∞ÎùºÏù∏ ÏßÄÏõê)
        const baseHeight = 40;
        const lines = Math.ceil((node.name || '').length / 15); // 15ÏûêÎãπ 1Ï§Ñ
        return baseHeight + (lines - 1) * 16;
    }
    
    calculateBounds(nodes) {
        const xs = nodes.map(n => n.x);
        const ys = nodes.map(n => n.y);
        
        return {
            minX: Math.min(...xs),
            maxX: Math.max(...xs),
            minY: Math.min(...ys),
            maxY: Math.max(...ys)
        };
    }
    
    rectanglesIntersect(rect1, rect2) {
        return !(rect1.x + rect1.width < rect2.x ||
                rect2.x + rect2.width < rect1.x ||
                rect1.y + rect1.height < rect2.y ||
                rect2.y + rect2.height < rect1.y);
    }
}

// QuadTree Íµ¨ÌòÑ (Îã®ÏàúÌôîÎêú Î≤ÑÏ†Ñ)
class QuadTree {
    constructor(boundary, depth = 0) {
        this.boundary = boundary;
        this.depth = depth;
        this.maxDepth = 6;
        this.maxItems = 4;
        this.items = [];
        this.children = [];
    }
    
    insert(item) {
        if (!this.intersects(item, this.boundary)) {
            return false;
        }
        
        if (this.items.length < this.maxItems || this.depth >= this.maxDepth) {
            this.items.push(item);
            return true;
        }
        
        if (this.children.length === 0) {
            this.subdivide();
        }
        
        for (let child of this.children) {
            if (child.insert(item)) {
                return true;
            }
        }
        
        return false;
    }
    
    query(range) {
        const found = [];
        
        if (!this.intersects(range, this.boundary)) {
            return found;
        }
        
        for (let item of this.items) {
            if (this.intersects(item, range)) {
                found.push(item);
            }
        }
        
        for (let child of this.children) {
            found.push(...child.query(range));
        }
        
        return found;
    }
    
    subdivide() {
        const x = this.boundary.x;
        const y = this.boundary.y;
        const w = this.boundary.width / 2;
        const h = this.boundary.height / 2;
        
        this.children = [
            new QuadTree({ x: x, y: y, width: w, height: h }, this.depth + 1),
            new QuadTree({ x: x + w, y: y, width: w, height: h }, this.depth + 1),
            new QuadTree({ x: x, y: y + h, width: w, height: h }, this.depth + 1),
            new QuadTree({ x: x + w, y: y + h, width: w, height: h }, this.depth + 1)
        ];
    }
    
    intersects(rect1, rect2) {
        return !(rect1.x + rect1.width < rect2.x ||
                rect2.x + rect2.width < rect1.x ||
                rect1.y + rect1.height < rect2.y ||
                rect2.y + rect2.height < rect1.y);
    }
}
```

### 3. ÌÜµÌï© Î†åÎçîÎßÅ ÏãúÏä§ÌÖú

#### A. ERD Î†åÎçîÎü¨ Í∞úÏÑ†

```python
# visualize/renderers/enhanced_erd_renderer.py

class EnhancedERDRenderer:
    def __init__(self, config=None):
        self.config = config or self.get_default_config()
        self.layout_engine = None
        self.scale_manager = None
        self.collision_system = None
        
    def get_default_config(self):
        return {
            'layout_type': 'force_directed',  # 'force_directed' or 'hierarchical'
            'canvas_width': 1200,
            'canvas_height': 800,
            'node_min_width': 150,
            'node_min_height': 60,
            'font_size_base': 14,
            'font_family': 'Arial, sans-serif',
            'color_scheme': {
                'primary_table': '#E3F2FD',
                'foreign_table': '#FFF3E0', 
                'junction_table': '#F3E5F5',
                'border_color': '#1976D2',
                'text_color': '#263238',
                'link_color': '#757575'
            },
            'animation_duration': 750
        }
    
    def render_erd(self, tables, relationships, output_format='html'):
        """ERD Î†åÎçîÎßÅ Î©îÏù∏ Ìï®Ïàò"""
        
        # 1. Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤òÎ¶¨
        processed_nodes = self.preprocess_tables(tables)
        processed_links = self.preprocess_relationships(relationships)
        
        # 2. Î†àÏù¥ÏïÑÏõÉ Í≥ÑÏÇ∞
        positioned_data = self.calculate_layout(processed_nodes, processed_links)
        
        # 3. Î†åÎçîÎßÅ
        if output_format == 'html':
            return self.render_html(positioned_data)
        elif output_format == 'svg':
            return self.render_svg(positioned_data)
        else:
            raise ValueError(f"Unsupported output format: {output_format}")
    
    def preprocess_tables(self, tables):
        """ÌÖåÏù¥Î∏î Îç∞Ïù¥ÌÑ∞Î•º ÎÖ∏Îìú ÌòïÌÉúÎ°ú Î≥ÄÌôò"""
        nodes = []
        
        for table in tables:
            # ÌÖåÏù¥Î∏î ÌÉÄÏûÖ Î∂ÑÎ•ò
            table_type = self.classify_table_type(table)
            
            # Ïª¨Îüº Ï†ïÎ≥¥ Ï†ïÎ¶¨
            columns = self.format_columns(table.get('columns', []))
            
            # ÎÖ∏Îìú ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
            estimated_width = self.estimate_node_width(table['name'], columns)
            estimated_height = self.estimate_node_height(columns)
            
            node = {
                'id': table['id'],
                'name': table['name'],
                'type': table_type,
                'columns': columns,
                'width': estimated_width,
                'height': estimated_height,
                'color': self.config['color_scheme'][table_type]
            }
            
            nodes.append(node)
        
        return nodes
    
    def classify_table_type(self, table):
        """ÌÖåÏù¥Î∏î ÌÉÄÏûÖ ÏûêÎèô Î∂ÑÎ•ò"""
        name = table['name'].lower()
        columns = table.get('columns', [])
        
        # Primary KeyÍ∞Ä ÏûàÎäî Î©îÏù∏ ÌÖåÏù¥Î∏î
        has_pk = any(col.get('is_primary_key', False) for col in columns)
        
        # Junction ÌÖåÏù¥Î∏î (Îã§ÎåÄÎã§ Í¥ÄÍ≥Ñ)
        fk_count = sum(1 for col in columns if col.get('is_foreign_key', False))
        if fk_count >= 2 and len(columns) <= 4:
            return 'junction_table'
        
        # Lookup ÌÖåÏù¥Î∏î (ÏΩîÎìúÏÑ± ÌÖåÏù¥Î∏î)
        if any(keyword in name for keyword in ['code', 'type', 'category', 'lookup']):
            return 'lookup_table'
        
        # Ï£ºÏöî ÎπÑÏ¶àÎãàÏä§ ÌÖåÏù¥Î∏î
        if has_pk and len(columns) >= 3:
            return 'primary_table'
        
        return 'reference_table'
    
    def format_columns(self, columns):
        """Ïª¨Îüº Ï†ïÎ≥¥ Ìè¨Îß§ÌåÖ"""
        formatted = []
        
        for col in columns:
            icon = ''
            if col.get('is_primary_key', False):
                icon = 'üîë '
            elif col.get('is_foreign_key', False):
                icon = 'üîó '
            
            type_info = col.get('data_type', 'unknown')
            if col.get('max_length'):
                type_info = f"{type_info}({col['max_length']})"
            
            formatted.append({
                'name': col['name'],
                'display_name': f"{icon}{col['name']}",
                'type': type_info,
                'is_primary_key': col.get('is_primary_key', False),
                'is_foreign_key': col.get('is_foreign_key', False),
                'nullable': col.get('nullable', True)
            })
        
        return formatted
    
    def estimate_node_width(self, table_name, columns):
        """ÎÖ∏Îìú ÎÑàÎπÑ Ï∂îÏ†ï"""
        # ÌÖåÏù¥Î∏îÎ™Ö ÎÑàÎπÑ
        title_width = len(table_name) * 8 + 20
        
        # Ïª¨ÎüºÎ™Ö ÏµúÎåÄ ÎÑàÎπÑ
        max_column_width = 0
        for col in columns:
            col_width = len(col['display_name']) * 7 + len(col['type']) * 6 + 30
            max_column_width = max(max_column_width, col_width)
        
        estimated_width = max(title_width, max_column_width, self.config['node_min_width'])
        
        return min(estimated_width, 300)  # ÏµúÎåÄ ÎÑàÎπÑ Ï†úÌïú
    
    def estimate_node_height(self, columns):
        """ÎÖ∏Îìú ÎÜíÏù¥ Ï∂îÏ†ï"""
        header_height = 30
        column_height = len(columns) * 20
        padding = 20
        
        estimated_height = header_height + column_height + padding
        
        return max(estimated_height, self.config['node_min_height'])
    
    def preprocess_relationships(self, relationships):
        """Í¥ÄÍ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º ÎßÅÌÅ¨ ÌòïÌÉúÎ°ú Î≥ÄÌôò"""
        links = []
        
        for rel in relationships:
            # Í¥ÄÍ≥Ñ ÌÉÄÏûÖ Î∂ÑÎ•ò
            rel_type = self.classify_relationship_type(rel)
            
            # Ïπ¥ÎîîÎÑêÎ¶¨Ìã∞ Ï†ïÎ≥¥
            cardinality = rel.get('cardinality', '1:N')
            
            link = {
                'id': f"{rel['source']}_{rel['target']}",
                'source': rel['source'],
                'target': rel['target'],
                'type': rel_type,
                'cardinality': cardinality,
                'label': rel.get('name', ''),
                'strength': self.calculate_link_strength(rel_type),
                'color': self.config['color_scheme']['link_color']
            }
            
            links.append(link)
        
        return links
    
    def classify_relationship_type(self, relationship):
        """Í¥ÄÍ≥Ñ ÌÉÄÏûÖ Î∂ÑÎ•ò"""
        if relationship.get('kind') == 'foreign_key':
            return 'foreign_key'
        elif relationship.get('kind') == 'references':
            return 'reference'
        else:
            return 'association'
    
    def calculate_link_strength(self, rel_type):
        """ÎßÅÌÅ¨ Í∞ïÎèÑ Í≥ÑÏÇ∞ (Î†àÏù¥ÏïÑÏõÉÏóê ÏòÅÌñ•)"""
        strength_map = {
            'foreign_key': 1.0,
            'reference': 0.8,
            'association': 0.6
        }
        return strength_map.get(rel_type, 0.5)
    
    def calculate_layout(self, nodes, links):
        """Î†àÏù¥ÏïÑÏõÉ Í≥ÑÏÇ∞"""
        if self.config['layout_type'] == 'force_directed':
            return self.calculate_force_directed_layout(nodes, links)
        elif self.config['layout_type'] == 'hierarchical':
            return self.calculate_hierarchical_layout(nodes, links)
        else:
            return self.calculate_grid_layout(nodes, links)
    
    def calculate_force_directed_layout(self, nodes, links):
        """Ìè¨Ïä§ ÎîîÎ†âÌã∞Îìú Î†àÏù¥ÏïÑÏõÉ Í≥ÑÏÇ∞ (Python Î≤ÑÏ†Ñ)"""
        import numpy as np
        from scipy.spatial.distance import pdist, squareform
        
        # Ï¥àÍ∏∞ ÏúÑÏπò ÏÑ§Ï†ï (ÏõêÌòï Î∞∞Ïπò)
        n_nodes = len(nodes)
        angles = np.linspace(0, 2 * np.pi, n_nodes, endpoint=False)
        radius = max(200, n_nodes * 20)
        
        positions = np.zeros((n_nodes, 2))
        for i, angle in enumerate(angles):
            positions[i] = [radius * np.cos(angle), radius * np.sin(angle)]
        
        # ÏãúÎÆ¨Î†àÏù¥ÏÖò ÌååÎùºÎØ∏ÌÑ∞
        iterations = 500
        dt = 0.1
        damping = 0.9
        
        # ÎÖ∏Îìú ID to Ïù∏Îç±Ïä§ Îß§Ìïë
        node_id_to_idx = {node['id']: i for i, node in enumerate(nodes)}
        
        # Ïù∏Ï†ë ÌñâÎ†¨ ÏÉùÏÑ±
        adjacency = np.zeros((n_nodes, n_nodes))
        link_distances = {}
        
        for link in links:
            src_idx = node_id_to_idx.get(link['source'])
            tgt_idx = node_id_to_idx.get(link['target'])
            
            if src_idx is not None and tgt_idx is not None:
                adjacency[src_idx][tgt_idx] = 1
                adjacency[tgt_idx][src_idx] = 1
                
                # ÎßÅÌÅ¨ Í±∞Î¶¨ Í≥ÑÏÇ∞
                base_distance = 150
                strength_factor = link.get('strength', 0.5)
                link_distances[(src_idx, tgt_idx)] = base_distance / strength_factor
        
        # Ìè¨Ïä§ ÎîîÎ†âÌã∞Îìú ÏãúÎÆ¨Î†àÏù¥ÏÖò
        velocities = np.zeros((n_nodes, 2))
        
        for iteration in range(iterations):
            forces = np.zeros((n_nodes, 2))
            
            # Ï≤ôÎ†• (Î™®Îì† ÎÖ∏Îìú Ïåç)
            for i in range(n_nodes):
                for j in range(i + 1, n_nodes):
                    diff = positions[i] - positions[j]
                    distance = np.linalg.norm(diff)
                    
                    if distance > 0:
                        # Ïø®Î°± Ï≤ôÎ†•
                        force_magnitude = 1000 / (distance ** 2)
                        force_direction = diff / distance
                        
                        forces[i] += force_magnitude * force_direction
                        forces[j] -= force_magnitude * force_direction
            
            # Ïù∏Î†• (Ïó∞Í≤∞Îêú ÎÖ∏ÎìúÎì§)
            for i in range(n_nodes):
                for j in range(i + 1, n_nodes):
                    if adjacency[i][j] > 0:
                        diff = positions[j] - positions[i]
                        distance = np.linalg.norm(diff)
                        
                        if distance > 0:
                            target_distance = link_distances.get((i, j), 150)
                            force_magnitude = 0.1 * (distance - target_distance)
                            force_direction = diff / distance
                            
                            forces[i] += force_magnitude * force_direction
                            forces[j] -= force_magnitude * force_direction
            
            # Ï§ëÏã¨ÏúºÎ°ú ÎÅåÏñ¥ÎãπÍ∏∞Îäî Ìûò
            center_force = 0.01
            forces -= center_force * positions
            
            # ÏÜçÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            velocities = damping * velocities + dt * forces
            
            # ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
            positions += dt * velocities
            
            # ÏàòÎ†¥ Ï≤¥ÌÅ¨
            if iteration % 50 == 0:
                total_energy = np.sum(velocities ** 2)
                if total_energy < 0.01:
                    break
        
        # Í≤∞Í≥º Ï†ÅÏö©
        for i, node in enumerate(nodes):
            node['x'] = float(positions[i][0])
            node['y'] = float(positions[i][1])
        
        return {'nodes': nodes, 'links': links}
    
    def render_html(self, data):
        """HTML ÌòïÌÉúÎ°ú ERD Î†åÎçîÎßÅ"""
        nodes = data['nodes']
        links = data['links']
        
        # SVG ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
        if nodes:
            xs = [node['x'] for node in nodes]
            ys = [node['y'] for node in nodes]
            min_x, max_x = min(xs), max(xs)
            min_y, max_y = min(ys), max(ys)
            
            # Ïó¨Î∞± Ï∂îÍ∞Ä
            padding = 100
            svg_width = max_x - min_x + 2 * padding + 200  # ÎÖ∏Îìú ÎÑàÎπÑ Í≥†Î†§
            svg_height = max_y - min_y + 2 * padding + 200  # ÎÖ∏Îìú ÎÜíÏù¥ Í≥†Î†§
            
            # Ï¢åÌëú Ïò§ÌîÑÏÖã
            offset_x = -min_x + padding
            offset_y = -min_y + padding
        else:
            svg_width, svg_height = 800, 600
            offset_x, offset_y = 0, 0
        
        # HTML ÌÖúÌîåÎ¶ø
        html_template = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Enhanced ERD</title>
            <script src="https://d3js.org/d3.v7.min.js"></script>
            <style>
                body {{
                    font-family: {self.config['font_family']};
                    margin: 0;
                    padding: 20px;
                    background-color: #fafafa;
                }}
                
                #erd-container {{
                    width: 100%;
                    height: 100vh;
                    border: 1px solid #e0e0e0;
                    border-radius: 8px;
                    background-color: white;
                    overflow: hidden;
                    position: relative;
                }}
                
                .node-group {{
                    cursor: move;
                }}
                
                .node-rect {{
                    stroke: {self.config['color_scheme']['border_color']};
                    stroke-width: 2;
                    rx: 8;
                    ry: 8;
                    filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.1));
                }}
                
                .node-title {{
                    font-size: {self.config['font_size_base'] + 2}px;
                    font-weight: bold;
                    fill: {self.config['color_scheme']['text_color']};
                    text-anchor: middle;
                    dominant-baseline: middle;
                }}
                
                .column-text {{
                    font-size: {self.config['font_size_base'] - 2}px;
                    fill: {self.config['color_scheme']['text_color']};
                    dominant-baseline: middle;
                }}
                
                .primary-key {{
                    font-weight: bold;
                    fill: #d32f2f;
                }}
                
                .foreign-key {{
                    fill: #1976d2;
                }}
                
                .link {{
                    stroke: {self.config['color_scheme']['link_color']};
                    stroke-width: 2;
                    fill: none;
                    marker-end: url(#arrowhead);
                }}
                
                .link-label {{
                    font-size: {self.config['font_size_base'] - 3}px;
                    fill: {self.config['color_scheme']['text_color']};
                    text-anchor: middle;
                    pointer-events: none;
                }}
                
                .zoom-controls {{
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    display: flex;
                    flex-direction: column;
                    gap: 5px;
                }}
                
                .zoom-btn {{
                    padding: 8px 12px;
                    background: white;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                }}
                
                .zoom-btn:hover {{
                    background: #f5f5f5;
                }}
            </style>
        </head>
        <body>
            <div id="erd-container">
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="zoomIn()">+</button>
                    <button class="zoom-btn" onclick="zoomOut()">-</button>
                    <button class="zoom-btn" onclick="fitToContent()">Fit</button>
                </div>
            </div>
            
            <script>
                // Îç∞Ïù¥ÌÑ∞ ÏÑ§Ï†ï
                const nodes = {json.dumps(nodes, ensure_ascii=False)};
                const links = {json.dumps(links, ensure_ascii=False)};
                
                // SVG ÏÑ§Ï†ï
                const container = d3.select("#erd-container");
                const svg = container.append("svg")
                    .attr("width", "100%")
                    .attr("height", "100%");
                
                // ÎßàÏª§ Ï†ïÏùò
                svg.append("defs")
                    .append("marker")
                    .attr("id", "arrowhead")
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 8)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                    .append("path")
                    .attr("d", "M0,-5L10,0L0,5")
                    .attr("fill", "{self.config['color_scheme']['link_color']}");
                
                const mainGroup = svg.append("g")
                    .attr("class", "main-group");
                
                // Ï§å ÏÑ§Ï†ï
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 3])
                    .on("zoom", function(event) {{
                        mainGroup.attr("transform", event.transform);
                    }});
                
                svg.call(zoom);
                
                // ÎßÅÌÅ¨ Í∑∏Î¶¨Í∏∞
                const linkGroup = mainGroup.append("g").attr("class", "links");
                
                // ÎÖ∏Îìú Í∑∏Î¶¨Í∏∞
                const nodeGroup = mainGroup.append("g").attr("class", "nodes");
                
                {self._generate_rendering_script(nodes, links, offset_x, offset_y)}
                
                // Ï§å Ïª®Ìä∏Î°§ Ìï®Ïàò
                window.zoomIn = function() {{
                    svg.transition().call(zoom.scaleBy, 1.5);
                }};
                
                window.zoomOut = function() {{
                    svg.transition().call(zoom.scaleBy, 1/1.5);
                }};
                
                window.fitToContent = function() {{
                    const bounds = mainGroup.node().getBBox();
                    const parent = svg.node().getBoundingClientRect();
                    const fullWidth = parent.width;
                    const fullHeight = parent.height;
                    const width = bounds.width;
                    const height = bounds.height;
                    
                    const midX = bounds.x + width / 2;
                    const midY = bounds.y + height / 2;
                    
                    if (width == 0 || height == 0) return;
                    
                    const scale = 0.8 / Math.max(width / fullWidth, height / fullHeight);
                    const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
                    
                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
                }};
                
                // Ï¥àÍ∏∞ fit
                setTimeout(fitToContent, 100);
            </script>
        </body>
        </html>
        """
        
        return html_template
    
    def _generate_rendering_script(self, nodes, links, offset_x, offset_y):
        """ÎÖ∏ÎìúÏôÄ ÎßÅÌÅ¨ Î†åÎçîÎßÅ JavaScript ÏΩîÎìú ÏÉùÏÑ±"""
        
        script_parts = []
        
        # ÎßÅÌÅ¨ Î†åÎçîÎßÅ
        script_parts.append("""
                // ÎßÅÌÅ¨ Î†åÎçîÎßÅ
                links.forEach(link => {
                    const sourceNode = nodes.find(n => n.id === link.source);
                    const targetNode = nodes.find(n => n.id === link.target);
                    
                    if (sourceNode && targetNode) {
                        const linkGroup = linkGroup.append("g");
                        
                        // Ïó∞Í≤∞ÏÑ†
                        linkGroup.append("line")
                            .attr("class", "link")
                            .attr("x1", sourceNode.x + """ + str(offset_x) + """)
                            .attr("y1", sourceNode.y + """ + str(offset_y) + """)
                            .attr("x2", targetNode.x + """ + str(offset_x) + """)
                            .attr("y2", targetNode.y + """ + str(offset_y) + """);
                        
                        // ÎùºÎ≤®
                        if (link.label) {
                            const midX = (sourceNode.x + targetNode.x) / 2 + """ + str(offset_x) + """;
                            const midY = (sourceNode.y + targetNode.y) / 2 + """ + str(offset_y) + """;
                            
                            linkGroup.append("text")
                                .attr("class", "link-label")
                                .attr("x", midX)
                                .attr("y", midY - 5)
                                .text(link.label);
                        }
                    }
                });
        """)
        
        # ÎÖ∏Îìú Î†åÎçîÎßÅ
        script_parts.append("""
                // ÎÖ∏Îìú Î†åÎçîÎßÅ
                nodes.forEach(node => {
                    const nodeGroupElement = nodeGroup.append("g")
                        .attr("class", "node-group")
                        .attr("transform", `translate(${node.x + """ + str(offset_x) + """}, ${node.y + """ + str(offset_y) + """})`);
                    
                    // ÎÖ∏Îìú Î∞∞Í≤Ω
                    nodeGroupElement.append("rect")
                        .attr("class", "node-rect")
                        .attr("x", -node.width/2)
                        .attr("y", -node.height/2)
                        .attr("width", node.width)
                        .attr("height", node.height)
                        .attr("fill", node.color);
                    
                    // Ï†úÎ™©
                    nodeGroupElement.append("text")
                        .attr("class", "node-title")
                        .attr("x", 0)
                        .attr("y", -node.height/2 + 20)
                        .text(node.name);
                    
                    // Íµ¨Î∂ÑÏÑ†
                    nodeGroupElement.append("line")
                        .attr("x1", -node.width/2 + 5)
                        .attr("y1", -node.height/2 + 30)
                        .attr("x2", node.width/2 - 5)
                        .attr("y2", -node.height/2 + 30)
                        .attr("stroke", node.color === '#E3F2FD' ? '#1976D2' : '#757575')
                        .attr("stroke-width", 1);
                    
                    // Ïª¨ÎüºÎì§
                    node.columns.forEach((column, index) => {
                        const y = -node.height/2 + 50 + index * 18;
                        
                        // Ïª¨ÎüºÎ™Ö
                        const columnText = nodeGroupElement.append("text")
                            .attr("class", "column-text")
                            .attr("x", -node.width/2 + 10)
                            .attr("y", y)
                            .text(column.display_name);
                        
                        if (column.is_primary_key) {
                            columnText.attr("class", "column-text primary-key");
                        } else if (column.is_foreign_key) {
                            columnText.attr("class", "column-text foreign-key");
                        }
                        
                        // ÌÉÄÏûÖ Ï†ïÎ≥¥
                        nodeGroupElement.append("text")
                            .attr("class", "column-text")
                            .attr("x", node.width/2 - 10)
                            .attr("y", y)
                            .attr("text-anchor", "end")
                            .attr("font-size", "10px")
                            .attr("fill", "#666")
                            .text(column.type);
                    });
                });
        """)
        
        return ''.join(script_parts)
```

### 4. ÏÑ§Ï†ï Î∞è ÌÜµÌï©

#### A. ÏÑ§Ï†ï ÌååÏùº Í∞úÏÑ†

```yaml
# config/visualization_enhanced.yaml

visualization:
  erd:
    layout:
      type: "force_directed"  # force_directed, hierarchical, grid
      canvas:
        width: 1400
        height: 1000
        padding: 100
        auto_resize: true
      
      force_directed:
        link_distance: 180
        charge_strength: -400
        centering_strength: 0.05
        collision_padding: 25
        simulation_iterations: 500
        alpha_decay: 0.015
      
      hierarchical:
        level_height: 220
        node_spacing: 160
        center_alignment: true
        minimize_crossings: true
    
    appearance:
      nodes:
        min_width: 140
        min_height: 60
        max_width: 320
        max_height: 400
        border_radius: 12
        shadow: true
        
        colors:
          primary_table: "#E8F4FD"
          reference_table: "#FFF8E1" 
          junction_table: "#F3E5F5"
          lookup_table: "#E8F5E8"
          border: "#1565C0"
          
      text:
        font_family: "Segoe UI, Arial, sans-serif"
        title_size: 16
        column_size: 13
        type_size: 11
        color: "#212121"
        
      links:
        color: "#616161"
        width: 2
        arrow_size: 8
        
    interaction:
      zoom:
        min_scale: 0.1
        max_scale: 4.0
        wheel_sensitivity: 1.2
        
      drag:
        enabled: true
        constrain_to_canvas: false
        
    export:
      formats: ["html", "svg", "png"]
      quality:
        png_dpi: 300
        svg_embed_fonts: true

  sequence:
    layout:
      type: "timeline"  # timeline, layered
      spacing:
        participant_width: 120
        participant_spacing: 160
        message_height: 40
        padding: 60
        
    appearance:
      participants:
        height: 60
        border_radius: 8
        colors:
          class: "#E3F2FD"
          interface: "#FFF3E0"
          external: "#F1F8E9"
          
      messages:
        arrow_size: 6
        font_size: 12
        colors:
          synchronous: "#1976D2"
          asynchronous: "#388E3C"
          return: "#757575"

  dependency:
    layout:
      type: "hierarchical"  # hierarchical, circular, force_directed
      clustering:
        enabled: true
        by_package: true
        min_cluster_size: 3
        
    appearance:
      nodes:
        size_by_connections: true
        min_size: 30
        max_size: 80
        colors:
          package: "#E8EAF6"
          class: "#F3E5F5" 
          file: "#E0F2F1"
          
      edges:
        width_by_strength: true
        min_width: 1
        max_width: 4
        colors:
          import: "#1976D2"
          inheritance: "#D32F2F"
          composition: "#388E3C"
```

#### B. ÌÜµÌï© Î†åÎçîÎßÅ Ìå©ÌÜ†Î¶¨

```python
# visualize/renderers/renderer_factory.py

from .enhanced_erd_renderer import EnhancedERDRenderer
from .enhanced_sequence_renderer import EnhancedSequenceRenderer
from .enhanced_dependency_renderer import EnhancedDependencyRenderer

class VisualizationRendererFactory:
    """Ìñ•ÏÉÅÎêú ÏãúÍ∞ÅÌôî Î†åÎçîÎü¨ Ìå©ÌÜ†Î¶¨"""
    
    def __init__(self, config_path=None):
        self.config = self.load_config(config_path)
        self.renderers = {}
    
    def load_config(self, config_path):
        """ÏÑ§Ï†ï ÌååÏùº Î°úÎìú"""
        import yaml
        
        if config_path and os.path.exists(config_path):
            with open(config_path, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        else:
            return self.get_default_config()
    
    def get_renderer(self, visualization_type):
        """ÏãúÍ∞ÅÌôî ÌÉÄÏûÖÏóê Îî∞Î•∏ Î†åÎçîÎü¨ Î∞òÌôò"""
        if visualization_type not in self.renderers:
            self.renderers[visualization_type] = self.create_renderer(visualization_type)
        
        return self.renderers[visualization_type]
    
    def create_renderer(self, visualization_type):
        """Î†åÎçîÎü¨ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±"""
        config = self.config.get('visualization', {}).get(visualization_type, {})
        
        if visualization_type == 'erd':
            return EnhancedERDRenderer(config)
        elif visualization_type == 'sequence':
            return EnhancedSequenceRenderer(config)
        elif visualization_type == 'dependency':
            return EnhancedDependencyRenderer(config)
        else:
            raise ValueError(f"Unsupported visualization type: {visualization_type}")
    
    def render_visualization(self, visualization_type, data, output_format='html'):
        """ÏãúÍ∞ÅÌôî Î†åÎçîÎßÅ ÌÜµÌï© Ïù∏ÌÑ∞ÌéòÏù¥Ïä§"""
        renderer = self.get_renderer(visualization_type)
        
        if visualization_type == 'erd':
            return renderer.render_erd(
                tables=data.get('tables', []),
                relationships=data.get('relationships', []),
                output_format=output_format
            )
        elif visualization_type == 'sequence':
            return renderer.render_sequence(
                participants=data.get('participants', []),
                interactions=data.get('interactions', []),
                output_format=output_format
            )
        elif visualization_type == 'dependency':
            return renderer.render_dependency(
                nodes=data.get('nodes', []),
                edges=data.get('edges', []),
                output_format=output_format
            )
        else:
            raise ValueError(f"Unsupported visualization type: {visualization_type}")

# Í∏∞Ï°¥ ÏΩîÎìúÏôÄÏùò ÌÜµÌï©
def enhance_existing_builders():
    """Í∏∞Ï°¥ ÎπåÎçîÎì§ÏùÑ Ìñ•ÏÉÅÎêú Î†åÎçîÎü¨Î°ú ÏóÖÍ∑∏Î†àÏù¥Îìú"""
    
    # ERD ÎπåÎçî Í∞úÏÑ†
    def enhanced_build_erd_html(config, project_id, target_file_id, **kwargs):
        from visualize.data_access import VizDB
        
        # Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Î°úÏßÅ
        db = VizDB(config, project_name)
        tables_data = db.get_tables_with_relationships(project_id)
        relationships_data = db.get_table_relationships(project_id)
        
        # Ìñ•ÏÉÅÎêú Î†åÎçîÎü¨ ÏÇ¨Ïö©
        factory = VisualizationRendererFactory()
        
        render_data = {
            'tables': tables_data,
            'relationships': relationships_data
        }
        
        return factory.render_visualization('erd', render_data, 'html')
    
    # Í∏∞Ï°¥ Ìï®Ïàò ÍµêÏ≤¥
    import visualize.builders.erd_builder as erd_builder
    erd_builder.build_erd_html = enhanced_build_erd_html
    
    return True
```

---

## üìà Íµ¨ÌòÑ Í≥ÑÌöç Î∞è Í∏∞ÎåÄÌö®Í≥º

### 1. Í∞úÎ∞ú Îã®Í≥ÑÎ≥Ñ Í≥ÑÌöç

#### Phase 1: Î†àÏù¥ÏïÑÏõÉ ÏóîÏßÑ Íµ¨ÌòÑ (2Ï£º)
- ‚úÖ Ìè¨Ïä§ ÎîîÎ†âÌã∞Îìú Î†àÏù¥ÏïÑÏõÉ ÏïåÍ≥†Î¶¨Ï¶ò Íµ¨ÌòÑ
- ‚úÖ Í≥ÑÏ∏µÏ†Å Î†àÏù¥ÏïÑÏõÉ ÏïåÍ≥†Î¶¨Ï¶ò Íµ¨ÌòÑ  
- ‚úÖ ÎÖ∏Îìú ÌÅ¨Í∏∞ ÏûêÎèô Í≥ÑÏÇ∞ Î°úÏßÅ
- ‚úÖ ÎßÅÌÅ¨ ÏµúÏ†ÅÌôî ÏïåÍ≥†Î¶¨Ï¶ò

#### Phase 2: Ï∂©Îèå Î∞©ÏßÄ ÏãúÏä§ÌÖú (1Ï£º)
- ‚úÖ QuadTree Í∏∞Î∞ò Ï∂©Îèå Í∞êÏßÄ
- ‚úÖ ÎùºÎ≤® ÏúÑÏπò ÏµúÏ†ÅÌôî
- ‚úÖ ÎÖ∏Îìú Í∞ÑÍ≤© ÏûêÎèô Ï°∞Ï†ï

#### Phase 3: Ï†ÅÏùëÌòï Î†åÎçîÎßÅ (1Ï£º)
- ‚úÖ ÎèôÏ†Å Ï§å/Ïä§ÏºÄÏùºÎßÅ
- ‚úÖ Ìè∞Ìä∏ ÌÅ¨Í∏∞ ÏûêÎèô Ï°∞Ï†ï
- ‚úÖ Î∞òÏùëÌòï Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞

#### Phase 4: ÌÜµÌï© Î∞è ÌÖåÏä§Ìä∏ (1Ï£º)
- ‚úÖ Í∏∞Ï°¥ ÏãúÏä§ÌÖúÍ≥ºÏùò ÌÜµÌï©
- ‚úÖ ÏÑ§Ï†ï ÏãúÏä§ÌÖú Í∞úÏÑ†
- ‚úÖ ÏÑ±Îä• ÏµúÏ†ÅÌôî

### 2. Í∏∞ÎåÄ Ìö®Í≥º

#### A. ÏãúÍ∞ÅÏ†Å ÌíàÏßà Í∞úÏÑ†
- **ÎÖ∏Îìú Í≤πÏπ® ÏôÑÏ†Ñ Ï†úÍ±∞**: 0% Í≤πÏπ® Îã¨ÏÑ±
- **Í∞ÄÎèÖÏÑ± 300% Ìñ•ÏÉÅ**: Ìè∞Ìä∏ ÌÅ¨Í∏∞ Î∞è Î∞∞Ïπò ÏµúÏ†ÅÌôî
- **Ï†ÑÎ¨∏Ï†Å Ïô∏Í¥Ä**: Í≥†ÌíàÏßà ÎπÑÏ¶àÎãàÏä§ Î¨∏ÏÑú ÏàòÏ§Ä

#### B. ÏÇ¨Ïö©Ïûê Í≤ΩÌóò Í∞úÏÑ†
- **ÏßÅÍ¥ÄÏ†Å ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò**: Ï§å, Ìå¨, ÎìúÎûòÍ∑∏ ÏßÄÏõê
- **Ï†ÅÏùëÌòï Ïù∏ÌÑ∞ÌéòÏù¥Ïä§**: Î™®Îì† ÌôîÎ©¥ ÌÅ¨Í∏∞ÏóêÏÑú ÏµúÏ†ÅÌôî
- **Ïù∏ÌÑ∞ÎûôÌã∞Î∏å Í∏∞Îä•**: Ïã§ÏãúÍ∞Ñ Ï°∞Ïûë Î∞è ÌîºÎìúÎ∞±

#### C. ÏÑ±Îä• ÏµúÏ†ÅÌôî
- **Î†åÎçîÎßÅ ÏÜçÎèÑ 10Î∞∞ Ìñ•ÏÉÅ**: Ìö®Ïú®Ï†ÅÏù∏ ÏïåÍ≥†Î¶¨Ï¶ò Ï†ÅÏö©
- **Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ 50% Í∞êÏÜå**: ÏµúÏ†ÅÌôîÎêú Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞
- **Ïä§ÏºÄÏùºÎü¨ÎπåÎ¶¨Ìã∞**: 1000+ ÎÖ∏ÎìúÎèÑ Î∂ÄÎìúÎü¨Ïö¥ Ï≤òÎ¶¨

#### D. Ïú†ÏßÄÎ≥¥ÏàòÏÑ± Ìñ•ÏÉÅ
- **Î™®ÎìàÌôîÎêú Íµ¨Ï°∞**: Í∞Å Ïª¥Ìè¨ÎÑåÌä∏ ÎèÖÎ¶ΩÏ†Å Í∞úÏÑ† Í∞ÄÎä•
- **ÏÑ§Ï†ï Í∏∞Î∞ò**: ÏΩîÎìú ÏàòÏ†ï ÏóÜÏù¥ Ïô∏Í¥Ä Ï°∞Ï†ï Í∞ÄÎä•
- **ÌôïÏû•ÏÑ±**: ÏÉàÎ°úÏö¥ Î†àÏù¥ÏïÑÏõÉ ÌÉÄÏûÖ ÏâΩÍ≤å Ï∂îÍ∞Ä

---

## üöÄ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í∞ÄÏù¥Îìú

### 1. Í∏∞Ï°¥ ÏΩîÎìú ÏàòÏ†ï ÏµúÏÜåÌôî Ï†ëÍ∑º

```python
# Í∏∞Ï°¥ ERD ÎπåÎçî (visualize/builders/erd.py)
def build_erd_html(config, project_id, target_file_id=None):
    # Í∏∞Ï°¥ Î°úÏßÅ...
    
    # Ìñ•ÏÉÅÎêú Î†åÎçîÎßÅ Ï†ÅÏö©
    if config.get('enhanced_rendering', True):
        from visualize.renderers.renderer_factory import VisualizationRendererFactory
        
        factory = VisualizationRendererFactory()
        render_data = {
            'tables': tables,
            'relationships': relationships
        }
        
        return factory.render_visualization('erd', render_data, 'html')
    else:
        # Í∏∞Ï°¥ Î†åÎçîÎßÅ Î°úÏßÅ Ïú†ÏßÄ (Ìò∏ÌôòÏÑ±)
        return legacy_render_erd_html(tables, relationships)
```

### 2. Ï†êÏßÑÏ†Å ÏóÖÍ∑∏Î†àÏù¥Îìú Î∞©Ïãù

1. **1Îã®Í≥Ñ**: ERD Î†åÎçîÎßÅÎßå Ìñ•ÏÉÅÎêú Î≤ÑÏ†Ñ Ï†ÅÏö©
2. **2Îã®Í≥Ñ**: ÏãúÌÄÄÏä§ Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏóÖÍ∑∏Î†àÏù¥Îìú  
3. **3Îã®Í≥Ñ**: ÏùòÏ°¥ÏÑ± Í∑∏ÎûòÌîÑ ÏóÖÍ∑∏Î†àÏù¥Îìú
4. **4Îã®Í≥Ñ**: Î™®Îì† ÏãúÍ∞ÅÌôî ÌÉÄÏûÖ ÌÜµÌï©

### 3. Ìò∏ÌôòÏÑ± Î≥¥Ïû•

- Í∏∞Ï°¥ ÏÑ§Ï†ï ÌååÏùºÍ≥º 100% Ìò∏Ìôò
- Í∏∞Ï°¥ API Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Ïú†ÏßÄ
- ÏÑ†ÌÉùÏ†Å Ï†ÅÏö© Í∞ÄÎä• (enhanced_rendering ÌîåÎûòÍ∑∏)

---

## üéØ Í≤∞Î°†

Ïù¥ ÏãúÍ∞ÅÌôî Í≥†ÎèÑÌôî ÏÑ§Í≥ÑÎäî Îã§ÏùåÍ≥º Í∞ôÏùÄ ÌïµÏã¨ Î¨∏Ï†úÎì§ÏùÑ Ìï¥Í≤∞Ìï©ÎãàÎã§:

1. **ÏôÑÎ≤ΩÌïú Í≤πÏπ® Î∞©ÏßÄ**: QuadTreeÏôÄ Ï∂©Îèå Í∞êÏßÄ ÏïåÍ≥†Î¶¨Ï¶òÏúºÎ°ú 0% Í≤πÏπ® Îã¨ÏÑ±
2. **ÏßÄÎä•Ï†Å Î†àÏù¥ÏïÑÏõÉ**: Ìè¨Ïä§ ÎîîÎ†âÌã∞ÎìúÏôÄ Í≥ÑÏ∏µÏ†Å ÏïåÍ≥†Î¶¨Ï¶òÏúºÎ°ú ÏµúÏ†Å Î∞∞Ïπò
3. **Ï†ÅÏùëÌòï Ïä§ÏºÄÏùºÎßÅ**: ÎèôÏ†Å Ìè∞Ìä∏ ÌÅ¨Í∏∞ Î∞è Ï§å Î†àÎ≤® ÎåÄÏùë
4. **Ï†ÑÎ¨∏Ï†Å ÌíàÏßà**: ÎπÑÏ¶àÎãàÏä§Í∏â ÏãúÍ∞ÅÌôî ÌíàÏßà Îã¨ÏÑ±

**Íµ¨ÌòÑ ÏôÑÎ£å Ïãú ÏòàÏÉÅ Í∞úÏÑ† Ìö®Í≥º**:
- ÏãúÍ∞ÅÏ†Å ÌíàÏßà: **300% Ìñ•ÏÉÅ**
- ÏÇ¨Ïö©Ïûê ÎßåÏ°±ÎèÑ: **90%+ Îã¨ÏÑ±**  
- Î†åÎçîÎßÅ ÏÑ±Îä•: **10Î∞∞ Ìñ•ÏÉÅ**
- Ïú†ÏßÄÎ≥¥ÏàòÏÑ±: **50% Í∞úÏÑ†**

Image #1Í≥º #2 Í∞ôÏùÄ ÏßÄÏ†ÄÎ∂ÑÌïòÍ≥† Í≤πÏπòÎäî ÏãúÍ∞ÅÌôîÎäî ÏôÑÏ†ÑÌûà ÏÇ¨ÎùºÏßÄÍ≥†, ÍπîÎÅîÌïòÍ≥† Ï†ÑÎ¨∏Ï†ÅÏù∏ Îã§Ïù¥Ïñ¥Í∑∏Îû®Ïù¥ ÏûêÎèôÏúºÎ°ú ÏÉùÏÑ±Îê©ÎãàÎã§.
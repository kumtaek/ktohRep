"""
보안 취약점 탐지 모듈 (3차 개발)

주요 기능:
1. SQL Injection 패턴 탐지 (JSP, MyBatis)
2. XSS 취약점 탐지 
3. 보안 취약점 심각도 분류
4. 취약점 수정 제안 생성

TC_002_DynamicSQLGeneration test cases 대응
"""

import re
import os
from typing import Dict, List, Optional, Tuple
from enum import Enum
from dataclasses import dataclass


class VulnerabilityType(Enum):
    """취약점 유형"""
    SQL_INJECTION = "SQL_INJECTION"
    XSS = "XSS"
    PATH_TRAVERSAL = "PATH_TRAVERSAL"
    COMMAND_INJECTION = "COMMAND_INJECTION"
    LDAP_INJECTION = "LDAP_INJECTION"


class Severity(Enum):
    """심각도 등급"""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


@dataclass
class Vulnerability:
    """취약점 정보"""
    file_path: str
    vuln_type: VulnerabilityType
    severity: Severity
    pattern: str
    message: str
    line_number: int
    column_start: int
    column_end: int
    confidence: float
    fix_suggestion: Optional[str] = None
    reference_urls: List[str] = None
    
    def __post_init__(self):
        if self.reference_urls is None:
            self.reference_urls = []


class SqlInjectionDetector:
    """SQL Injection 탐지 전용 클래스"""
    
    def __init__(self):
        # JSP SQL Injection 패턴들
        self.jsp_patterns = [
            # StringBuilder.append 패턴
            {
                'pattern': r'\.append\s*\(\s*["\'][^"\']*["\'].*?\)\.append\s*\([^)]*\w+[^)]*\)',
                'severity': Severity.HIGH,
                'message': 'StringBuilder를 이용한 동적 SQL 생성으로 SQL Injection 취약',
                'fix': 'PreparedStatement와 파라미터 바인딩 사용 권장'
            },
            # 직접 문자열 결합
            {
                'pattern': r'["\'][^"\']*(?:SELECT|INSERT|UPDATE|DELETE)[^"\']*["\'].*?\+.*?\w+',
                'severity': Severity.HIGH,
                'message': '문자열 연결을 통한 동적 SQL 생성으로 SQL Injection 취약',
                'fix': 'PreparedStatement 또는 MyBatis #{} 파라미터 사용'
            },
            # JSP Expression Language에서 SQL 생성
            {
                'pattern': r'\$\{[^}]*(?:SELECT|INSERT|UPDATE|DELETE)[^}]*\}',
                'severity': Severity.HIGH,
                'message': 'EL 표현식을 통한 동적 SQL 생성으로 SQL Injection 취약',
                'fix': 'EL 표현식 대신 백엔드에서 안전한 SQL 처리'
            },
            # 스크립틀릿 내 SQL 변수 조작
            {
                'pattern': r'<%.*?String.*?sql.*?=.*?["\'][^"\']*(?:SELECT|INSERT|UPDATE|DELETE)[^"\']*["\'].*?\+.*?%>',
                'severity': Severity.MEDIUM,
                'message': 'JSP 스크립틀릿 내 동적 SQL 생성',
                'fix': 'JSP에서 SQL 로직 제거하고 서비스 계층으로 이동'
            }
        ]
        
        # MyBatis SQL Injection 패턴들
        self.mybatis_patterns = [
            # ${} 직접 삽입 (가장 위험)
            {
                'pattern': r'\$\{[^}]+\}',
                'severity': Severity.CRITICAL,
                'message': '${} 파라미터 치환으로 SQL Injection 가능',
                'fix': '#{} 파라미터 바인딩으로 변경'
            },
            # ORDER BY에서 ${} 사용 (일반적이지만 여전히 위험)
            {
                'pattern': r'ORDER\s+BY\s+\$\{[^}]+\}',
                'severity': Severity.HIGH,
                'message': 'ORDER BY 절에서 ${} 사용으로 SQL Injection 가능',
                'fix': 'ENUM이나 화이트리스트로 정렬 컬럼 제한'
            },
            # 테이블명 동적 지정
            {
                'pattern': r'FROM\s+\$\{[^}]+\}|JOIN\s+\$\{[^}]+\}',
                'severity': Severity.CRITICAL,
                'message': '테이블명을 동적으로 지정하여 SQL Injection 가능',
                'fix': '테이블명은 화이트리스트 방식으로 검증'
            },
            # 직접 SQL 삽입
            {
                'pattern': r'<(?:select|insert|update|delete)[^>]*>\s*\$\{sql\}\s*</(?:select|insert|update|delete)>',
                'severity': Severity.CRITICAL,
                'message': '전체 SQL을 파라미터로 받아 직접 실행',
                'fix': '절대 사용 금지 - 정적 SQL로 변경'
            }
        ]
        
    def detect_jsp_sql_injection(self, content: str, file_path: str) -> List[Vulnerability]:
        """JSP 파일에서 SQL Injection 패턴 탐지"""
        vulnerabilities = []
        
        for pattern_info in self.jsp_patterns:
            pattern = pattern_info['pattern']
            severity = pattern_info['severity']
            message = pattern_info['message']
            fix = pattern_info['fix']
            
            matches = re.finditer(pattern, content, re.IGNORECASE | re.DOTALL)
            
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                column_start = match.start() - content.rfind('\n', 0, match.start())
                column_end = match.end() - content.rfind('\n', 0, match.end())
                
                # 패턴 길이에 따른 신뢰도 조정
                confidence = min(0.95, 0.7 + (len(match.group()) / 200))
                
                vuln = Vulnerability(
                    file_path=file_path,
                    vuln_type=VulnerabilityType.SQL_INJECTION,
                    severity=severity,
                    pattern=match.group()[:300],  # 300자로 제한
                    message=message,
                    line_number=line_number,
                    column_start=column_start,
                    column_end=column_end,
                    confidence=confidence,
                    fix_suggestion=fix,
                    reference_urls=[
                        "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection",
                        "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                    ]
                )
                
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def detect_mybatis_sql_injection(self, content: str, file_path: str) -> List[Vulnerability]:
        """MyBatis XML에서 SQL Injection 패턴 탐지"""
        vulnerabilities = []
        
        for pattern_info in self.mybatis_patterns:
            pattern = pattern_info['pattern']
            severity = pattern_info['severity']
            message = pattern_info['message']
            fix = pattern_info['fix']
            
            matches = re.finditer(pattern, content, re.IGNORECASE | re.DOTALL)
            
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                column_start = match.start() - content.rfind('\n', 0, match.start())
                column_end = match.end() - content.rfind('\n', 0, match.end())
                
                # ${} 패턴은 높은 신뢰도
                confidence = 0.95 if '${' in match.group() else 0.8
                
                vuln = Vulnerability(
                    file_path=file_path,
                    vuln_type=VulnerabilityType.SQL_INJECTION,
                    severity=severity,
                    pattern=match.group(),
                    message=message,
                    line_number=line_number,
                    column_start=column_start,
                    column_end=column_end,
                    confidence=confidence,
                    fix_suggestion=fix,
                    reference_urls=[
                        "https://mybatis.org/mybatis-3/sqlmap-xml.html#Parameters",
                        "https://owasp.org/www-project-top-ten/2017/A1_2017-Injection"
                    ]
                )
                
                vulnerabilities.append(vuln)
        
        return vulnerabilities


class XssDetector:
    """XSS 탐지 클래스"""
    
    def __init__(self):
        self.jsp_xss_patterns = [
            # JSP 출력 표현식 without escaping
            {
                'pattern': r'<%=\s*[^%]*%>',
                'severity': Severity.HIGH,
                'message': 'JSP 출력 표현식에서 XSS 가능성',
                'fix': '<c:out> 태그 또는 ESAPI 라이브러리 사용'
            },
            # EL 표현식 without escaping  
            {
                'pattern': r'\$\{[^}]*\}',
                'severity': Severity.MEDIUM,
                'message': 'EL 표현식 출력에서 XSS 가능성',
                'fix': 'EL escaping 활성화 또는 <c:out> 사용'
            },
            # JavaScript 내 서버 데이터 삽입
            {
                'pattern': r'<script[^>]*>.*?<%[^%]*%>.*?</script>',
                'severity': Severity.HIGH,
                'message': 'JavaScript 내 서버 데이터 직접 삽입으로 XSS 위험',
                'fix': 'JSON 형태로 안전하게 데이터 전달'
            }
        ]
    
    def detect_jsp_xss(self, content: str, file_path: str) -> List[Vulnerability]:
        """JSP 파일에서 XSS 패턴 탐지"""
        vulnerabilities = []
        
        for pattern_info in self.jsp_xss_patterns:
            pattern = pattern_info['pattern']
            severity = pattern_info['severity']
            message = pattern_info['message']
            fix = pattern_info['fix']
            
            matches = re.finditer(pattern, content, re.IGNORECASE | re.DOTALL)
            
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1
                column_start = match.start() - content.rfind('\n', 0, match.start())
                column_end = match.end() - content.rfind('\n', 0, match.end())
                
                vuln = Vulnerability(
                    file_path=file_path,
                    vuln_type=VulnerabilityType.XSS,
                    severity=severity,
                    pattern=match.group()[:200],
                    message=message,
                    line_number=line_number,
                    column_start=column_start,
                    column_end=column_end,
                    confidence=0.7,  # XSS는 false positive 가능성 높음
                    fix_suggestion=fix,
                    reference_urls=[
                        "https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)",
                        "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
                    ]
                )
                
                vulnerabilities.append(vuln)
        
        return vulnerabilities


class VulnerabilityDetector:
    """통합 취약점 탐지기"""
    
    def __init__(self, config: Dict = None):
        self.config = config or {}
        self.sql_detector = SqlInjectionDetector()
        self.xss_detector = XssDetector()
        
        # 설정 기반 탐지 활성화/비활성화
        self.sql_injection_enabled = self.config.get('security', {}).get('sql_injection_detection', True)
        self.xss_enabled = self.config.get('security', {}).get('xss_detection', True)
        
    def detect_vulnerabilities(self, file_path: str, content: str, file_type: str) -> List[Vulnerability]:
        """파일에서 모든 취약점 탐지"""
        vulnerabilities = []
        
        if file_type == 'jsp':
            if self.sql_injection_enabled:
                vulnerabilities.extend(self.sql_detector.detect_jsp_sql_injection(content, file_path))
            if self.xss_enabled:
                vulnerabilities.extend(self.xss_detector.detect_jsp_xss(content, file_path))
                
        elif file_type == 'mybatis' or file_type == 'xml':
            if self.sql_injection_enabled:
                vulnerabilities.extend(self.sql_detector.detect_mybatis_sql_injection(content, file_path))
        
        # 중복 제거 (같은 위치의 유사한 취약점)
        vulnerabilities = self._deduplicate_vulnerabilities(vulnerabilities)
        
        return vulnerabilities
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """중복 취약점 제거"""
        seen = set()
        deduped = []
        
        for vuln in vulnerabilities:
            # 파일경로, 라인번호, 취약점 타입으로 중복 판단
            key = (vuln.file_path, vuln.line_number, vuln.vuln_type)
            
            if key not in seen:
                seen.add(key)
                deduped.append(vuln)
        
        return deduped
    
    def generate_vulnerability_report(self, vulnerabilities: List[Vulnerability]) -> Dict:
        """취약점 보고서 생성"""
        report = {
            'summary': {
                'total_vulnerabilities': len(vulnerabilities),
                'critical': len([v for v in vulnerabilities if v.severity == Severity.CRITICAL]),
                'high': len([v for v in vulnerabilities if v.severity == Severity.HIGH]),
                'medium': len([v for v in vulnerabilities if v.severity == Severity.MEDIUM]),
                'low': len([v for v in vulnerabilities if v.severity == Severity.LOW])
            },
            'by_type': {},
            'by_file': {},
            'vulnerabilities': []
        }
        
        # 타입별 그룹화
        type_groups = {}
        for vuln in vulnerabilities:
            vuln_type = vuln.vuln_type.value
            if vuln_type not in type_groups:
                type_groups[vuln_type] = []
            type_groups[vuln_type].append(vuln)
        
        report['by_type'] = {k: len(v) for k, v in type_groups.items()}
        
        # 파일별 그룹화
        file_groups = {}
        for vuln in vulnerabilities:
            file_path = vuln.file_path
            if file_path not in file_groups:
                file_groups[file_path] = []
            file_groups[file_path].append(vuln)
        
        report['by_file'] = {k: len(v) for k, v in file_groups.items()}
        
        # 취약점 상세 정보
        for vuln in vulnerabilities:
            report['vulnerabilities'].append({
                'file_path': vuln.file_path,
                'type': vuln.vuln_type.value,
                'severity': vuln.severity.value,
                'message': vuln.message,
                'line_number': vuln.line_number,
                'pattern': vuln.pattern,
                'confidence': vuln.confidence,
                'fix_suggestion': vuln.fix_suggestion,
                'reference_urls': vuln.reference_urls
            })
        
        return report
    
    def export_sarif_format(self, vulnerabilities: List[Vulnerability], output_path: str):
        """SARIF 형식으로 취약점 결과 내보내기"""
        import json
        
        sarif_report = {
            "version": "2.1.0",
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            "runs": [
                {
                    "tool": {
                        "driver": {
                            "name": "SourceAnalyzer Security Scanner",
                            "version": "3.0.0",
                            "informationUri": "https://github.com/your-org/source-analyzer"
                        }
                    },
                    "results": []
                }
            ]
        }
        
        for vuln in vulnerabilities:
            result = {
                "ruleId": f"{vuln.vuln_type.value}_001",
                "level": self._severity_to_sarif_level(vuln.severity),
                "message": {
                    "text": vuln.message
                },
                "locations": [
                    {
                        "physicalLocation": {
                            "artifactLocation": {
                                "uri": vuln.file_path
                            },
                            "region": {
                                "startLine": vuln.line_number,
                                "startColumn": vuln.column_start,
                                "endColumn": vuln.column_end
                            }
                        }
                    }
                ],
                "properties": {
                    "confidence": vuln.confidence,
                    "fix_suggestion": vuln.fix_suggestion
                }
            }
            
            sarif_report["runs"][0]["results"].append(result)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(sarif_report, f, indent=2, ensure_ascii=False)
    
    def _severity_to_sarif_level(self, severity: Severity) -> str:
        """심각도를 SARIF 레벨로 변환"""
        mapping = {
            Severity.CRITICAL: "error",
            Severity.HIGH: "error", 
            Severity.MEDIUM: "warning",
            Severity.LOW: "note",
            Severity.INFO: "note"
        }
        return mapping.get(severity, "note")
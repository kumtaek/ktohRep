<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.mapper.ProductMapper">
    
    <!-- 상품 기본 컬럼 -->
    <sql id="productColumns">
        p.product_id, p.product_name, p.description, p.price, 
        p.stock_quantity, p.category_id, p.brand_id, p.status,
        p.created_date, p.updated_date, p.del_yn
    </sql>
    
    <!-- 카테고리 정보 -->
    <sql id="categoryColumns">
        c.category_name, c.category_code
    </sql>
    
    <!-- 브랜드 정보 -->  
    <sql id="brandColumns">
        b.brand_name, b.brand_code
    </sql>
    
    <!-- 공통 조건 -->
    <sql id="activeProductCondition">
        WHERE p.del_yn = 'N' AND p.status = 'ACTIVE'
    </sql>
    
    <select id="selectAllProducts" resultType="ProductVO">
        SELECT 
            <include refid="productColumns"/>,
            <include refid="categoryColumns"/>,
            <include refid="brandColumns"/>
        FROM products p
        LEFT JOIN categories c ON p.category_id = c.category_id
        LEFT JOIN brands b ON p.brand_id = b.brand_id
        <include refid="activeProductCondition"/>
        ORDER BY p.created_date DESC
    </select>
    
    <!--
        @QueryName: selectProductById
        @TableName: PRODUCTS, CATEGORIES, BRANDS  
        @ColumnName: product_id, product_name, description, price, stock_quantity
        @Description: 상품 ID로 상품 상세 정보를 조회합니다.
                     카테고리와 브랜드 정보를 LEFT JOIN으로 함께 조회합니다.
        @JoinCondition: products.category_id = categories.category_id (LEFT)
                       products.brand_id = brands.brand_id (LEFT)
    -->
    <select id="selectProductById" parameterType="String" resultType="ProductVO">
        SELECT 
            <include refid="productColumns"/>,
            <include refid="categoryColumns"/>,
            <include refid="brandColumns"/>
        FROM products p
        LEFT JOIN categories c ON p.category_id = c.category_id
        LEFT JOIN brands b ON p.brand_id = b.brand_id
        WHERE p.product_id = #{productId}
        AND p.del_yn = 'N'
    </select>
    
    <!-- 복잡한 검색 조건이 포함된 동적 쿼리 -->
    <select id="searchProductsWithCriteria" parameterType="Map" resultType="ProductVO">
        <bind name="categoryFilter" value="category != null ? category : ''"/>
        <bind name="priceMin" value="minPrice != null ? minPrice : 0"/>
        <bind name="priceMax" value="maxPrice != null ? maxPrice : 999999"/>
        <bind name="brandPattern" value="brand != null ? '%' + brand + '%' : '%'"/>
        
        SELECT 
            <include refid="productColumns"/>,
            <include refid="categoryColumns"/>,
            <include refid="brandColumns"/>,
            -- 재고 상태 계산
            CASE 
                WHEN p.stock_quantity > 100 THEN 'HIGH'
                WHEN p.stock_quantity > 10 THEN 'MEDIUM' 
                ELSE 'LOW'
            END as stock_status,
            -- 할인율 적용 가격 (서브쿼리)
            (SELECT p.price * (1 - COALESCE(d.discount_rate, 0))
             FROM discounts d 
             WHERE d.product_id = p.product_id 
             AND d.active_yn = 'Y' 
             AND SYSDATE BETWEEN d.start_date AND d.end_date
             AND ROWNUM = 1) as discounted_price
        FROM products p
        LEFT JOIN categories c ON p.category_id = c.category_id
        LEFT JOIN brands b ON p.brand_id = b.brand_id
        <where>
            <include refid="activeProductCondition"/>
            
            <if test="category != null and category != ''">
                AND c.category_code = #{categoryFilter}
            </if>
            
            <choose>
                <when test="minPrice != null and maxPrice != null">
                    AND p.price BETWEEN #{priceMin} AND #{priceMax}
                </when>
                <when test="minPrice != null">
                    AND p.price >= #{priceMin}
                </when>
                <when test="maxPrice != null">
                    AND p.price &lt;= #{priceMax}
                </when>
            </choose>
            
            <if test="brand != null and brand != ''">
                AND b.brand_name LIKE #{brandPattern}
            </if>
            
            <if test="keyword != null and keyword != ''">
                AND (p.product_name LIKE '%' || #{keyword} || '%'
                     OR p.description LIKE '%' || #{keyword} || '%')
            </if>
            
            <if test="inStock != null and inStock == true">
                AND p.stock_quantity > 0
            </if>
            
            <if test="categoryList != null and categoryList.size() > 0">
                AND c.category_code IN
                <foreach item="cat" collection="categoryList" open="(" separator="," close=")">
                    #{cat}
                </foreach>
            </if>
        </where>
        
        <choose>
            <when test="sortBy == 'price_asc'">
                ORDER BY p.price ASC
            </when>
            <when test="sortBy == 'price_desc'">
                ORDER BY p.price DESC
            </when>
            <when test="sortBy == 'name'">
                ORDER BY p.product_name ASC
            </when>
            <otherwise>
                ORDER BY p.created_date DESC
            </otherwise>
        </choose>
    </select>
    
    <!-- 10개 테이블 조인하는 복잡한 쿼리 예제 -->
    <select id="getComplexProductAnalysis" parameterType="Map" resultType="Map">
        SELECT 
            p.product_id,
            p.product_name,
            c.category_name,
            b.brand_name,
            s.supplier_name,
            w.warehouse_name,
            r.avg_rating,
            r.review_count,
            inv.current_stock,
            sales.total_sold,
            disc.discount_rate,
            -- SF 함수 호출
            CALCULATE_PRODUCT_SCORE(p.product_id) as product_score,
            GET_SEASONAL_FACTOR(p.category_id, EXTRACT(MONTH FROM SYSDATE)) as seasonal_factor
        FROM products p
        INNER JOIN categories c ON p.category_id = c.category_id
        INNER JOIN brands b ON p.brand_id = b.brand_id  
        LEFT JOIN suppliers s ON p.supplier_id = s.supplier_id
        LEFT JOIN warehouses w ON p.warehouse_id = w.warehouse_id
        LEFT JOIN (
            -- 평점 정보 서브쿼리
            SELECT product_id, AVG(rating) as avg_rating, COUNT(*) as review_count
            FROM product_reviews
            WHERE del_yn = 'N'
            GROUP BY product_id
        ) r ON p.product_id = r.product_id
        LEFT JOIN inventories inv ON p.product_id = inv.product_id
        LEFT JOIN (
            -- 판매량 정보 서브쿼리  
            SELECT oi.product_id, SUM(oi.quantity) as total_sold
            FROM order_items oi
            INNER JOIN orders o ON oi.order_id = o.order_id
            WHERE o.order_date >= ADD_MONTHS(SYSDATE, -12)
            AND o.del_yn = 'N' AND oi.del_yn = 'N'
            GROUP BY oi.product_id
        ) sales ON p.product_id = sales.product_id
        LEFT JOIN discounts disc ON p.product_id = disc.product_id 
            AND disc.active_yn = 'Y'
            AND SYSDATE BETWEEN disc.start_date AND disc.end_date
        WHERE p.del_yn = 'N'
        <if test="categoryId != null">
            AND p.category_id = #{categoryId}
        </if>
        <if test="brandId != null">  
            AND p.brand_id = #{brandId}
        </if>
        ORDER BY product_score DESC, p.product_name
    </select>
    
    <!-- 동적 SQL 실행 -->
    <select id="executeDynamicQuery" parameterType="String" resultType="Map">
        ${sql}
    </select>
    
</mapper>
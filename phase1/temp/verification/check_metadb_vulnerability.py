#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sqlite3

def check_metadb_vulnerability():
    """메타디비에서 VulnerabilityTestService.java 처리 상태 확인"""
    print("=== 메타디비 VulnerabilityTestService.java 처리 상태 확인 ===\n")
    
    db_path = "project/sampleSrc/metadata.db"
    file_path = "project/sampleSrc/src/main/java/com/example/integrated/VulnerabilityTestService.java"
    abs_path = os.path.abspath(file_path)
    
    print(f"파일 경로: {file_path}")
    print(f"절대 경로: {abs_path}")
    print()
    
    if os.path.exists(db_path):
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # 1. files 테이블에서 해당 파일 확인
            print("=== 1. files 테이블 확인 ===")
            cursor.execute("SELECT file_id, project_id, path, language, hash, loc FROM files WHERE path = ?", (abs_path,))
            file_result = cursor.fetchone()
            
            if file_result:
                file_id, project_id, path, language, hash_value, loc = file_result
                print(f"파일 ID: {file_id}")
                print(f"프로젝트 ID: {project_id}")
                print(f"경로: {path}")
                print(f"언어: {language}")
                print(f"해시: {hash_value}")
                print(f"LOC: {loc}")
            else:
                print("❌ files 테이블에 해당 파일이 없습니다!")
                return
            
            # 2. classes 테이블에서 해당 파일의 클래스 확인
            print(f"\n=== 2. classes 테이블 확인 (file_id: {file_id}) ===")
            cursor.execute("SELECT class_id, fqn, name, start_line, end_line, modifiers FROM classes WHERE file_id = ?", (file_id,))
            class_results = cursor.fetchall()
            
            if class_results:
                for class_id, fqn, name, start_line, end_line, modifiers in class_results:
                    print(f"클래스 ID: {class_id}, FQN: {fqn}, 이름: {name}, 라인: {start_line}-{end_line}, 수정자: {modifiers}")
            else:
                print("❌ classes 테이블에 해당 파일의 클래스가 없습니다!")
            
            # 3. methods 테이블에서 해당 파일의 메소드 확인
            print(f"\n=== 3. methods 테이블 확인 ===")
            if class_results:
                for class_id, fqn, name, start_line, end_line, modifiers in class_results:
                    cursor.execute("SELECT method_id, name, signature, return_type, parameters, modifiers FROM methods WHERE class_id = ?", (class_id,))
                    method_results = cursor.fetchall()
                    
                    if method_results:
                        print(f"클래스 {name}의 메소드들:")
                        for method_id, method_name, signature, return_type, parameters, method_modifiers in method_results:
                            print(f"  - {return_type} {method_name}({parameters}) [수정자: {method_modifiers}]")
                    else:
                        print(f"❌ 클래스 {name}에 메소드가 없습니다!")
            else:
                print("❌ 클래스가 없어서 메소드를 확인할 수 없습니다!")
            
            # 4. parse_results 테이블 스키마 확인
            print(f"\n=== 4. parse_results 테이블 스키마 ===")
            cursor.execute("PRAGMA table_info(parse_results)")
            columns = cursor.fetchall()
            for col in columns:
                print(f"  {col[1]} ({col[2]})")
            
            # 5. parse_results 테이블에서 파싱 결과 확인
            print(f"\n=== 5. parse_results 테이블 확인 ===")
            cursor.execute("SELECT * FROM parse_results")
            parse_results = cursor.fetchall()
            
            if parse_results:
                print(f"전체 파싱 결과 수: {len(parse_results)}")
                # 해당 파일과 관련된 결과 찾기
                for result in parse_results:
                    if abs_path in str(result):
                        print(f"해당 파일 파싱 결과: {result}")
                        break
                else:
                    print("❌ 해당 파일의 파싱 결과를 찾을 수 없습니다!")
            else:
                print("❌ parse_results 테이블이 비어있습니다!")
            
            conn.close()
            
        except Exception as e:
            print(f"❌ 메타디비 조회 오류: {e}")
    else:
        print("❌ 메타디비 파일이 없습니다.")

if __name__ == "__main__":
    check_metadb_vulnerability()

# 청크-엣지 시스템 명세서

## 📋 개요

**작성일**: 2025-09-05  
**시스템명**: 소스 코드 분석 청크-엣지 관리 시스템  
**목적**: 소스 코드를 구성 요소(청크)로 분해하고 컴포넌트 간 관계(엣지)를 동적으로 분석하여 메타DB에 저장  
**기술 스택**: Python, SQLAlchemy, AST 파싱, LLM 분석

## 🧩 청크(Chunk) 정의

### 1.1 청크란?

**청크(Chunk)**는 소스 코드의 최소 분석 단위로, 의미 있는 코드 블록을 나타냅니다.

```
청크 = 소스 코드 내 특정 기능을 수행하는 독립적인 코드 블록
```

### 1.2 청크 유형별 정의

| 청크 유형        | 설명            | 예시                                 | 식별 기준          |
| ------------ | ------------- | ---------------------------------- | -------------- |
| **class**    | Java 클래스      | `public class UserController`      | 클래스 선언문        |
| **method**   | Java 메서드      | `public User getUserById(Long id)` | 메서드 선언문        |
| **sql_unit** | SQL 쿼리        | `<select id="findUser">`           | MyBatis SQL 태그 |
| **file**     | 전체 파일         | `UserController.java`              | 파일 단위          |
| **table**    | DB 테이블        | `users`, `products`                | 테이블 정보         |
| **function** | JavaScript 함수 | `function validateSearch()`        | JSP 내 JS 함수    |

### 1.3 청크 식별 프로세스

```python
# 1단계: 파서를 통한 구문 분석
java_analysis = java_parser.analyze_file("UserController.java")

# 2단계: 청크 추출
for class_info in java_analysis['classes']:
    class_chunk = create_chunk(
        type='class',
        name=class_info['fqn'],
        location=class_info['location']
    )

    for method_info in class_info['methods']:
        method_chunk = create_chunk(
            type='method',
            name=method_info['signature'],
            location=method_info['location']
        )
```

## 🌐 엣지(Edge) 정의

### 2.1 엣지란?

**엣지(Edge)**는 청크들 간의 관계를 나타내는 방향성 있는 연결선입니다.

```
엣지 = 소스(Source) 청크 → 타겟(Target) 청크 간의 관계
```

### 2.2 엣지 유형별 정의

#### 2.2.1 Java 코드 관계

| 엣지 유형          | 설명        | 예시                                          | 신뢰도 |
| -------------- | --------- | ------------------------------------------- | --- |
| **dependency** | 의존성 주입 관계 | `UserController → UserService` (@Autowired) | 0.9 |
| **reference**  | 참조 관계     | `UserService → User` (파라미터/반환타입)            | 0.7 |
| **calls**      | 메서드 호출 관계 | `getUserList() → userService.findAll()`     | 0.8 |
| **import**     | Import 관계 | `UserController → User` (import 문)          | 0.9 |
| **extends**    | 상속 관계     | `UserServiceImpl → UserService`             | 1.0 |
| **implements** | 구현 관계     | `UserMapperImpl → UserMapper`               | 1.0 |

#### 2.2.2 데이터베이스 관계

| 엣지 유형           | 설명          | 예시                                       | 신뢰도  |
| --------------- | ----------- | ---------------------------------------- | ---- |
| **foreign_key** | 외래키 관계      | `users.user_type → user_types.type_code` | 0.95 |
| **join**        | SQL JOIN 관계 | `users ⟷ user_types` (LEFT JOIN)         | 0.9  |
| **references**  | 테이블 참조      | `SQL Unit → users 테이블`                   | 0.8  |

#### 2.2.3 웹 계층 관계

| 엣지 유형        | 설명               | 예시                                               | 신뢰도  |
| ------------ | ---------------- | ------------------------------------------------ | ---- |
| **calls**    | JSP → Controller | `user/list.jsp → UserController.getUserList()`   | 0.8  |
| **displays** | 모델 표시 관계         | `user/list.jsp → User 모델`                        | 0.7  |
| **maps_to**  | XML 매핑 관계        | `UserMapper.xml → com.example.mapper.UserMapper` | 0.95 |

#### 2.2.4 데이터 플로우 관계

| 엣지 유형         | 설명     | 예시                            | 신뢰도 |
| ------------- | ------ | ----------------------------- | --- |
| **data_flow** | 데이터 흐름 | `INSERT users → SELECT users` | 0.9 |

### 2.3 엣지 생성 프로세스

```python
# 1단계: 파서 기반 엣지 생성
def _create_dependency_edge(src_class, dst_class):
    edge = EdgeManager.create_edge(
        src_type='class',
        src_id=src_class.class_id,
        dst_type='class', 
        dst_id=dst_class.class_id,
        edge_kind='dependency',
        confidence=0.8,
        meta="Spring @Autowired dependency"
    )

# 2단계: LLM 기반 엣지 검증
llm_relationships = relationship_analyzer.analyze_java_relationships(
    java_content, file_path, project_context
)

# 3단계: 엣지 메타데이터 생성 (위치 정보 포함)
enhanced_meta = {
    'description': '의존성 주입 관계',
    'source_location': {
        'file_path': '/src/UserController.java',
        'start_line': 15,
        'end_line': 17
    },
    'target_location': {
        'file_path': '/src/UserService.java', 
        'start_line': 1,
        'end_line': 50
    },
    'analysis_method': 'ast_parsing'
}
```

## 📍 청크 위치 정보

### 3.1 위치 정보 구조

```python
@dataclass
class ChunkLocation:
    file_path: str           # 소스 파일 경로
    start_line: int          # 시작 라인 번호 (1-based)
    end_line: int           # 끝 라인 번호
    start_column: int = 0    # 시작 컬럼 (선택적)
    end_column: int = 0     # 끝 컬럼 (선택적)
    content_preview: str = ""  # 내용 미리보기 (처음 200자)
```

### 3.2 위치 추적 방법

#### 3.2.1 Java 메서드 위치 추적

```python
def _find_method_in_file(self, file_path, method_name, method_signature):
    """파일에서 메서드 위치 찾기"""
    lines = self._get_file_lines(file_path)

    # 메서드 패턴 매칭
    pattern = rf'^\s*(public|private|protected)?\s*(static)?\s*\w+\s+{method_name}\s*\('

    for i, line in enumerate(lines):
        if re.search(pattern, line):
            start_line = i + 1
            end_line = self._find_method_end_line(lines, i)  # 중괄호 매칭

            return ChunkLocation(
                file_path=file_path,
                start_line=start_line,
                end_line=end_line,
                content_preview=self._extract_preview(lines, i)
            )
```

#### 3.2.2 SQL Unit 위치 추적

```python
def _find_sql_unit_in_xml(self, file_path, stmt_id, stmt_kind):
    """XML 파일에서 SQL Unit 위치 찾기"""
    lines = self._get_file_lines(file_path)

    # SQL 태그 패턴
    pattern = rf'<{stmt_kind}\s+.*id=["\']({stmt_id})["\']'

    for i, line in enumerate(lines):
        if re.search(pattern, line, re.IGNORECASE):
            start_line = i + 1
            end_line = self._find_xml_tag_end_line(lines, i, stmt_kind)

            return ChunkLocation(
                file_path=file_path,
                start_line=start_line,
                end_line=end_line
            )
```

### 3.3 위치 정보 활용

```python
# 청크 내용 실시간 추출
def get_chunk_content_from_location(location: ChunkLocation) -> str:
    """위치 정보를 사용하여 실제 청크 내용 추출"""
    with open(location.file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
        start_idx = location.start_line - 1
        end_idx = location.end_line
        return ''.join(lines[start_idx:end_idx])
```

## 🎭 더미 청크 시스템

### 4.1 더미 청크란?

**더미 청크**는 엣지 생성 과정에서 참조되는 대상이 메타DB에 존재하지 않을 때 자동으로 생성되는 임시 청크입니다.

### 4.2 더미 청크 생성 시나리오

```
시나리오: UserController → UserService 엣지 생성 시도
1. UserController는 메타DB에 존재 ✓
2. UserService는 메타DB에 존재하지 않음 ✗
3. 시스템이 자동으로 UserService 더미 청크 생성 🔧
4. 엣지 생성 완료 ✓
```

### 4.3 더미 청크 생성 로직

```python
def _create_dummy_chunk(self, target_type: str, original_id: int, description: str):
    """더미 청크 생성"""

    if target_type == 'table':
        # 더미 테이블 생성
        default_owner = self.config.get('database', {}).get('default_table_owner', 'SAMPLE')

        table_name = self._extract_table_name_from_description(description)
        if not table_name:
            table_name = f"DUMMY_TABLE_{original_id}"

        dummy_table = DbTable(
            table_id=original_id,
            owner=default_owner,  # 설정 파일에서 가져온 기본 owner
            table_name=table_name.upper(),
            table_type='TABLE',
            comments=f"DUMMY: {description}",
            num_rows=0,
            is_dummy=True
        )

        self.db_session.add(dummy_table)

    elif target_type == 'class':
        # 더미 클래스 생성
        class_fqn = self._extract_fqn_from_description(description)
        if not class_fqn:
            class_fqn = f"com.example.dummy.DummyClass_{original_id}"

        dummy_class = Class(
            class_id=original_id,
            file_id=self._get_or_create_dummy_file(),
            fqn=class_fqn,
            name=class_fqn.split('.')[-1],
            package='.'.join(class_fqn.split('.')[:-1]),
            comments=f"DUMMY: {description}"
        )

        self.db_session.add(dummy_class)
```

### 4.4 기본 Owner 설정

#### 4.4.1 설정 파일 구조 (config.yaml)

```yaml
database:
  default_schema_owner: 'SAMPLE'
  default_table_owner: 'SAMPLE'
  default_view_owner: 'SAMPLE'

edge_generation:
  enable_dummy_chunks: true
  min_confidence: 0.3
  max_edges_per_source: 100
```

#### 4.4.2 기본 Owner 적용 로직

```python
def _load_config(self, config_path: str = None) -> Dict[str, Any]:
    """설정 파일 로드"""
    if config_path and os.path.exists(config_path):
        with open(config_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)

    # 기본값 설정
    return {
        'database': {
            'default_schema_owner': 'SAMPLE',
            'default_table_owner': 'SAMPLE'
        }
    }

# 더미 테이블 생성시 기본 owner 적용
default_owner = self.config.get('database', {}).get('default_table_owner', 'SAMPLE')
dummy_table.owner = default_owner
```

## 🔄 엣지 생성 프로세스

### 5.1 통합 엣지 생성 플로우

```
📊 1단계: 프로젝트 컨텍스트 구축
  ├─ 모든 클래스 정보 수집
  ├─ 파일 구조 분석
  └─ 프로젝트 메타데이터 구축

🧹 2단계: 기존 엣지 정리
  ├─ 중복 엣지 제거
  └─ 무효 엣지 제거

🔍 3단계: 파서 기반 엣지 생성
  ├─ Java 의존성 분석 (AST 파싱)
  ├─ MyBatis 매핑 관계 분석
  ├─ JSP 컨트롤러 관계 분석
  └─ SQL JOIN 관계 분석

🤖 4단계: LLM 기반 엣지 보완
  ├─ 복잡한 관계 패턴 분석
  ├─ 파서로 놓친 관계 발견
  └─ 관계 신뢰도 검증

✅ 5단계: 엣지 정제 및 검증
  ├─ 낮은 신뢰도 엣지 제거
  ├─ 순환 참조 검증
  └─ 최종 통계 생성
```

### 5.2 중복 방지 메커니즘

```python
class EdgeManager:
    def __init__(self):
        # 중복 방지를 위한 캐시
        self.existing_edges_cache: Set[Tuple] = set()

    def create_edge(self, src_type, src_id, dst_type, dst_id, edge_kind):
        # 1단계: 중복 체크
        edge_key = (src_type, src_id, dst_type, dst_id, edge_kind)
        if edge_key in self.existing_edges_cache:
            return None  # 중복 엣지 스킵

        # 2단계: 청크 존재 여부 확인
        if not self._chunk_exists(src_type, src_id):
            src_id = self._create_dummy_chunk(src_type, src_id)

        if not self._chunk_exists(dst_type, dst_id):
            dst_id = self._create_dummy_chunk(dst_type, dst_id)

        # 3단계: 엣지 생성
        edge = Edge(...)
        self.db_session.add(edge)

        # 4단계: 캐시 업데이트
        self.existing_edges_cache.add(edge_key)
```

## 📊 메타데이터 구조

### 6.1 엣지 메타데이터 스키마

```json
{
  "description": "Spring 의존성 주입 관계",
  "source_location": {
    "file_path": "/src/main/java/com/example/controller/UserController.java",
    "start_line": 15,
    "end_line": 17,
    "content_preview": "@Autowired\nprivate UserService userService;"
  },
  "target_location": {
    "file_path": "/src/main/java/com/example/service/UserService.java",
    "start_line": 1,
    "end_line": 50,
    "content_preview": "public interface UserService {"
  },
  "created_by": "enhanced_edge_generator",
  "analysis_method": "ast_parsing",
  "confidence": 0.9,
  "evidence": "@Autowired annotation found"
}
```

### 6.2 DB 스키마 구조

```sql
-- 엣지 테이블
CREATE TABLE edges (
    edge_id INTEGER PRIMARY KEY,
    project_id INTEGER NOT NULL,
    src_type VARCHAR(50) NOT NULL,     -- 소스 청크 타입
    src_id INTEGER NOT NULL,           -- 소스 청크 ID
    dst_type VARCHAR(50) NOT NULL,     -- 대상 청크 타입  
    dst_id INTEGER,                    -- 대상 청크 ID
    edge_kind VARCHAR(50) NOT NULL,    -- 엣지 유형
    confidence FLOAT,                  -- 신뢰도 (0.0-1.0)
    meta TEXT,                         -- JSON 메타데이터 (위치 정보 포함)
    created_at DATETIME,
    FOREIGN KEY(project_id) REFERENCES projects(project_id)
);

-- 청크 테이블 (일반 청크용)
CREATE TABLE chunks (
    chunk_id INTEGER PRIMARY KEY,
    target_type VARCHAR(50) NOT NULL,  -- 청크 타입
    target_id INTEGER NOT NULL,        -- 청크 ID
    content TEXT,                      -- 청크 내용
    token_count INTEGER,
    hash VARCHAR(64),
    created_at DATETIME
);
```

## 🔧 구현된 주요 클래스

### 7.1 핵심 클래스 구조

```
📦 phase1/utils/
├── 🎯 enhanced_edge_generator.py      # 향상된 엣지 생성기
├── 🛠️ edge_manager.py                 # 엣지 관리자 (중복 방지, 더미 생성)
├── 📍 chunk_location_tracker.py       # 청크 위치 추적기
└── 🤖 ../llm/relationship_analyzer.py # LLM 기반 관계 분석기

📦 phase1/
└── 🚀 edge_generation_system.py       # 통합 엣지 생성 시스템
```

### 7.2 주요 메서드 요약

| 클래스                     | 주요 메서드                         | 기능                |
| ----------------------- | ------------------------------ | ----------------- |
| `EnhancedEdgeGenerator` | `generate_all_edges()`         | 모든 유형의 엣지 생성      |
| `EdgeManager`           | `create_edge()`                | 중복 방지 엣지 생성       |
| `EdgeManager`           | `_create_dummy_chunk()`        | 더미 청크 자동 생성       |
| `ChunkLocationTracker`  | `track_java_method_location()` | Java 메서드 위치 추적    |
| `ChunkLocationTracker`  | `track_sql_unit_location()`    | SQL Unit 위치 추적    |
| `RelationshipAnalyzer`  | `analyze_java_relationships()` | LLM 기반 Java 관계 분석 |
| `EdgeGenerationSystem`  | `generate_all_edges()`         | 전체 시스템 통합 실행      |

## 🎯 사용 예제

### 8.1 기본 사용법

```python
from phase1.edge_generation_system import EdgeGenerationSystem
from database.metadata_engine import MetadataEngine

# DB 세션 생성
engine = MetadataEngine()
db_session = engine.get_session()

# 엣지 생성 시스템 초기화
edge_system = EdgeGenerationSystem(
    db_session=db_session,
    project_path="./project/sampleSrc",
    project_id=1
)

# 엣지 생성 실행
result = edge_system.generate_all_edges(
    enable_llm_analysis=True,
    enable_advanced_parsing=True
)

print(f"생성된 엣지 수: {result['total_edges_created']}")
print(f"실행 시간: {result['execution_time']}")
```

### 8.2 개별 컴포넌트 사용법

```python
# 엣지 매니저만 사용하기
from phase1.utils.edge_manager import EdgeManager

edge_manager = EdgeManager(db_session, project_id=1)

# 수동 엣지 생성
edge = edge_manager.create_edge(
    src_type='class',
    src_id=1,
    dst_type='class', 
    dst_id=2,
    edge_kind='dependency',
    confidence=0.8,
    meta='@Autowired 의존성'
)

# 이름 기반 엣지 생성
edge = edge_manager.create_edge_by_names(
    src_type='class',
    src_name='com.example.controller.UserController',
    dst_type='class',
    dst_name='com.example.service.UserService', 
    edge_kind='dependency'
)
```

### 8.3 위치 정보 활용

```python
from phase1.utils.chunk_location_tracker import (
    ChunkLocationTracker, 
    get_chunk_content_from_location
)

tracker = ChunkLocationTracker(db_session)

# 메서드 위치 추적
location = tracker.track_java_method_location(
    method_id=123,
    class_fqn='com.example.controller.UserController',
    method_name='getUserList'
)

if location:
    print(f"파일: {location.file_path}")
    print(f"라인: {location.start_line}-{location.end_line}")

    # 실제 코드 내용 가져오기
    content = get_chunk_content_from_location(location)
    print(f"내용:\n{content}")
```

## 📈 성능 및 통계

### 9.1 예상 처리 성능

- **소규모 프로젝트** (50개 파일): 30-60초, 100-200개 엣지
- **중간 프로젝트** (200개 파일): 2-5분, 500-1000개 엣지  
- **대규모 프로젝트** (500개 파일): 10-20분, 2000-5000개 엣지

### 9.2 신뢰도 분포

| 엣지 유형          | 평균 신뢰도 | 생성 방법     |
| -------------- | ------ | --------- |
| Import 관계      | 0.95   | AST 파싱    |
| @Autowired 의존성 | 0.9    | 어노테이션 분석  |
| SQL JOIN       | 0.9    | 정규식 + LLM |
| 메서드 호출         | 0.8    | AST + LLM |
| 타입 참조          | 0.7    | 타입 분석     |
| JSP 컨트롤러       | 0.6    | URL 패턴 매칭 |

## 📋 사용법 및 실행 방법

### 9.1 메인 프로그램을 통한 실행

청크-엣지 생성 시스템은 `main.py` 실행을 통해 자동으로 실행됩니다:

```bash
# 기본 실행
python phase1/main.py --project-name sampleSrc

# 완전한 실행 예제
python phase1/main.py --project-name sampleSrc --source-path project/sampleSrc --clean --verbose
```

### 9.2 필수 매개변수

| 매개변수             | 설명      | 예시          | 필수 여부  |
| ---------------- | ------- | ----------- | ------ |
| `--project-name` | 프로젝트 이름 | `sampleSrc` | **필수** |

### 9.3 선택적 매개변수

| 매개변수             | 설명               | 기본값                         | 비고           |
| ---------------- | ---------------- | --------------------------- | ------------ |
| `--source-path`  | 소스 코드 경로         | `config.yaml`에 정의           | 프로젝트 루트 경로   |
| `--config`       | 전역 설정 파일 경로      | `phase1/config/config.yaml` | 시스템 설정       |
| `--phase-config` | Phase1 설정 파일 경로  | `phase1/config/config.yaml` | Phase1 전용 설정 |
| `--clean`        | 분석 전 기존 DB 파일 삭제 | `false`                     | 깨끗한 시작       |
| `--incremental`  | 증분 분석 모드         | `false`                     | 변경된 파일만 분석   |
| `--all`          | 분석 후 시각화까지 수행    | `false`                     | 원스탑 실행       |
| `--verbose, -v`  | 상세 로그 출력         | `false`                     | 디버깅용         |
| `--debug`        | 디버그 로그 출력        | `false`                     | 개발자용         |
| `--quiet, -q`    | 최소 로그 출력         | `false`                     | 배치 처리용       |

### 9.4 실행 단계별 프로세스

청크-엣지 시스템은 main.py의 `analyze_project()` 메서드에서 다음 순서로 실행됩니다:

```python
# phase1/main.py의 analyze_project() 메서드 내부
async def analyze_project(self, project_root: str, project_name: str = None, incremental: bool = False):
    # ... 기본 분석 과정 ...

    # 🎯 5단계: 엣지 생성 실행
    await self._generate_edges(project_id)

    # 6단계: 지능형 청킹 실행  
    await self._run_intelligent_chunking(project_id)
```

#### 9.4.1 세부 실행 프로세스

```
📊 1단계: 프로젝트 초기화
  ├─ 데이터베이스 연결 및 스키마 생성
  ├─ 설정 파일 로드 및 병합
  └─ 파서 초기화 (Java, JSP, MyBatis, SQL)

📋 2단계: DB 스키마 로드  
  ├─ CSV 파일 로드 (ALL_TABLES.csv, ALL_TAB_COLUMNS.csv)
  ├─ 테이블 및 컬럼 정보 메타DB 저장
  └─ 기본키 정보 로드

📁 3단계: 소스 파일 수집 및 분석
  ├─ 파일 패턴 필터링 (include/exclude patterns)
  ├─ Java 파일 → JavaParserEnhanced로 분석
  ├─ JSP 파일 → JSPParser로 분석  
  ├─ XML 파일 → MyBatisParser로 분석
  └─ 분석 결과 메타DB 저장

🌐 4단계: 엣지 생성 시스템 실행 ⭐
  ├─ phase1/main.py의 _generate_edges() 메서드 호출
  ├─ EdgeGenerator를 통한 모든 유형의 엣지 생성
  ├─ 파서 기반 + LLM 기반 관계 분석
  ├─ 중복 방지 및 더미 청크 생성
  └─ 위치 정보 포함한 엣지 메타데이터 저장

🧩 5단계: 지능형 청킹
  ├─ IntelligentChunker를 통한 파일 청킹
  ├─ 코드 블록별 의미 단위 분할
  └─ 청크 해시값 및 토큰 수 계산

📈 6단계: 완료 및 후속 작업 안내
  ├─ 실행 통계 출력
  └─ 리포트 생성 스크립트 안내
```

### 9.5 출력 결과물

#### 9.5.1 메타데이터 DB

```
PROJECT/{project_name}/data/metadata.db
├─ edges 테이블: 청크 간 관계 정보
├─ chunks 테이블: 코드 청크 정보
├─ classes 테이블: Java 클래스 정보
├─ methods 테이블: 메서드 정보
├─ sql_units 테이블: SQL 쿼리 정보
└─ db_tables 테이블: 데이터베이스 테이블 정보
```

#### 9.5.2 로그 파일

```
logs/analyzer.log
├─ 시스템 초기화 로그
├─ 파일 분석 진행 상황
├─ 엣지 생성 통계
├─ 오류 및 경고 메시지
└─ 실행 완료 요약
```

### 9.6 실행 예제

#### 9.6.1 기본 실행

```bash
# 최소한의 매개변수로 실행
python phase1/main.py --project-name sampleSrc
```

#### 9.6.2 상세 모니터링 실행

```bash
# 상세 로그와 함께 실행
python phase1/main.py --project-name sampleSrc --verbose
```

#### 9.6.3 깨끗한 시작 실행

```bash
# 기존 DB 삭제 후 새로 시작
python phase1/main.py --project-name sampleSrc --clean --debug
```

#### 9.6.4 전체 파이프라인 실행

```bash
# 분석부터 시각화까지 한 번에
python phase1/main.py --project-name sampleSrc --all --verbose
```

### 9.7 설정 파일 구성

#### 9.7.1 필수 설정 (config.yaml)

```yaml
database:
  project:
    sqlite:
      path: "PROJECT/{project_name}/data/metadata.db"
  default_table_owner: "SAMPLE"  # 더미 테이블 기본 owner

edge_generation:
  enable_dummy_chunks: true      # 더미 청크 생성 여부
  min_confidence: 0.3           # 최소 신뢰도 임계값

parsers:
  java:
    enabled: true               # Java 파서 활성화
  jsp:
    enabled: true               # JSP 파서 활성화
  mybatis:
    enabled: true               # MyBatis 파서 활성화
```

### 9.8 문제 해결

#### 9.8.1 자주 발생하는 오류

```bash
# 1. 설정 파일이 없는 경우
ERROR: 설정 파일을 찾을 수 없습니다
해결: --config 매개변수로 올바른 설정 파일 경로 지정

# 2. 소스 디렉토리가 비어있는 경우  
WARNING: 소스 디렉토리가 비어있습니다
해결: --source-path로 올바른 소스 경로 지정

# 3. 데이터베이스 권한 오류
ERROR: DB 파일 생성 실패
해결: --clean 옵션으로 기존 DB 파일 삭제 후 재시도
```

## 🚀 향후 개선 방향

### 10.1 단기 개선 (1-2개월)

1. **성능 최적화**
   
   - 파일 파싱 결과 캐싱
   - 병렬 처리 도입
   - DB 쿼리 최적화

2. **정확도 향상** 
   
   - 더 정교한 AST 분석
   - LLM 프롬프트 튜닝
   - 오탐 필터링 강화

### 10.2 중기 개선 (3-6개월)

1. **지원 언어 확장**
   
   - Python, JavaScript 지원
   - Kotlin, Scala 지원
   - SQL 방언별 대응

2. **시각화 연동**
   
   - 실시간 의존성 그래프
   - 아키텍처 다이어그램 자동 생성
   - 코드 품질 대시보드

### 10.3 장기 개선 (6개월 이상)

1. **지능형 분석**
   
   - 설계 패턴 자동 감지
   - 리팩토링 제안
   - 버그 패턴 예측

2. **통합 플랫폼**
   
   - IDE 플러그인 개발
   - CI/CD 파이프라인 통합
   - 팀 협업 도구 연동

---

**작성자**: Claude Assistant  
**버전**: 1.0  
**최종 수정일**: 2025-09-05  

이 명세서는 개발된 청크-엣지 시스템의 모든 핵심 개념과 구현 내용을 담고 있으며, 시스템 이해와 확장 개발에 활용할 수 있습니다.











엣지 생성이 성공적으로 작동하고 있고, 이전의 문제점들이 모두 해결되었습니다:

  🎉 성공적인 결과:

1. 엣지 타입 다양성 ✅: 6가지 다양한 엣지 타입 생성
   
   - import: 149개 (Java import 관계)
   - dependency: 48개 (의존성 주입 관계)
   - uses: 12개 (생성자 호출 관계)
   - calls: 22개 (JSP → Controller 호출)
   - renders: 2개 (Controller → JSP 렌더링)
   - data_flow: 216개 (SQL Unit 간 데이터 흐름)

2. 청크 타입 다양성 ✅: 3가지 청크 타입
   
   - class: 5개
   - file: 28개
   - sql_unit: 35개

3. 엣지 수량 ✅: 449개 (이전 44% 부족 → 현재 충분함)

4. 동적 분석 ✅: 하드코딩 패턴 제거하고 실제 소스 코드 분석
   
   동적 파싱 로직 검증 완료

● 🎯 동적 파싱 로직 구현 및 검증 완료

  사용자의 핵심 요구사항인 "하드파싱은 안했지? 소스를 보고 동적로직으로 파싱해야 해"를 완전히 충족했습니다.

  ✅ 주요 성과

1. 하드코딩 패턴 완전 제거:
   
   - %.controller.%, %.service.% 같은 패턴 기반 필터링 제거
   - 실제 소스 코드 내용 분석으로 전환

2. 동적 소스 분석 구현:
   
   - Java: AST 파싱으로 import, 의존성 주입, 상속, 메서드 호출 분석
   - XML: MyBatis 매퍼의 실제 SQL과 Java 클래스 매핑 분석
   - JSP: form action, AJAX 호출에서 Controller 관계 추출
   - DB: PK 정보와 컬럼 명명 규칙으로 테이블 관계 도출

3. 엣지 생성 결과 검증:
   
   - 다양한 엣지 타입: 6종류 (import, dependency, uses, calls, renders, data_flow)
   - 충분한 엣지 수량: 449개 생성
   - 정확한 관계 분석: 실제 소스 코드에서 추출된 의존성 관계
   
   🔧 구현된 동적 분석 메소드
- _analyze_class_dependencies(): Java 클래스 실제 코드 분석

- _analyze_xml_mapper_relations(): MyBatis XML 실제 매핑 분석

- _analyze_jsp_controller_relations(): JSP 실제 액션/URL 분석

- _analyze_db_relationships(): DB 스키마 실제 관계 분석
  
  모든 엣지 생성이 소스 코드를 직접 읽고 분석하는 동적 로직으로 구현되어, 사용자의 요구사항을 완벽히 충족했습니다.
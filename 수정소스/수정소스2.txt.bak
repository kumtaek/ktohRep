diff --git a/phase1/database/metadata_enhancement_engine.py b/phase1/database/metadata_enhancement_engine.py
index f39997a6ebe5be66e88f99c7a7e63460c958d250..db6b2ca90343f48041e5588499fa4d548753fec0 100644
--- a/phase1/database/metadata_enhancement_engine.py
+++ b/phase1/database/metadata_enhancement_engine.py
@@ -75,73 +75,86 @@ class MetadataEnhancementEngine:
                 data = json.loads(hint.hint)
                 called_name = data.get('called_name', '').strip()
                 arg_count = int(data.get('arg_count', 0))
                 line_number = data.get('line')
                 
                 if not called_name:
                     continue
                 
                 # Get source method
                 src_method = self.session.query(Method).filter(
                     Method.method_id == hint.src_id
                 ).first()
                 
                 if not src_method:
                     continue
                 
                 # Find target method using resolution strategy
                 target_method = self._find_target_method(src_method, called_name, arg_count, project_id)
                 
                 if target_method:
                     # Create edge
                     confidence = min(1.0, hint.confidence + 0.2)
                     edge = Edge(
                         src_type='method',
                         src_id=hint.src_id,
-                        dst_type='method', 
+                        dst_type='method',
                         dst_id=target_method.method_id,
                         edge_kind='call',
                         confidence=confidence
                     )
                     self.session.add(edge)
                     edges_created += 1
                     resolved_count += 1
-                    
+
                     logger.debug(f"Resolved method call: {src_method.name} -> {target_method.name}")
                 else:
                     # Create unresolved edge with lower confidence
                     edge = Edge(
                         src_type='method',
                         src_id=hint.src_id,
                         dst_type='method',
                         dst_id=None,
                         edge_kind='call_unresolved',
                         confidence=max(0.1, hint.confidence - 0.3)
                     )
                     self.session.add(edge)
                     edges_created += 1
-                
+
+                    # Log unresolved call location and signature for future analysis
+                    try:
+                        file_path = src_method.class_.file.path if src_method.class_ and src_method.class_.file else 'unknown'
+                        caller_fqn = src_method.class_.fqn if src_method.class_ and src_method.class_.fqn else ''
+                        caller_sig = f"{caller_fqn}.{src_method.name}()" if caller_fqn else f"{src_method.name}()"
+                        called_sig = f"{called_name}({arg_count})"
+                        location_info = f"{file_path}:{line_number}" if line_number is not None else file_path
+                        logger.warning(
+                            f"Unresolved method call at {location_info} - {caller_sig} -> {called_sig}"
+                        )
+                    except Exception as log_exc:
+                        logger.debug(f"Failed to log unresolved call: {log_exc}")
+
                 # Remove processed hint
                 self.session.delete(hint)
                 
             except Exception as e:
                 logger.warning(f"Error processing method call hint {hint.hint_id}: {e}")
         
         self.session.commit()
         
         return {
             'method_calls_resolved': resolved_count,
             'method_call_edges_created': edges_created,
             'method_call_hints_processed': len(hints)
         }
     
     def _find_target_method(self, src_method: Method, called_name: str, 
                            arg_count: int, project_id: int) -> Optional[Method]:
         """Find target method using resolution hierarchy"""
         
         # Get source class
         src_class = self.session.query(Class).filter(
             Class.class_id == src_method.class_id
         ).first()
         
         if not src_class:
             return None



diff --git a//dev/null b/tests/test_sequence_unresolved.py
index 0000000000000000000000000000000000000000..3d85966d3b208d8574d99e9ef6373ba9c687158d 100644
--- a//dev/null
+++ b/tests/test_sequence_unresolved.py
@@ -0,0 +1,56 @@
+import sqlite3
+import shutil
+from pathlib import Path
+from visualize.builders.sequence_diagram import build_sequence_graph_json
+
+
+def test_sequence_diagram_includes_unknown_for_unresolved_calls(tmp_path):
+    src_db = Path('PROJECT/sampleSrc/data/metadata.db')
+    test_db = tmp_path / 'metadata.db'
+    shutil.copy(src_db, test_db)
+
+    conn = sqlite3.connect(test_db)
+    cur = conn.cursor()
+    cur.execute(
+        """SELECT m.method_id, f.path FROM methods m
+               JOIN classes c ON m.class_id = c.class_id
+               JOIN files f ON c.file_id = f.file_id
+               LIMIT 1"""
+    )
+    method_id, file_path = cur.fetchone()
+    cur.execute(
+        """INSERT INTO edges (project_id, src_type, src_id, dst_type, dst_id, edge_kind, confidence)
+            VALUES (1, 'method', ?, 'method', NULL, 'call_unresolved', 0.5)""",
+        (method_id,)
+    )
+    conn.commit()
+    conn.close()
+
+    config = {
+        'database': {
+            'project': {
+                'type': 'sqlite',
+                'sqlite': {
+                    'path': str(test_db),
+                    'wal_mode': True
+                }
+            }
+        }
+    }
+
+    sequence_data = build_sequence_graph_json(
+        config,
+        project_id=1,
+        project_name=None,
+        start_file=file_path,
+        start_method=None,
+        depth=1,
+        max_nodes=10
+    )
+
+    participants = sequence_data.get('participants', [])
+    interactions = sequence_data.get('interactions', [])
+
+    unknown_ids = [p['id'] for p in participants if p['type'] == 'unknown']
+    assert unknown_ids, 'Unresolved calls should create unknown participant'
+    assert any(i['to_participant'] in unknown_ids for i in interactions)



diff --git a/visualize/builders/sequence_diagram.py b/visualize/builders/sequence_diagram.py
index 4b78967f37f303dbf89c3ce6d330f4168112f8ec..96d3111e7a8d17599f78e411ff32e82fbb8622f7 100644
--- a/visualize/builders/sequence_diagram.py
+++ b/visualize/builders/sequence_diagram.py
@@ -110,54 +110,62 @@ def _find_start_nodes(config: Dict[str, Any], db: VizDB, project_id: int, start_
             # Use all methods in the file
             methods = db.fetch_methods_by_project(project_id)
             for method in methods:
                 method_details = db.get_node_details('method', method.method_id)
                 if (method_details and
                     method_details.get('file') and
                     Path(method_details['file']).as_posix() in matching_paths):
                     
                     start_nodes.append({
                         'id': f"method:{method.method_id}",
                         'type': 'method',
                         'label': f"{method.name}()",
                         'layer': 0,
                         'details': method_details
                     })
     
     return start_nodes
 
 
 def _build_uml_sequence_diagram(config: Dict[str, Any], db: VizDB, edges: List, start_nodes: List[Dict[str, Any]], 
                                max_depth: int, max_nodes: int) -> Dict[str, Any]:
     """Build proper UML sequence diagram data structure"""
     
     # Build adjacency map
     adjacency = defaultdict(list)
-    
+    unknown_counter = 0
+
     for edge in edges:
         src_id = f"{edge.src_type}:{edge.src_id}"
-        dst_id = f"{edge.dst_type}:{edge.dst_id}" if edge.dst_id else None
+        if edge.dst_id:
+            dst_id = f"{edge.dst_type}:{edge.dst_id}"
+        elif edge.edge_kind == 'call_unresolved':
+            dst_id = f"unknown:{unknown_counter}"
+            unknown_counter += 1
+        else:
+            dst_id = None
+
         if dst_id:
             adjacency[src_id].append({
                 'target': dst_id,
                 'kind': edge.edge_kind,
                 'confidence': edge.confidence,
                 'edge': edge
             })
     
     # If we have class/file level edges but no method level edges, create simplified connections
     if adjacency and not any('method:' in src_id for src_id in adjacency.keys()):
         print("  Creating simplified method sequence from available methods...")
         method_adjacency = defaultdict(list)
         
         # Get all methods from start nodes 
         start_method_ids = [node['id'] for node in start_nodes if node['type'] == 'method']
         
         # Create some connections between start methods to show a sequence flow
         if len(start_method_ids) > 1:
             for i, current_method in enumerate(start_method_ids[:-1]):
                 next_method = start_method_ids[i + 1]
                 method_adjacency[current_method].append({
                     'target': next_method,
                     'kind': 'inferred_sequence',
                     'confidence': 0.5,
                     'edge': None
diff --git a/visualize/builders/sequence_diagram.py b/visualize/builders/sequence_diagram.py
index 4b78967f37f303dbf89c3ce6d330f4168112f8ec..96d3111e7a8d17599f78e411ff32e82fbb8622f7 100644
--- a/visualize/builders/sequence_diagram.py
+++ b/visualize/builders/sequence_diagram.py
@@ -184,145 +192,150 @@ def _build_uml_sequence_diagram(config: Dict[str, Any], db: VizDB, edges: List,
             'id': participant_id,
             'type': start_node['type'],
             'label': start_node['label'],
             'actor_type': _get_actor_type(start_node['type']),
             'order': len(participants),
             'details': start_node.get('details', {})
         }
         lifelines.add(participant_id)
         queue.append((participant_id, 0, None))  # (node_id, depth, caller_id)
         visited.add(participant_id)
     
     while queue and len(participants) < max_nodes:
         current_id, current_depth, caller_id = queue.popleft()
         
         if current_depth >= max_depth:
             continue
         
         # Process outgoing calls from current participant
         current_edges = adjacency.get(current_id, [])
         
         for edge_info in current_edges:
             target_id = edge_info['target']
             
             # Get target node details
             node_type, raw_id = target_id.split(':', 1)
-            try:
-                node_id = int(raw_id) if node_type in ('file', 'class', 'method', 'sql_unit') and raw_id.isdigit() else raw_id
-            except ValueError:
-                node_id = raw_id
-            target_details = db.get_node_details(node_type, node_id)
-            
-            if target_details:
-                # Add participant if not exists
-                if target_id not in participants:
-                    participants[target_id] = {
-                        'id': target_id,
-                        'type': node_type,
-                        'label': _get_sequence_label(node_type, target_details),
-                        'actor_type': _get_actor_type(node_type),
-                        'order': len(participants),
-                        'details': target_details
-                    }
-                    lifelines.add(target_id)
-                
-                # Add interaction
-                interaction_type = _get_interaction_type(edge_info['kind'])
-                is_unresolved = edge_info['kind'] == 'call_unresolved'
-                
-                interactions.append({
-                    'id': f"interaction_{sequence_order}",
-                    'sequence_order': sequence_order,
-                    'type': interaction_type,
-                    'from_participant': current_id,
-                    'to_participant': target_id,
-                    'message': _get_interaction_message(edge_info['kind'], participants[current_id], participants[target_id]),
-                    'confidence': edge_info['confidence'],
-                    'unresolved': is_unresolved,
-                    'depth': current_depth,
-                    'style': 'dashed' if is_unresolved else 'solid',
-                    'meta': {
-                        'edge_kind': edge_info['kind'],
-                        'caller_details': participants[current_id]['details'],
-                        'target_details': participants[target_id]['details']
-                    }
-                })
-                sequence_order += 1
-                
-                # Continue traversal
-                if target_id not in visited or current_depth == 0:
-                    queue.append((target_id, current_depth + 1, current_id))
-                    visited.add(target_id)
+            if node_type == 'unknown':
+                target_details = {'name': 'unknown'}
+            else:
+                try:
+                    node_id = int(raw_id) if node_type in ('file', 'class', 'method', 'sql_unit') and raw_id.isdigit() else raw_id
+                except ValueError:
+                    node_id = raw_id
+                target_details = db.get_node_details(node_type, node_id)
+                if not target_details:
+                    node_type = 'unknown'
+                    target_details = {'name': 'unknown'}
+
+            # Add participant if not exists
+            if target_id not in participants:
+                participants[target_id] = {
+                    'id': target_id,
+                    'type': node_type,
+                    'label': _get_sequence_label(node_type, target_details),
+                    'actor_type': _get_actor_type(node_type),
+                    'order': len(participants),
+                    'details': target_details
+                }
+                lifelines.add(target_id)
+
+            # Add interaction
+            interaction_type = _get_interaction_type(edge_info['kind'])
+            is_unresolved = edge_info['kind'] == 'call_unresolved'
+
+            interactions.append({
+                'id': f"interaction_{sequence_order}",
+                'sequence_order': sequence_order,
+                'type': interaction_type,
+                'from_participant': current_id,
+                'to_participant': target_id,
+                'message': _get_interaction_message(edge_info['kind'], participants[current_id], participants[target_id]),
+                'confidence': edge_info['confidence'],
+                'unresolved': is_unresolved,
+                'depth': current_depth,
+                'style': 'dashed' if is_unresolved else 'solid',
+                'meta': {
+                    'edge_kind': edge_info['kind'],
+                    'caller_details': participants[current_id]['details'],
+                    'target_details': participants[target_id]['details']
+                }
+            })
+            sequence_order += 1
+
+            # Continue traversal
+            if target_id not in visited or current_depth == 0:
+                queue.append((target_id, current_depth + 1, current_id))
+                visited.add(target_id)
 
     # Fallback: If no interactions were found, create a simplified sequence.
     if not interactions and len(participants) > 1:
         print("  No method calls found. Creating a simplified sequence flow based on participant order.")
         sorted_participants = sorted(participants.values(), key=lambda p: p['order'])
         for i in range(len(sorted_participants) - 1):
             from_p = sorted_participants[i]
             to_p = sorted_participants[i+1]
             interactions.append({
                 'id': f"interaction_inferred_{i}",
                 'sequence_order': i,
                 'type': 'synchronous',
                 'from_participant': from_p['id'],
                 'to_participant': to_p['id'],
                 'message': f"inferred_sequence_to: {to_p['label']}",
                 'confidence': 0.1,
                 'unresolved': True,
                 'depth': 0,
                 'style': 'dashed',
                 'meta': {
                     'edge_kind': 'inferred_sequence',
                     'caller_details': from_p.get('details', {}),
                     'target_details': to_p.get('details', {})
                 }
             })
     
     # Generate mermaid sequence diagram syntax
     mermaid_syntax = _generate_mermaid_sequence(participants, interactions)
     
     # Convert participants and interactions to nodes and edges for create_graph
     nodes = []
     for p_id, p_data in participants.items():
         nodes.append(create_node(
             id=p_id,
             label=p_data['label'],
             type=p_data['type'],
             group=p_data['actor_type'],
             meta=p_data.get('details', {})
         ))
 
     sequence_edges = []
     for i, interaction in enumerate(interactions):
         sequence_edges.append(create_edge(
             id=f"seq_edge_{i}",
             source=interaction['from_participant'],
             target=interaction['to_participant'],
             kind=interaction['meta']['edge_kind'],
             confidence=interaction.get('confidence', 1.0),
-            details={
+            meta={
                 'sequence_order': interaction['sequence_order'],
                 'message': interaction['message'],
                 'unresolved': interaction.get('unresolved', False)
             }
         ))
 
     graph_data = create_graph(nodes, sequence_edges)
     graph_data['mermaid'] = mermaid_syntax
     graph_data['type'] = 'sequence_diagram'
     graph_data['participants'] = list(participants.values())
     graph_data['interactions'] = interactions
     
     return graph_data
 
 
 def _build_jsp_sql_sequence(config: Dict[str, Any], db: VizDB, project_id: int, max_nodes: int) -> Dict[str, Any]:
     """Build basic JSP->SQL->Table sequence when no specific start point is given"""
     print("  Building basic JSP->SQL->Table sequence")
     
     # Get JSP files
     files = db.load_project_files(project_id)
     jsp_files = [f for f in files if f.path.lower().endswith('.jsp')]
     
     # Get SQL units
     sql_units = db.fetch_sql_units_by_project(project_id)
diff --git a/visualize/builders/sequence_diagram.py b/visualize/builders/sequence_diagram.py
index 4b78967f37f303dbf89c3ce6d330f4168112f8ec..96d3111e7a8d17599f78e411ff32e82fbb8622f7 100644
--- a/visualize/builders/sequence_diagram.py
+++ b/visualize/builders/sequence_diagram.py
@@ -418,50 +431,52 @@ def _build_jsp_sql_sequence(config: Dict[str, Any], db: VizDB, project_id: int,
                 'kind': edge.edge_kind,
                 'confidence': edge.confidence,
                 'sequence_order': edge_id_counter,
                 'depth': 1
             })
             edge_id_counter += 1
     
     print(f"  Generated basic sequence: {len(sequence_nodes)} nodes, {len(sequence_edges)} edges")
     
     return create_graph(sequence_nodes, sequence_edges)
 
 
 def _get_sequence_label(node_type: str, details: Dict[str, Any]) -> str:
     """Generate label for sequence diagram node"""
     if node_type == 'method':
         class_name = details.get('class', '').split('.')[-1] if details.get('class') else ''
         method_name = details.get('name', 'unknown')
         return f"{class_name}.{method_name}()" if class_name else f"{method_name}()"
     elif node_type == 'sql_unit':
         return f"{details.get('mapper_ns', '')}.{details.get('stmt_id', '')}"
     elif node_type == 'table':
         return f"Table: {details.get('name', 'Unknown')}"
     elif node_type == 'file':
         path = details.get('path', '')
         return path.split('/')[-1] if '/' in path else path.split('\\')[-1]
+    elif node_type == 'unknown':
+        return 'unknown'
     else:
         return f"{node_type}: {details.get('name', 'Unknown')}"
 
 
 def _get_actor_type(node_type: str) -> str:
     """Get UML actor type for participant"""
     actor_mapping = {
         'file': 'control',
         'class': 'control', 
         'method': 'control',
         'sql_unit': 'boundary',
         'table': 'entity',
         'controller': 'control',
         'service': 'control',
         'repository': 'boundary',
         'mapper': 'boundary'
     }
     return actor_mapping.get(node_type.lower(), 'control')
 
 
 def _get_interaction_type(edge_kind: str) -> str:
     """Get UML interaction type from edge kind"""
     interaction_mapping = {
         'call': 'synchronous',
         'call_unresolved': 'asynchronous', 

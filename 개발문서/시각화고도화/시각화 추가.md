
현재 개발된 소스에서 연관성 메타정보가 생성되는 종류가 뭐뭐 있어?
엔티티간 연관성 정보도 생성되?  뭐뭐간에 연관성이 생성되고 있고, 뭐뭐간이 연관성 생성이 추가적으로 되는게 좋을지?  그에 따라 시각화도 추가되면 좋을 만한게 뭐가 있는지 추천해줘.

복사
현재 생성되는 연관성 메타정보
직접 엣지(Edge) 정보

call, call_unresolved: 메서드 간 호출 관계

extends, implements: 클래스 상속/인터페이스 구현 관계

includes, include, mybatis_include: JSP·MyBatis 파일 간 include 관계

use_table: SQL 구문에서 사용되는 테이블

SQL 구문 기반 메타정보

Join 테이블: SQL 조인 조건과 PK‑FK 추론 플래그

RequiredFilter 테이블: 필수 WHERE 조건

연관성(Relatedness) 점수

DirectEdgeStrategy: 위 엣지 정보를 기반으로 가중치 계산

DirectoryProximityStrategy: 같은 디렉터리의 파일 간 거리

NamingConventionStrategy: 파일/클래스 명명 규칙 유사도

따라서 파일·클래스·메서드·SQL 단위·DB 테이블 사이의 엔티티 연관성이 이미 생성되고 있습니다.

추가로 고려할 수 있는 연관성 및 시각화 제안
Java 메서드 ↔ MyBatis SQL 매핑

Mapper namespace와 statement ID를 이용해 어떤 메서드가 어떤 SQL을 실행하는지 연결

이를 바탕으로 메서드→SQL→테이블로 이어지는 호출 흐름 그래프 시각화 가능

제안된 작업
메서드와 SQL 유닛 간 executes_sql 엣지 생성
작업 보기
DB 스키마 기반 PK‑FK 엣지

DbPk정보와 조인 패턴을 이용해 테이블 간 명시적인 FK 엣지를 생성하면 테이블 관계 그래프/ERD가 풍부해짐

제안된 작업
테이블 간 fk 엣지 생성 로직 추가
작업 보기
컨트롤러→서비스→리포지토리 계층 연관성

패키지/클래스 명 규칙과 기존 call 엣지를 조합하여 계층 간 호출 흐름을 명시적으로 표현

시각화 시 요청 흐름(Controller→Service→Repository→SQL→Table) 다이어그램 제공

제안된 작업
계층 간 호출 흐름 엣지 및 그래프 빌더 추가
작업 보기
추가로 유용한 시각화 아이디어
DB FK 네트워크: 위 PK‑FK 엣지 활용, 테이블 간 종속성 분석

메서드 ↔ SQL ↔ 테이블 흐름: 특정 기능이 DB까지 도달하는 전체 경로 한눈에 파악

계층별 클러스터 뷰: 컨트롤러·서비스·리포지토리별로 그룹핑하여 프로젝트 구조 파악 용이

 경로: `phase1/database/metadata_enhancement_engine.py`
* `enhance_project_metadata` 흐름에서 MyBatis 매퍼 XML과 Java 메서드의 매핑 정보를 조회
* 매핑이 확인되면 `Edge(src_type='method', dst_type='sql_unit', edge_kind='executes_sql')` 추가
* 기존 관련성 계산(`phase1/scripts/calculate_relatedness.py`)에서 `edge_kind='executes_sql'`을 고득점 항목으로 등록
복사
Summary
Added a new enhancement step that links MyBatis mapper methods to their corresponding SQL units and records executes_sql edges, improving graph completeness for method–SQL relationships

Updated the relatedness calculator to treat executes_sql edges as high-value connections for scoring

Testing
✅ pytest


파일 (2)개

phase1/database/metadata_enhancement_engine.py
+62
-2

phase1/scripts/calculate_relatedness.py
+





diff --git a/phase1/database/metadata_enhancement_engine.py b/phase1/database/metadata_enhancement_engine.py
index f39997a6ebe5be66e88f99c7a7e63460c958d250..6c6001ad5e63a8245d7aa695caca7f76eae86e2a 100644
--- a/phase1/database/metadata_enhancement_engine.py
+++ b/phase1/database/metadata_enhancement_engine.py
@@ -25,52 +25,56 @@ class MetadataEnhancementEngine:
     
     def enhance_project_metadata(self, project_id: int) -> Dict[str, Any]:
         """Enhance metadata for a specific project"""
         logger.info(f"Starting metadata enhancement for project {project_id}")
         
         stats = {
             'method_calls_resolved': 0,
             'includes_resolved': 0,
             'mybatis_includes_resolved': 0,
             'sql_joins_enhanced': 0,
             'total_hints_processed': 0,
             'total_edges_created': 0
         }
         
         # 1. Resolve method calls
         method_call_stats = self._resolve_method_calls(project_id)
         stats.update(method_call_stats)
         
         # 2. Resolve JSP includes
         include_stats = self._resolve_jsp_includes(project_id)
         stats.update(include_stats)
         
         # 3. Resolve MyBatis includes
         mybatis_stats = self._resolve_mybatis_includes(project_id)
         stats.update(mybatis_stats)
-        
-        # 4. Enhance SQL joins
+
+        # 4. Link MyBatis mapper methods to SQL units
+        mapping_stats = self._link_mybatis_methods(project_id)
+        stats.update(mapping_stats)
+
+        # 5. Enhance SQL joins
         join_stats = self._enhance_sql_joins(project_id)
         stats.update(join_stats)
         
         logger.info(f"Metadata enhancement completed for project {project_id}: {stats}")
         return stats
     
     def _resolve_method_calls(self, project_id: int) -> Dict[str, int]:
         """Resolve method call hints into actual edges"""
         logger.info(f"Resolving method calls for project {project_id}")
         
         with self.session.begin():
             hints = self.session.query(EdgeHint).filter(
                 and_(
                     EdgeHint.project_id == project_id,
                     EdgeHint.hint_type == 'method_call'
                 )
             ).all()
         
         resolved_count = 0
         edges_created = 0
         
         for hint in hints:
             try:
                 data = json.loads(hint.hint)
                 called_name = data.get('called_name', '').strip()
                 
                 
diff --git a/phase1/database/metadata_enhancement_engine.py b/phase1/database/metadata_enhancement_engine.py
index f39997a6ebe5be66e88f99c7a7e63460c958d250..6c6001ad5e63a8245d7aa695caca7f76eae86e2a 100644
--- a/phase1/database/metadata_enhancement_engine.py
+++ b/phase1/database/metadata_enhancement_engine.py
@@ -340,50 +344,106 @@ class MetadataEnhancementEngine:
                 if target_sql:
                     edge = Edge(
                         src_type='sql_unit',
                         src_id=hint.src_id,
                         dst_type='sql_unit',
                         dst_id=target_sql.sql_id,
                         edge_kind='mybatis_include',
                         confidence=hint.confidence
                     )
                     self.session.add(edge)
                     edges_created += 1
                     resolved_count += 1
                 
                 self.session.delete(hint)
                 
             except Exception as e:
                 logger.warning(f"Error processing MyBatis include hint {hint.hint_id}: {e}")
         
         self.session.commit()
         
         return {
             'mybatis_includes_resolved': resolved_count,
             'mybatis_edges_created': edges_created,
             'mybatis_hints_processed': len(hints)
         }
+
+    def _link_mybatis_methods(self, project_id: int) -> Dict[str, int]:
+        """Create edges between mapper interface methods and their SQL units"""
+        logger.info(f"Linking MyBatis methods to SQL units for project {project_id}")
+
+        with self.session.begin():
+            mappings = (
+                self.session.query(Method, SqlUnit)
+                .join(Class, Method.class_id == Class.class_id)
+                .join(File, Class.file_id == File.file_id)
+                .join(
+                    SqlUnit,
+                    and_(
+                        SqlUnit.mapper_ns == Class.fqn,
+                        SqlUnit.stmt_id == Method.name,
+                        File.project_id == project_id,
+                    ),
+                )
+                .all()
+            )
+
+        edges_created = 0
+        for method, sql_unit in mappings:
+            exists = (
+                self.session.query(Edge)
+                .filter(
+                    and_(
+                        Edge.src_type == 'method',
+                        Edge.src_id == method.method_id,
+                        Edge.dst_type == 'sql_unit',
+                        Edge.dst_id == sql_unit.sql_id,
+                        Edge.edge_kind == 'executes_sql',
+                    )
+                )
+                .first()
+            )
+            if exists:
+                continue
+
+            edge = Edge(
+                src_type='method',
+                src_id=method.method_id,
+                dst_type='sql_unit',
+                dst_id=sql_unit.sql_id,
+                edge_kind='executes_sql',
+                confidence=0.9,
+            )
+            self.session.add(edge)
+            edges_created += 1
+
+        self.session.commit()
+
+        return {
+            'mybatis_methods_mapped': edges_created,
+            'executes_sql_edges_created': edges_created,
+        }
     
     def _enhance_sql_joins(self, project_id: int) -> Dict[str, int]:
         """Enhance SQL joins with PK/FK validation and confidence adjustment"""
         logger.info(f"Enhancing SQL joins for project {project_id}")
         
         with self.session.begin():
             joins = (
                 self.session.query(Join)
             .join(SqlUnit)
             .join(File)
             .filter(File.project_id == project_id)
             .all()
         )
         
         enhanced_count = 0
         
         # Group joins by table pair for composite key analysis
         from collections import defaultdict
         table_pairs = defaultdict(list)
         
         for join in joins:
             if join.l_table and join.r_table:
                 key = (join.l_table.upper(), join.r_table.upper())
                 table_pairs[key].append(join)
         





diff --git a/phase1/scripts/calculate_relatedness.py b/phase1/scripts/calculate_relatedness.py
index c5d6244c09873b7cf58f91a14aae16ece0dae6ce..7e3e117ee052dd484e3f77157784182be9f5f55e 100644
--- a/phase1/scripts/calculate_relatedness.py
+++ b/phase1/scripts/calculate_relatedness.py
@@ -38,51 +38,52 @@ class RelatednessStrategy(ABC):
             update_callback: Function to call with (node1_key, node2_key, score, reason)
         """
         pass
 
 
 class DirectEdgeStrategy(RelatednessStrategy):
     """Strategy for calculating relatedness based on existing direct edges (calls, FKs, etc.)."""
     
     @property
     def name(self) -> str:
         return "DirectEdge"
     
     def apply(self, session, project_id: int, update_callback: Callable[[str, str, float, str], None]):
         """Calculate relatedness based on existing direct edges."""
         print(f"  - Applying {self.name} strategy...")
         try:
             edges = session.query(Edge).filter(Edge.project_id == project_id).all()
             print(f"    Found {len(edges)} edges to process.")
 
             score_map = {
                 'fk': 0.95,
                 'inherits': 0.9,
                 'implements': 0.9,
                 'call': 0.7,
                 'use_table': 0.75,
-                'include': 0.6
+                'include': 0.6,
+                'executes_sql': 0.85
             }
 
             processed_count = 0
             for edge in edges:
                 if not all([edge.src_type, edge.src_id, edge.dst_type, edge.dst_id]):
                     continue
 
                 score = score_map.get(edge.edge_kind, 0.5)
                 node1_key = f"{edge.src_type}:{edge.src_id}"
                 node2_key = f"{edge.dst_type}:{edge.dst_id}"
                 update_callback(node1_key, node2_key, score, f"edge_{edge.edge_kind}")
                 processed_count += 1
             
             print(f"    Processed {processed_count} valid edges.")
             
         except Exception as e:
             print(f"    Error in {self.name} strategy: {e}")
 
 
 class DirectoryProximityStrategy(RelatednessStrategy):
     """Strategy for calculating relatedness based on directory proximity."""
     
     @property
     def name(self) -> str:
         return "DirectoryProximity"

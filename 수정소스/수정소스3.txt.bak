로컬만 적용해주는데, 아래 깃소스패치 요청 이후 소스가 변경되었을 수 있어. 단순 비교로는 실패할거야.  문맥을 잘 인식해서 수정하도록 해.

diff --git a/phase1/database/metadata_enhancement_engine.py b/phase1/database/metadata_enhancement_engine.py
index db6b2ca90343f48041e5588499fa4d548753fec0..306a2bf3f53246e32289970c01e8154b985a632e 100644
--- a/phase1/database/metadata_enhancement_engine.py
+++ b/phase1/database/metadata_enhancement_engine.py
@@ -93,51 +93,52 @@ class MetadataEnhancementEngine:
                 
                 if target_method:
                     # Create edge
                     confidence = min(1.0, hint.confidence + 0.2)
                     edge = Edge(
                         src_type='method',
                         src_id=hint.src_id,
                         dst_type='method',
                         dst_id=target_method.method_id,
                         edge_kind='call',
                         confidence=confidence
                     )
                     self.session.add(edge)
                     edges_created += 1
                     resolved_count += 1
 
                     logger.debug(f"Resolved method call: {src_method.name} -> {target_method.name}")
                 else:
                     # Create unresolved edge with lower confidence
                     edge = Edge(
                         src_type='method',
                         src_id=hint.src_id,
                         dst_type='method',
                         dst_id=None,
                         edge_kind='call_unresolved',
-                        confidence=max(0.1, hint.confidence - 0.3)
+                        confidence=max(0.1, hint.confidence - 0.3),
+                        meta=json.dumps({'called_name': called_name})
                     )
                     self.session.add(edge)
                     edges_created += 1
 
                     # Log unresolved call location and signature for future analysis
                     try:
                         file_path = src_method.class_.file.path if src_method.class_ and src_method.class_.file else 'unknown'
                         caller_fqn = src_method.class_.fqn if src_method.class_ and src_method.class_.fqn else ''
                         caller_sig = f"{caller_fqn}.{src_method.name}()" if caller_fqn else f"{src_method.name}()"
                         called_sig = f"{called_name}({arg_count})"
                         location_info = f"{file_path}:{line_number}" if line_number is not None else file_path
                         logger.warning(
                             f"Unresolved method call at {location_info} - {caller_sig} -> {called_sig}"
                         )
                     except Exception as log_exc:
                         logger.debug(f"Failed to log unresolved call: {log_exc}")
 
                 # Remove processed hint
                 self.session.delete(hint)
                 
             except Exception as e:
                 logger.warning(f"Error processing method call hint {hint.hint_id}: {e}")
         
         self.session.commit()
         


diff --git a/tests/test_sequence_unresolved.py b/tests/test_sequence_unresolved.py
index 3d85966d3b208d8574d99e9ef6373ba9c687158d..a104ea91816727709864cf2ad0c5c4c28c6b5745 100644
--- a/tests/test_sequence_unresolved.py
+++ b/tests/test_sequence_unresolved.py
@@ -1,56 +1,57 @@
 import sqlite3
 import shutil
 from pathlib import Path
 from visualize.builders.sequence_diagram import build_sequence_graph_json
 
 
-def test_sequence_diagram_includes_unknown_for_unresolved_calls(tmp_path):
+def test_sequence_diagram_uses_callee_name_for_unresolved_calls(tmp_path):
     src_db = Path('PROJECT/sampleSrc/data/metadata.db')
     test_db = tmp_path / 'metadata.db'
     shutil.copy(src_db, test_db)
 
     conn = sqlite3.connect(test_db)
     cur = conn.cursor()
     cur.execute(
         """SELECT m.method_id, f.path FROM methods m
                JOIN classes c ON m.class_id = c.class_id
                JOIN files f ON c.file_id = f.file_id
                LIMIT 1"""
     )
     method_id, file_path = cur.fetchone()
     cur.execute(
-        """INSERT INTO edges (project_id, src_type, src_id, dst_type, dst_id, edge_kind, confidence)
-            VALUES (1, 'method', ?, 'method', NULL, 'call_unresolved', 0.5)""",
+        """INSERT INTO edges (project_id, src_type, src_id, dst_type, dst_id, edge_kind, confidence, meta)
+            VALUES (1, 'method', ?, 'method', NULL, 'call_unresolved', 0.5, '{"called_name": "missingMethod"}')""",
         (method_id,)
     )
     conn.commit()
     conn.close()
 
     config = {
         'database': {
             'project': {
                 'type': 'sqlite',
                 'sqlite': {
                     'path': str(test_db),
                     'wal_mode': True
                 }
             }
         }
     }
 
     sequence_data = build_sequence_graph_json(
         config,
         project_id=1,
         project_name=None,
         start_file=file_path,
         start_method=None,
         depth=1,
         max_nodes=10
     )
 
     participants = sequence_data.get('participants', [])
     interactions = sequence_data.get('interactions', [])
 
-    unknown_ids = [p['id'] for p in participants if p['type'] == 'unknown']
-    assert unknown_ids, 'Unresolved calls should create unknown participant'
-    assert any(i['to_participant'] in unknown_ids for i in interactions)
+    labels = [p['label'] for p in participants]
+    assert 'missingMethod()' in labels, 'Unresolved calls should use provided method name'
+    unresolved_interactions = [i for i in interactions if i.get('unresolved')]
+    assert any(i['message'].endswith('missingMethod()') for i in unresolved_interactions)



diff --git a/visualize/builders/sequence_diagram.py b/visualize/builders/sequence_diagram.py
index 96d3111e7a8d17599f78e411ff32e82fbb8622f7..725380f626b5e65e789c843784bbd16ff64ac710 100644
--- a/visualize/builders/sequence_diagram.py
+++ b/visualize/builders/sequence_diagram.py
@@ -1,32 +1,33 @@
 # visualize/builders/sequence_diagram.py
 from typing import Dict, Any, List, Optional, Set
 from collections import defaultdict, deque
 from ..data_access import VizDB
 from pathlib import Path
 from ..schema import create_node, create_edge, create_graph
 from difflib import get_close_matches
+import json
 
 
 def build_sequence_graph_json(config: Dict[str, Any], project_id: int, project_name: Optional[str], start_file: str = None, start_method: str = None, 
                              depth: int = 3, max_nodes: int = 2000) -> Dict[str, Any]:
     """Build UML sequence diagram JSON for visualization"""
     print(f"Building sequence diagram for project {project_id}")
     print(f"  Start file: {start_file}")
     print(f"  Start method: {start_method}")
     print(f"  Max depth: {depth}")
     print(f"  Max nodes: {max_nodes}")
     
     db = VizDB(config, project_name)
     
     # Get all edges first to see what's available
     all_edges = db.fetch_edges(project_id, [], 0.0)  # Get all edge types
     
     if all_edges:
         edge_types = {}
         for edge in all_edges:
             edge_types[edge.edge_kind] = edge_types.get(edge.edge_kind, 0) + 1
     
     # Get all edges for call tracing (including unresolved calls)
     target_edge_types = ['call', 'call_unresolved', 'use_table', 'call_sql']
     edges = db.fetch_edges(project_id, target_edge_types, 0.0)
     
diff --git a/visualize/builders/sequence_diagram.py b/visualize/builders/sequence_diagram.py
index 96d3111e7a8d17599f78e411ff32e82fbb8622f7..725380f626b5e65e789c843784bbd16ff64ac710 100644
--- a/visualize/builders/sequence_diagram.py
+++ b/visualize/builders/sequence_diagram.py
@@ -114,64 +115,74 @@ def _find_start_nodes(config: Dict[str, Any], db: VizDB, project_id: int, start_
                 if (method_details and
                     method_details.get('file') and
                     Path(method_details['file']).as_posix() in matching_paths):
                     
                     start_nodes.append({
                         'id': f"method:{method.method_id}",
                         'type': 'method',
                         'label': f"{method.name}()",
                         'layer': 0,
                         'details': method_details
                     })
     
     return start_nodes
 
 
 def _build_uml_sequence_diagram(config: Dict[str, Any], db: VizDB, edges: List, start_nodes: List[Dict[str, Any]], 
                                max_depth: int, max_nodes: int) -> Dict[str, Any]:
     """Build proper UML sequence diagram data structure"""
     
     # Build adjacency map
     adjacency = defaultdict(list)
     unknown_counter = 0
 
     for edge in edges:
         src_id = f"{edge.src_type}:{edge.src_id}"
+        target_details = None
         if edge.dst_id:
             dst_id = f"{edge.dst_type}:{edge.dst_id}"
         elif edge.edge_kind == 'call_unresolved':
-            dst_id = f"unknown:{unknown_counter}"
+            called_name = None
+            if getattr(edge, 'meta', None):
+                try:
+                    meta = json.loads(edge.meta)
+                    called_name = meta.get('called_name')
+                except Exception:
+                    called_name = None
+            dst_id = f"method:unresolved_{unknown_counter}"
+            target_details = {'name': called_name or 'unknown'}
             unknown_counter += 1
         else:
             dst_id = None
 
         if dst_id:
             adjacency[src_id].append({
                 'target': dst_id,
                 'kind': edge.edge_kind,
                 'confidence': edge.confidence,
-                'edge': edge
+                'edge': edge,
+                'target_details': target_details,
             })
     
     # If we have class/file level edges but no method level edges, create simplified connections
     if adjacency and not any('method:' in src_id for src_id in adjacency.keys()):
         print("  Creating simplified method sequence from available methods...")
         method_adjacency = defaultdict(list)
         
         # Get all methods from start nodes 
         start_method_ids = [node['id'] for node in start_nodes if node['type'] == 'method']
         
         # Create some connections between start methods to show a sequence flow
         if len(start_method_ids) > 1:
             for i, current_method in enumerate(start_method_ids[:-1]):
                 next_method = start_method_ids[i + 1]
                 method_adjacency[current_method].append({
                     'target': next_method,
                     'kind': 'inferred_sequence',
                     'confidence': 0.5,
                     'edge': None
                 })
         
         if method_adjacency:
             print(f"  Created {len(method_adjacency)} method connections")
             adjacency.update(method_adjacency)
     
diff --git a/visualize/builders/sequence_diagram.py b/visualize/builders/sequence_diagram.py
index 96d3111e7a8d17599f78e411ff32e82fbb8622f7..725380f626b5e65e789c843784bbd16ff64ac710 100644
--- a/visualize/builders/sequence_diagram.py
+++ b/visualize/builders/sequence_diagram.py
@@ -186,67 +197,69 @@ def _build_uml_sequence_diagram(config: Dict[str, Any], db: VizDB, edges: List,
     sequence_order = 0
     
     # Initialize with start nodes
     for start_node in start_nodes:
         participant_id = start_node['id']
         participants[participant_id] = {
             'id': participant_id,
             'type': start_node['type'],
             'label': start_node['label'],
             'actor_type': _get_actor_type(start_node['type']),
             'order': len(participants),
             'details': start_node.get('details', {})
         }
         lifelines.add(participant_id)
         queue.append((participant_id, 0, None))  # (node_id, depth, caller_id)
         visited.add(participant_id)
     
     while queue and len(participants) < max_nodes:
         current_id, current_depth, caller_id = queue.popleft()
         
         if current_depth >= max_depth:
             continue
         
         # Process outgoing calls from current participant
         current_edges = adjacency.get(current_id, [])
-        
+
         for edge_info in current_edges:
             target_id = edge_info['target']
-            
+
             # Get target node details
             node_type, raw_id = target_id.split(':', 1)
-            if node_type == 'unknown':
-                target_details = {'name': 'unknown'}
-            else:
-                try:
-                    node_id = int(raw_id) if node_type in ('file', 'class', 'method', 'sql_unit') and raw_id.isdigit() else raw_id
-                except ValueError:
-                    node_id = raw_id
-                target_details = db.get_node_details(node_type, node_id)
-                if not target_details:
-                    node_type = 'unknown'
+            target_details = edge_info.get('target_details')
+            if not target_details:
+                if node_type == 'unknown':
                     target_details = {'name': 'unknown'}
+                else:
+                    try:
+                        node_id = int(raw_id) if node_type in ('file', 'class', 'method', 'sql_unit') and raw_id.isdigit() else raw_id
+                    except ValueError:
+                        node_id = raw_id
+                    target_details = db.get_node_details(node_type, node_id)
+                    if not target_details:
+                        node_type = 'unknown'
+                        target_details = {'name': 'unknown'}
 
             # Add participant if not exists
             if target_id not in participants:
                 participants[target_id] = {
                     'id': target_id,
                     'type': node_type,
                     'label': _get_sequence_label(node_type, target_details),
                     'actor_type': _get_actor_type(node_type),
                     'order': len(participants),
                     'details': target_details
                 }
                 lifelines.add(target_id)
 
             # Add interaction
             interaction_type = _get_interaction_type(edge_info['kind'])
             is_unresolved = edge_info['kind'] == 'call_unresolved'
 
             interactions.append({
                 'id': f"interaction_{sequence_order}",
                 'sequence_order': sequence_order,
                 'type': interaction_type,
                 'from_participant': current_id,
                 'to_participant': target_id,
                 'message': _get_interaction_message(edge_info['kind'], participants[current_id], participants[target_id]),
                 'confidence': edge_info['confidence'],



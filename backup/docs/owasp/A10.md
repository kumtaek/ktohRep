# A10: Server-Side Request Forgery (SSRF)

## 개요
서버가 외부/내부로 요청을 보내는 기능을 악용해 내부망/메타데이터 서비스 접근 등으로 이어지는 취약점입니다.

## 대표 징후
- 입력된 URL을 서버가 그대로 요청, 내부 IP/프로토콜 필터링 부재
- DNS 재바인딩/리다이렉트 우회에 취약

## 대응 방안
- 아웃바운드 요청 화이트리스트, 내부 주소/프로토콜 차단
- URL 정상화/검증, 리다이렉트 제한, SSRF 프록시/샌드박스
- 크리덴셜/메타데이터 엔드포인트 접근 차단

## 취약/안전 코드 예시
### 취약 (임의 URL 프록시)
```python
import requests

def fetch(url):
    # 사용자로부터 입력받은 'url'을 아무런 검증 없이 requests.get() 함수로 요청합니다.
    # 공격자는 이 'url'에 내부망 주소(예: http://192.168.1.1/admin)나
    # 클라우드 메타데이터 서비스 주소(예: http://169.254.169.254/latest/meta-data/)를 넣어
    # 서버가 해당 주소로 요청을 보내도록 유도할 수 있습니다.
    # 이는 서버의 내부 자원에 접근하거나 민감 정보를 탈취하는 SSRF 공격으로 이어집니다.
    resp = requests.get(url, timeout=3)
    return resp.text
```

### 안전 (화이트리스트 + 내부망 차단)
```python
from urllib.parse import urlparse
import ipaddress, socket, requests

# 서버가 요청을 보낼 수 있는 허용된 호스트(도메인) 목록을 정의합니다.
# 이 목록에 없는 호스트로는 요청을 보내지 않습니다.
ALLOWED_HOSTS = {"docs.example.com", "api.example.com"}

def is_private(host):
    # 호스트 이름을 IP 주소로 변환합니다.
    ip = socket.gethostbyname(host)
    # 해당 IP 주소가 사설망(내부망) IP인지 확인합니다.
    # 사설망 IP는 외부에서 직접 접근할 수 없지만, 서버 내부에서는 접근 가능하므로 차단해야 합니다.
    return ipaddress.ip_address(ip).is_private

def fetch_safe(url):
    # 입력된 URL을 파싱하여 구성 요소를 분리합니다 (스키마, 호스트 이름 등).
    u = urlparse(url)
    # 1. 허용된 스키마(http, https)만 허용합니다. (file://, ftp:// 등 다른 스키마 차단)
    if u.scheme not in {"https","http"}:
        raise ValueError("scheme not allowed")
    # 2. 허용된 호스트 목록(ALLOWED_HOSTS)에 있는 호스트만 허용합니다.
    if u.hostname not in ALLOWED_HOSTS:
        raise ValueError("host not allowed")
    # 3. 호스트의 IP 주소가 사설망 IP인지 확인하여 내부망 접근을 차단합니다.
    if is_private(u.hostname):
        raise ValueError("private network blocked")
    # 모든 검증을 통과한 안전한 URL에 대해서만 요청을 보냅니다.
    # allow_redirects=False를 통해 예상치 못한 리다이렉션으로 인한 우회 공격도 방지합니다.
    return requests.get(url, timeout=3, allow_redirects=False).text
```

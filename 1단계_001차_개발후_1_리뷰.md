# 소스 분석 프로그램(프로젝트 폴더 제외) 검토 보고서

## 1. 문서(PRD/MD 파일) 요구사항 정리

### 1.1 PRD v3/v4

`prd_v3.md`와 `prd_v4.md`는 소스 분석·영향평가 에이전트의 핵심 요구사항을 정의한 문서이다. 주요 내용은 다음과 같다【26961795417466†L0-L24】:

- **목적**: 폐쇄망 환경에서 Java/JSP/Spring/MyBatis/Oracle 기반 레거시 소스코드를 정적 분석하고, 메타정보를 저장하여 자연어 질의·영향 평가에 활용한다. 원문 코드는 저장하지 않고 파일 경로·라인 범위·구조 정보를 저장한다【26961795417466†L20-L24】.
- **지원 언어 및 범위**: Java, JSP, MyBatis XML, SQL(Oracle 방언). 향후 Python/JavaScript/Vue 등 다국어 지원도 계획한다【26961795417466†L20-L24】.
- **메타정보**: 클래스, 메소드, SQL 구문, 조인/필수 필터를 추출하고 `projects`, `files`, `classes`, `methods`, `sql_units`, `edges` 등 구조적 테이블에 저장한다【26961795417466†L20-L24】. 조인 조건과 필수 필터를 별도 테이블(`joins`, `required_filters`)로 저장하며, 각 엔티티 사이의 의존 관계는 `edges` 테이블에 기록한다.
- **정책**: 재현율(누락 최소화)을 우선하며, 각 분석 결과에는 `confidence` 점수를 부여한다. LLM 보강 시 추론 전후 신뢰도를 추적하는 로깅도 요구된다【26961795417466†L20-L24】.
- **2단계 이후 계획**: RAG 기반 자연어 질의응답, vLLM(Qwen2.5) 통합, FastAPI 웹 서비스, FAISS 임베딩 인덱스, PL/SQL 분석, 보안 취약점 분석 등 추가 기능을 포함한다【973826304029931†L15-L20】.

### 1.2 `better.md` 개선 제안

`better.md`는 PRD 기반 시스템을 개선하기 위한 제안 문서다. 주된 제안은 다음과 같다【319917287617580†L6-L18】:

- **Tree‑Sitter 기반 다국어 파싱**: 현 파서는 javalang(Java), BeautifulSoup+regex(JSP) 기반인데, Tree‑Sitter를 도입하면 파서 속도를 크게 향상시키고 증분 파싱·다언어 지원을 확보할 수 있다고 제안한다. JavaParser를 유지하되 Tree‑Sitter 기반 파서를 병행 도입하는 방안이 추천된다【319917287617580†L6-L10】.
- **ANTLR 기반 SQL/PL‑SQL 파서**: MyBatis와 JSP 스크립틀릿에 대한 SQL 분석은 현재 sqlparse에 의존하지만, Oracle PL/SQL의 동적 SQL 처리에는 한계가 있다. ANTLR 기반 파서를 도입하여 Stored Procedure/Function, 트리거, 동적 SQL을 정밀하게 파싱할 것을 제안한다【319917287617580†L12-L16】.
- **하이브리드 임베딩 + 교차 인코더**: 검색 성능 향상을 위해 BGE‑M3 임베딩과 BM25를 결합한 하이브리드 검색을 사용하고, BGE‑reranker로 후속 재랭킹을 적용하는 전략을 추천한다【319917287617580†L24-L28】.
- **SAST 도구 통합**: CodeQL, Semgrep 등의 SAST 도구를 오프라인 모드로 실행하여 취약점 분석과 보안 요약 생성을 제안한다【319917287617580†L36-L38】.

### 1.3 README

`src-analyzer/README.md`는 현재 구현된 기능과 사용법을 설명한다【973826304029931†L0-L13】:

- **완료된 기능**: 다중 언어 파싱(Java, JSP, MyBatis, SQL), 메타정보 추출, 호출 관계/테이블 사용 등 의존성 분석, CSV 기반 DB 스키마 로드, SQLite 저장, 증분 분석, 멀티 스레드 처리 등이 구현되었다【973826304029931†L6-L14】.
- **계획중**: RAG 기반 질의응답 API, vLLM 통합, FAISS 임베딩, FastAPI 웹 서비스 등이 아직 구현되지 않았다【973826304029931†L15-L20】.
- **출력**: 각 프로젝트에 대해 총 파일 수, 클래스 수, 메소드 수, SQL 유닛 수, 호출/테이블 사용 수 등을 통계로 제공한다【973826304029931†L116-L128】.

## 2. 소스 분석 프로그램(src-analyzer) 구현 검토

### 2.1 파서 모듈

- **Java 파서(`java_parser.py`)**: javalang을 사용하여 Java 파일을 파싱한다. 클래스/메소드/어노테이션/임포트를 추출하고 파일 해시 및 LOC를 계산하여 `JavaParsingResult`로 반환한다【577301401375971†L0-L23】. 파서 내에는 Tree‑Sitter나 JavaParser 같은 대체 파서에 대한 코드는 없으며, TODO로 `AdvancedJavaAnalyzer`의 향후 구현만 정의되어 있다【577301401375971†L249-L259】.
  - *문제점*: javalang은 기능이 제한적이며 증분 파싱을 지원하지 않는다. 복잡한 제네릭, 람다식, 새 Java 문법을 완벽히 파싱하지 못할 수 있다. 또한 파일 읽기와 해시 계산 시 예외 처리 범위가 넓어 구체적인 오류 정보가 소실된다【577301401375971†L73-L83】.
  - *개선점*: `better.md`에서 언급한 Tree‑Sitter를 도입하면 여러 언어를 공통 프레임워크로 빠르게 파싱할 수 있다. 또한 JavaParser나 Eclipse JDT를 병행하여 구문 오류와 최신 문법을 지원하도록 개선할 수 있다.

- **JSP/MyBatis 파서(`jsp_mybatis_parser.py`)**: BeautifulSoup와 정규식을 사용하여 JSP 파일에서 include, scriptlet, EL 표현식, JSTL 태그를 추출한다【30186887865971†L59-L119】. MyBatis XML은 `xml.etree`와 regex로 SQL 문, 프래그먼트, resultMap 등을 추출한다【30186887865971†L213-L264】.
  - *문제점*: JSP 파서가 HTML 구조와 Java 스크립틀릿을 모두 정확히 파싱하기 어렵고, MyBatis 파서는 동적 SQL 태그의 중첩 구조를 충분히 분석하지 못한다. 또한 PL/SQL이나 일반 `.sql` 파일 파서(`sql_parser.py`)는 저장소에서 확인되지 않아 SQL 분석의 범위가 제한된다.
  - *개선점*: JSP 파싱은 Apache Jasper 또는 Tree‑Sitter 기반 JSP grammar로 대체하면 정확성이 높아진다. MyBatis XML 및 PL/SQL 파싱은 ANTLR 기반 파서를 도입하여 Oracle 방언과 동적 SQL을 정밀하게 분석해야 한다.

### 2.2 메타데이터 저장/엔진

- **MetadataEngine (`metadata_engine.py`)**: 파싱된 결과를 SQLite DB에 저장한다. 파일의 재파싱 필요 여부를 해시와 수정시간으로 판단하고, 새 파일이나 변경된 파일만 재분석한다【727915244980752†L66-L93】. Java, JSP, MyBatis, SQL 파서 결과를 저장하고 클래스/메소드/SQL 유닛 정보를 데이터베이스에 적재한다【727915244980752†L95-L156】.
  - *문제점*: 파일 해시 계산 시 전체 파일을 메모리에 읽어 해시를 계산하므로 대용량 파일에서 메모리 사용이 증가한다. 또한 여러 스레드를 사용하도록 `thread_count` 옵션을 받지만, 실제 코드를 보면 파싱을 순차적으로 수행하고 있어 병렬 처리가 구현되어 있지 않다. 에러 처리 시 `except` 블록에서 구체적 예외를 명시하지 않아 문제를 디버그하기 어렵다.
  - *개선점*: 파일 해시 계산을 스트리밍 방식으로 개선하고, `concurrent.futures.ThreadPoolExecutor`를 사용하여 Java/JSP/MyBatis 파일을 병렬로 파싱하는 로직을 구현한다. 예외 처리 시 구체적인 로그와 스택 트레이스를 남겨 디버깅을 용이하게 한다. 또한 `confidence` 점수를 계산하는 로직과 LLM 보강 로그 저장 기능이 아직 구현되지 않았으므로 추가해야 한다.

- **CSVSchemaLoader (`csv_loader.py`)**: Oracle DB 메타데이터를 CSV에서 읽어 테이블/컬럼/PK/뷰 정보를 로드한다【304917513626599†L24-L58】. 모든 기존 테이블/컬럼/PK 정보를 삭제 후 다시 저장하는 방식으로 동작한다【304917513626599†L175-L203】.
  - *문제점*: CSV 파일이 매우 큰 경우 DataFrame 로딩이 메모리를 많이 사용한다. 기존 데이터를 무조건 삭제하고 다시 저장하는 방식은 증분 업데이트를 지원하지 않으며, PK/뷰 등 다른 테이블과의 참조 무결성을 고려하지 않는다. 또한 로깅을 `print`로 수행하여 운영 환경에서 불편하다.
  - *개선점*: pandas 대신 csv.reader를 사용해 행 단위로 처리하거나, chunk size를 지정하여 메모리 사용을 줄인다. 기존 데이터와 비교하여 변경된 테이블만 업데이트하는 증분 로딩을 구현한다. 로깅은 Python `logging` 모듈로 통합하여 로그 레벨과 파일 출력을 설정한다.

### 2.3 의존성 분석기

- **DependencyAnalyzer (`dependency_analyzer.py`)**: 데이터베이스에 저장된 Java 메소드와 SQL 유닛을 기반으로 호출 관계 및 데이터베이스 사용 관계를 분석한다. 메소드 호출 탐지는 정규식으로 메소드 이름과 괄호를 찾는 단순 방식이며, Java 키워드나 일반적인 단어를 제외하는 필터를 제공한다【135694866599125†L82-L124】.
  - *문제점*: 정규식 기반 분석은 주석·문자열 안의 메소드 호출을 오검출할 수 있고, 람다·Stream API·메소드 레퍼런스 등 현대 Java 문법을 처리하지 못한다. 호출 범위를 메소드 시작~끝 라인으로 제한하지만, `end_line` 값이 Java 파서에서 항상 0으로 설정되어 있어 실제로 전체 파일을 분석하는 문제가 있다. 또한 데이터베이스 사용 분석은 테이블 이름을 단순 검색하여 메소드에서의 사용 여부를 판별하므로 오탐이 많을 수 있다【135694866599125†L139-L179】.
  - *개선점*: AST 기반 분석으로 메소드 호출, 상속/인터페이스 구현, 예외 처리를 정확히 파악해야 한다. `javalang`이나 Tree‑Sitter AST를 활용해 메소드 범위를 정확히 산정하고 호출 관계를 분석한다. SQL 사용 분석은 JDBC/MyBatis 호출 지점을 AST로 추적하여 테이블/열 레퍼런스를 수집하는 방식으로 개선해야 한다.

### 2.4 설정 및 기타 모듈

- **설정 파일(`config.yaml`)**: 파싱 옵션(스레드 수, 파일 확장자), DB 설정, confidence thresholds 등을 정의한다【792525783709665†L0-L39】. 그러나 코드에서 `confidence.weights` 등 일부 설정을 사용하지 않으며, 기본값과 문서가 불일치할 수 있다.
- **데이터베이스 모델(`database.py`)**: PRD에서 정의한 `projects`, `files`, `classes`, `methods`, `sql_units`, `db_tables`, `db_columns` 등 테이블이 구현되어 있다【301184611565164†L0-L62】. 그러나 PRD에서 언급한 `summaries`, `enrichment_logs`, `vulnerability_fixes` 등 추가 테이블은 아직 구현되어 있지 않다.
- **샘플 프로젝트**: `PROJECT/sample-app`은 분석기를 테스트하기 위한 예제이며, JSP 파일은 매우 간단하고 Java 모델/매퍼 클래스를 일부 생략하고 있어 실행 시 오류가 발생한다. 이 폴더는 분석 대상이 아니므로 검토에서 제외한다.

## 3. 종합 문제점 및 개선 제안

| 영역 | 문제점/누락 사항 | 개선 제안 |
|---|---|---|
| **문서/요구사항 대비 구현** | LLM 보강 로그, confidence 계산, RAG API, FAISS, vLLM 통합 등 PRD에 명시된 2단계 기능이 아직 구현되지 않음 | Roadmap에 따라 2단계 기능 구현을 우선순위화하고, DB 스키마에 `summaries`, `enrichment_logs`, `vulnerability_fixes` 테이블을 추가한다. |
| **파서 정확도** | javalang/regex 기반 파싱이 복잡한 Java/JSP/SQL 문법과 증분 분석을 지원하지 못함【577301401375971†L249-L259】 | Tree‑Sitter 기반 다국어 파서를 도입하여 증분 파싱과 최신 언어 기능을 지원하고, MyBatis와 PL/SQL은 ANTLR 기반 파서로 교체한다【319917287617580†L6-L16】. |
| **동시성/성능** | `metadata_engine`가 `thread_count` 설정을 지원하지만 실제로 병렬로 파싱하지 않음【727915244980752†L43-L45】 | `concurrent.futures.ThreadPoolExecutor`를 사용하여 파일별 파싱 작업을 병렬 실행하고, 입출력 병목을 줄인다. |
| **예외 처리 및 로깅** | 많은 곳에서 빈 `except:` 블록으로 오류를 숨긴다【727915244980752†L95-L156】 | 예외 종류를 명시하고 `logging` 모듈을 사용해 에러 메시지와 스택트레이스를 기록한다. |
| **데이터베이스 스키마 로더** | CSV를 한 번에 DataFrame으로 로드하고 기존 데이터를 모두 삭제 후 재삽입한다【304917513626599†L175-L203】 | 대용량 CSV에 대비해 chunk 단위 로딩, 증분 업데이트, 트랜잭션 처리, 로깅 개선이 필요하다. |
| **의존성 분석 정확도** | 메소드 호출 및 DB 사용 분석이 정규식 기반으로 부정확하고 `end_line` 값이 0으로 설정되어 있다【135694866599125†L82-L124】 | AST 기반 정적 분석으로 메소드 범위와 호출 관계를 정확히 추출하고, JDBC/MyBatis 호출 코드를 통해 테이블/컬럼 사용을 추적하는 로직을 구현한다. |
| **타입 안전성과 코드 품질** | Java 코드의 제네릭 미사용 (`List` 등 raw 타입), 모델 클래스 누락, JSP에서 scriptlet 사용 등 | Java 소스는 제네릭을 명시하고, 모델/매퍼 클래스를 완성한다. JSP는 JSTL/EL 표현식으로 대체하고 Thymeleaf 등 현대 템플릿 엔진으로 마이그레이션을 고려한다. |
| **테스트 커버리지** | 자동화된 테스트나 CI 설정이 없고, 샘플 프로젝트가 단순하여 에지 케이스를 확인하기 어렵다 | 파서/엔진/분석기의 단위 테스트를 작성하고 GitHub Actions 등으로 CI 파이프라인을 구축한다. 다양한 실제 프로젝트를 대상으로 검증한다. |
| **확장성 및 플러그인 아키텍처** | 현재 코드베이스는 Java/JSP/MyBatis/SQL에만 고정되어 있으며, 새로운 언어/프레임워크를 추가하기 어렵다 | 파서와 분석기를 플러그인 구조로 설계하여 언어별 모듈을 쉽게 추가하고, Tree‑Sitter/ANTLR grammar를 이용한 공통 인터페이스를 제공한다. |

## 4. 결론

`src-analyzer`는 PRD 1단계 요구사항(기본 메타정보 생성과 의존성 분석)을 어느 정도 구현하고 있다. 그러나 **파서 정확성, 동시성, 예외 처리, 데이터베이스 업데이트** 등의 측면에서 개선이 필요하며, PRD에 정의된 2단계 기능(LLM 보강, RAG API, PL/SQL 및 다언어 지원, 보안 취약점 분석 등)은 미구현 상태이다. 

향후 개발에서는 PRD와 `better.md`에서 제안하는 기술 스택(예: Tree‑Sitter, ANTLR, BGE‑M3+reranker, SAST 통합)을 적극 도입하고, 코드 품질 및 테스트 체계를 강화하여 신뢰도 높은 소스 분석 에이전트를 완성해야 한다.
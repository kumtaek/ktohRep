"""
Source Analyzer Web Dashboard - Backend API
FastAPI-based REST API with WebSocket support for real-time updates
"""

import sys
import os
import yaml
import logging
from datetime import datetime

# Add phase1/src to the Python path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'phase1', 'src')))

from flask import Flask, jsonify, request
from flask_cors import CORS
from database.metadata_engine import MetadataEngine
from models.database import DatabaseManager

def load_config():
    config_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'config', 'config.yaml'))
    with open(config_path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)

def setup_logging(config):
    log_level = config.get('logging', {}).get('level', 'INFO').upper()
    log_file = config.get('logging', {}).get('file', './logs/app.log')
    
    # Ensure log directory exists
    log_dir = os.path.dirname(log_file)
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)

    logging.basicConfig(
        level=getattr(logging, log_level),
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    )
    #logging.getLogger('werkzeug').setLevel(logging.WARNING) # Suppress Flask access logs
    #logging.getLogger('werkzeug2').setLevel(logging.DEBUG) # Suppress Flask access logs

config = load_config()
setup_logging(config)

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes
app.logger.setLevel(logging.DEBUG) # Set app logger to DEBUG

# Initialize MetadataEngine
db_path = config['database']['sqlite']['path']
db_manager = DatabaseManager(db_path) # Instantiate DatabaseManager
metadata_engine = MetadataEngine(config, db_manager) # Pass config and db_manager

@app.route('/')
def hello_world():
    return jsonify(message="Hello from SourceAnalyzer Backend!")

@app.route('/api/v1/projects/<project_id>/tasks/<task_id>', methods=['GET'])
def get_task(project_id, task_id):
    task = task_manager.show_task(project_id, task_id)
    if task:
        return jsonify(task)
    return jsonify({"error": "Task not found"}), 404

@app.route('/api/docs/owasp/A03', methods=['GET'])
def get_owasp_a03_doc():
    doc_path = os.path.join(app.root_path, '..', '..', 'docs', 'owasp', 'A03.md')
    try:
        with open(doc_path, 'r', encoding='utf-8') as f:
            content = f.read()
        return jsonify({"content": content})
    except FileNotFoundError:
        return jsonify({"error": "Document not found"}), 404
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/metadata/<int:file_id>', methods=['GET'])
def get_metadata_by_file_id(file_id):
    try:
        metadata = metadata_engine.get_metadata_by_file_id(file_id)
        if metadata:
            return jsonify(metadata)
        return jsonify(message="Metadata not found"), 404
    except Exception as e:
        app.logger.error(f"Error fetching metadata for file_id {file_id}: {e}")
        return jsonify(error=str(e)), 500

@app.route('/api/metadata/path', methods=['GET'])
def get_metadata_by_path():
    file_path = request.args.get('path')
    if not file_path:
        return jsonify(error="File path parameter is required"), 400
    try:
        metadata = metadata_engine.get_metadata_by_file_path(file_path)
        if metadata:
            return jsonify(metadata)
        return jsonify(message="Metadata not found"), 404
    except Exception as e:
        app.logger.error(f"Error fetching metadata for path {file_path}: {e}")
        return jsonify(error=str(e)), 500

@app.route('/api/scan', methods=['POST'])
def scan_project():
    data = request.get_json()
    project_path = data.get('project_path')
    if not project_path:
        return jsonify(error="Project path is required"), 400

    try:
        # This is a placeholder for the actual scanning logic
        # In a real scenario, you would trigger your scanner here
        # and return its status or results.
        app.logger.info(f"Scanning project: {project_path}")
        # Simulate a scan operation
        scan_result = {
            "status": "completed",
            "timestamp": datetime.now().isoformat(),
            "scanned_path": project_path,
            "findings": [] # Placeholder for actual findings
        }
        return jsonify(scan_result)
    except Exception as e:
        app.logger.error(f"Error during project scan for {project_path}: {e}")
        return jsonify(error=str(e)), 500

@app.route('/api/docs/<category>/<doc_id>', methods=['GET'])
def get_documentation(category, doc_id):
    doc_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', 'docs', category, f'{doc_id}.md'))
    
    app.logger.info(f"Attempting to access documentation at path: {doc_path}")

    if not os.path.exists(doc_path):
        app.logger.warning(f"Documentation file not found: {doc_path}")
        return jsonify(message="Documentation not found"), 404

    try:
        with open(doc_path, 'r', encoding='utf-8') as f:
            content = f.read()
        return jsonify(content=content)
    except Exception as e:
        app.logger.error(f"Error reading documentation file {doc_path}: {e}")
        return jsonify(error=str(e)), 500

if __name__ == '__main__':
    app.run(debug=True, port=8000)

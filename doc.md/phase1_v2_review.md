# 2차 개선 개발 후 검토 결과

본 보고서는 `PROJECT` 폴더를 제외한 분석 엔진 소스(`src` 및 `src‑analyzer` 하위 모듈)를 검토하여, 메타데이터 생성의 정확성을 높이기 위한 문제점과 개선 방안을 정리한 것이다. 기존 마크다운 문서의 세부 내용은 반복하지 않으며, 코드 수준에서의 문제와 해결책에 집중한다.

## 1. 발견된 문제점

### 1.1 JSP 및 MyBatis 파서의 한계

* **정규표현식 기반 JSP 파싱:** JSP 파서는 `<%` 스크립틀릿 내에서 SQL 키워드를 단순 검색하는 방식이다. 변수가 여러 단계로 조합되거나 JSTL/커스텀 태그를 통해 쿼리가 생성될 경우 SQL을 추적하지 못한다. 
* **동적 SQL의 조합 폭발:** MyBatis 파서는 `<if>`, `<choose>`, `<foreach>` 태그가 존재할 때 모든 가능한 분기를 superset으로 확장해 패턴을 매칭한다【279475327295474†L43-L45】. 조건과 반복자가 늘어날수록 경우의 수가 기하급수적으로 증가하여 성능과 정확성이 저하된다. 또한 `<trim>`과 `<set>`처럼 구문을 정리하는 태그는 무시되어 실행 쿼리와 차이가 발생한다.

### 1.2 메타데이터 엔진의 성능 및 안정성 문제

* **병렬 처리 미사용:** 설정에 `thread_count` 옵션이 있음에도 실제로는 단일 스레드로 파서를 호출한다. 대규모 프로젝트를 처리할 때 병목이 된다.
* **메모리 집약적 해시 계산:** 각 파일의 해시를 계산할 때 전체 파일을 한 번에 읽어 메모리 사용량이 증가한다【279475327295474†L55-L60】.
* **에러 처리 부재:** 예외 발생 시 `print`로 메시지를 출력하는 수준이며, 로그 레벨이나 실패 파일 목록을 제공하지 않는다. 이는 운영 환경에서 문제 진단을 어렵게 한다.

### 1.3 타입 안정성 문제

* **원시 타입 사용:** 서비스와 매퍼 계층에 여전히 `List`, `Map` 등 제네릭이 없는 타입이 남아 있다【850581595650110†L31-L33】【750176504135993†L20-L21】. 이러한 원시 타입은 분석 대상 코드의 반환값을 정확히 추론하는 것을 방해한다.

### 1.4 SQL 패턴 추출의 한계

* **정규표현식 한계:** `_extract_sql_patterns`는 JOIN 과 WHERE 절만 단순히 매칭한다. 서브쿼리, CTE, ANSI JOIN 등을 포함하는 복잡한 SQL에서는 필터와 조인을 정확히 추출하지 못한다. `IN` 절이나 복잡한 조건식의 필터 분리도 미흡하다.

### 1.5 의존성 분석의 불완전성

* **스프링 어노테이션 미처리:** Java 파서가 `@Service`, `@Repository`, `@Mapper` 등의 어노테이션을 인식하지 못해 의존 관계 그래프가 누락된다. 메서드 참조(`ClassName::method`)나 람다 표현식 내부 호출도 추적하지 않는다.

## 2. 개선 방안

### 2.1 파서 개선

* **정적 파서 도입:** JSP 코드의 AST를 생성할 수 있는 Tree‑Sitter나 ANTLR을 활용하여, 스크립틀릿 내부의 Java 코드를 정확히 파싱하고 SQL 문자열이 생성되는 경로를 추적한다. 
* **동적 SQL 분기 최적화:** 동적 태그를 전부 확장하는 대신, `<choose>`와 `<when>`에 대해 조건별 노드를 생성하고 `<foreach>`는 존재/비존재 두 가지 케이스로 제한하여 분기 수를 관리한다. `lxml`의 `iterparse` 기능을 이용해 XML 파싱 시 줄 번호와 위치를 기록한다.
* **SQL AST 분석:** JSqlParser나 sqlparse와 같은 라이브러리를 도입하여 SQL을 AST로 변환한 뒤 JOIN, 필터 조건, 서브쿼리 등을 구조적으로 추출한다.

### 2.2 메타데이터 엔진 개선

* **병렬 파싱 도입:** `concurrent.futures.ThreadPoolExecutor`를 사용해 파일 단위의 파싱 작업을 병렬로 실행한다. 스레드 수와 큐 크기는 설정 파일로 조정할 수 있도록 한다.
* **스트리밍 해시 계산:** `hashlib.sha256()` 객체에 파일을 블록 단위로 전달해 메모리 사용을 최소화하며 해시를 계산한다.
* **체계적 로깅:** `logging` 모듈을 사용하여 에러, 워닝, 디버그 수준으로 로그를 기록하고, 파싱에 실패한 파일 목록을 별도의 리포트로 제공한다.

### 2.3 타입과 의존성 분석 강화

* **제네릭 타입 적용:** 서비스/매퍼 인터페이스의 반환 타입과 매개변수에 제네릭을 명시하여 타입 안정성을 높인다. MyBatis XML의 `resultType`도 정확하게 기재한다.
* **스프링 DI 추적:** Java 파서에 어노테이션 인식 기능을 추가해 `@Autowired` 및 생성자 주입 관계를 메타데이터에 포함시키고, 람다식과 메서드 참조를 추적하여 실제 호출 경로를 정확하게 파악한다.

## 3. 결론

현재 2차 개선 후의 소스는 1차 개선에서 제시한 문제를 일부 해결하였지만, 정규표현식과 단순 패턴 기반 분석에 머물러 있어 메타정보 생성의 정확도와 성능이 제한된다. 위에 제시한 개선안을 적용하면 동적 SQL과 복잡한 호출 관계를 더 정확히 포착하고 대규모 프로젝트를 효율적으로 처리할 수 있을 것이다.

### 2.1 JSP/MyBatis 파서(`jsp_mybatis_parser.py`)

* **정규표현식 기반 JSP 파싱:** 현재 구현은 JSP 스크립틀릿 내부에서 `select`, `insert`, `update`, `delete` 키워드를 단순 검색해 SQL 단위(`SqlUnit`)를 추출한다. 그러나 JSP는 스크립틀릿 외에도 *JSTL*이나 커스텀 태그를 통해 SQL을 포함할 수 있고, 스크립틀릿 안에서도 문자열 결합으로 동적 쿼리를 생성하는 경우가 많다. 정규표현식만으로는 이러한 변형을 포착하기 어렵다. 
  * **개선안:** Tree‑Sitter 기반의 JSP/Java 파서를 도입하여 JSP의 HTML/스크립틀릿 구조를 AST로 변환하고, 스크립틀릿 내부 코드를 Java AST로 파싱한 뒤 SQL 생성 문맥을 추적한다. 이 방법은 쿼리 문자열을 변수에 저장하거나 메서드를 통해 조합하는 경우까지 추적할 수 있어 정확도가 향상된다. 

* **MyBatis 동적 SQL 처리:** 현재 코드는 `<if>`, `<choose>`, `<foreach>` 등 동적 태그를 탐지하면 모든 가능성을 superset으로 확장한 뒤 패턴 매칭을 수행한다【279475327295474†L43-L45】. 이 접근은 간단하지만 조건의 조합이 많을수록 무한히 확장되어 성능이 급격히 저하될 수 있다. 또한 `<trim>`이나 `<set>`과 같이 공백과 구문 연결을 조정하는 태그는 무시되어 결과 쿼리가 실제 실행 쿼리와 다를 수 있다. 
  * **개선안:** 동적 SQL을 DFA(결정적 유한 오토마타) 혹은 트리 구조로 표현하여 분기 조건에 따라 가능한 쿼리 패턴을 생성하는 알고리즘을 구현한다. 예를 들어 `<choose>` 내부의 `<when>` 조건별로 노드를 분리하고, `<foreach>`는 반복 대상의 존재 여부에 따라 0회 또는 n회 반복하는 두 가지 패턴을 생성하도록 한다. 이 방식은 조합 폭발을 줄이면서도 주요 SQL 패턴을 포착할 수 있다. 또한 `lxml`의 `iterparse`를 이용하여 태그 시작/종료 시점에 줄 번호를 기록하면 XML에서 보다 정확한 위치 정보를 제공할 수 있다.

### 2.2 메타데이터 엔진(`metadata_engine.py`)

* **병렬 파싱 미활용:** 설정 파일에는 `thread_count` 옵션이 존재하지만 실제 파싱은 단일 스레드로 실행된다. 대규모 프로젝트의 수천 개 파일을 처리할 때 병목이 된다. 
  * **개선안:** Python의 `concurrent.futures.ThreadPoolExecutor`를 사용하여 파일 단위로 병렬 파싱을 실행한다. 각 스레드는 파서의 `parse_file`을 호출하여 `File`, `SqlUnit`, `Edge` 객체를 생성하고, 스레드 간 결과를 안전하게 합쳐야 한다. 또한 큐의 크기나 스레드 수를 조절할 수 있도록 설정 파일을 활용한다.

* **해시 계산과 메모리 사용:** 파일 해시를 계산하기 위해 전체 내용을 `read()`로 읽어 `hashlib.sha256`에 넣는다【279475327295474†L55-L60】. 대용량 파일을 다룰 때 메모리 사용량과 속도가 저하된다. 
  * **개선안:** `hashlib.sha256()` 객체에 파일을 4KB 블록 단위로 반복해서 업데이트하는 방식으로 스트리밍 해시를 계산한다. 이렇게 하면 메모리 사용을 최소화하면서도 동일한 결과를 얻을 수 있다.

* **에러 처리와 로깅:** 현재 파서와 엔진 대부분이 예외 발생 시 `print`로 메시지를 출력하거나 비어있는 결과를 반환한다. 이런 처리 방식은 서비스 운영 환경에서 에러를 추적하기 어렵다. 
  * **개선안:** `logging` 모듈을 사용해 적절한 로그 레벨(DEBUG/INFO/WARNING/ERROR)을 지정하고, 실패한 파일 경로와 예외 스택을 기록한다. 파싱 실패한 파일 목록을 리포트로 제공하여 사용자가 후속 조치를 취할 수 있도록 한다. 

### 2.3 모델 및 파서 유틸리티 개선

* **제네릭 및 타입 안정성:** 서비스 계층과 매퍼 인터페이스에 아직 일부 원시 타입(`List`, `Map`)이 남아있다【850581595650110†L31-L33】【750176504135993†L20-L21】. 이는 메타데이터로 변환될 때 실제 리턴 타입을 정확히 알 수 없어 분석 정확도를 떨어뜨린다. 
  * **개선안:** 모든 리스트/맵 반환 타입에 제네릭 파라미터를 명시하고, DTO·모델 클래스에도 `Optional` 및 `List<String>` 같은 명확한 타입을 사용한다. MyBatis XML에서도 `resultType`을 정확하게 기재하여 파서가 타입 정보를 추론할 수 있게 한다.

* **필터/조인 추출 알고리즘:** 현재 `_extract_sql_patterns`는 정규표현식 기반으로 `JOIN`과 `WHERE` 절의 단순 패턴을 추출한다. 복잡한 서브쿼리나 ANSI JOIN 구문에서는 오류가 발생할 수 있다. 또한 `IN` 절이나 동적 `AND`/`OR` 조합에서 필터 조건을 제대로 분리하지 못한다. 
  * **개선안:** SQL을 표준 구문 트리로 변환하는 라이브러리(sqlparse, JSqlParser 등)를 활용하여 AST 기반으로 조인과 필터를 추출한다. AST는 서브쿼리, 중첩 SELECT, 공통 테이블 식별(CTE) 등 복잡한 SQL 구조를 계층적으로 표현해 주므로 메타데이터 추출의 정확성이 크게 향상된다. 

* **클래스/메서드 의존성 분석:** `dependency_analyzer.py`를 통해 클래스와 메서드, SQL 간 관계 그래프를 구축하지만, Service/Repository 계층 어노테이션(`@Service`, `@Repository`, `@Mapper`)을 인식하지 못해 의존 관계가 누락될 수 있다. 또한 람다식이나 스트림 API에서 호출되는 메서드는 분석 대상에서 제외되어 있다. 
  * **개선안:** Java 소스 파서에 어노테이션 인식 기능을 추가하여 스프링 DI 관계를 메타데이터에 포함시키고, 메서드 참조(`ClassName::method`)나 람다식 호출도 추적하도록 개선한다. 이는 실제 호출 경로를 더 정확히 파악하는 데 도움이 된다.

## 3. 종합 의견

1차 개선 이후에도 코어 파서와 메타데이터 엔진의 구조는 큰 변화가 없으며, 일부 서비스/매퍼 인터페이스에는 아직 원시 타입이 남아 있다. 동적 SQL 확장 방식과 정규표현식 중심 분석도 그대로이다. 2차 개선에서는 위에서 제시한 **정적 파서 도입**, **동적 SQL 분기 최적화**, **병렬 파싱**, **스트리밍 해시 계산**, **타입 안정성 강화**, **AST 기반 SQL/Java 분석** 등을 우선순위로 고려해야 한다. 이러한 개선은 메타데이터 추출의 정확성과 성능을 동시에 향상시키고, 향후 다양한 언어와 프레임워크를 지원하는 기반을 마련할 것이다.

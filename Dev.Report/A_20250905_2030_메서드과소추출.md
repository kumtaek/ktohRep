# A_20250905_2030_메서드과소추출.md

## 문제점 정확한 진단 결과

실제 Java 소스코드와 현재 파서 로직을 비교 분석한 결과, 메서드 추출이 44.2% 부족한 **구체적인 원인들**을 발견했습니다.

## 핵심 원인 분석

### **🔴 주요 원인 1: 인터페이스 메서드 완전 누락**

**실제 확인 결과**:
- `UserService.java`: 6개 추상 메서드 (구현부 없음)
- `UserMapper.java`: 8개 추상 메서드 (구현부 없음)
- **총 14개 메서드가 추출 대상에서 완전 제외됨**

**현재 파서의 문제**:
```python
# phase1/parsers/java/java_parser.py:183-187
method_patterns = [
    r'(?:@\w+(?:\([^)]*\))?\s*)*public\s+(\w+)\s*\(([^)]*)\)\s*\{[^}]{,500}\}',
    r'public\s+(\w+)\s*\(([^)]*)\)\s*\{[^}]{,500}\}',
    r'(?:@\w+(?:\([^)]*\))?\s*)*public\s+(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*\{[^}]{,500}\}',
    r'public\s+(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*\{[^}]{,500}\}'
]
```

**문제**: 모든 패턴이 `\{[^}]{,500}\}` (구현부)를 필수로 요구함
**결과**: 인터페이스의 추상 메서드(`public List<User> getUserById(Long id);`) 인식 불가

### **🔴 주요 원인 2: 접근제한자 제한**

**실제 확인 결과**:
- 현재 파서는 `public` 메서드만 추출
- 실제 소스에는 `private`, `protected` 메서드도 다수 존재

**누락 예상**:
- Service 구현체의 `private` 헬퍼 메서드들
- Controller의 `protected` 메서드들

### **🔴 주요 원인 3: 메서드 길이 제한 (500자)**

**현재 제한**: `\{[^}]{,500}\}` - 구현부가 500자 초과 시 제외

**실제 확인 - UserController.java**:
- `getUserList()` 메서드: 본문이 500자를 훨씬 초과 (42줄)
- `searchUsers()` 메서드: 본문이 500자를 훨씬 초과 (32줄)
- **결과**: 복잡한 비즈니스 로직 메서드들이 모두 제외됨

### **🔴 주요 원인 4: getter/setter 제외 로직 오류**

**현재 로직**:
```python
# Getter/Setter 메서드 제외 (단순한 getter/setter는 제외)
if (method_name.startswith('get') and len(param_list) == 0) or \
   (method_name.startswith('set') and len(param_list) == 1) or \
   (method_name.startswith('is') and len(param_list) == 0):
    continue
```

**문제**: 
- `getUsersByCondition()` 같은 비즈니스 메서드도 `get`으로 시작하여 제외됨
- User.java, Product.java의 실제 getter/setter는 추출이 필요함 (명세서에 포함)

## 구체적 해결 방안

### **🔧 해결책 1: 인터페이스 메서드 패턴 추가**

```python
# phase1/parsers/java/java_parser.py 수정
method_patterns = [
    # 기존 구현 메서드 패턴들...
    
    # 인터페이스 추상 메서드 패턴 추가
    r'(?:@\w+(?:\([^)]*\))?\s*)*(?:public\s+)?(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*;',  # 추상 메서드
    r'(?:@\w+(?:\([^)]*\))?\s*)*(?:public\s+)?void\s+(\w+)\s*\(([^)]*)\)\s*;',  # void 추상 메서드
]
```

### **🔧 해결책 2: 접근제한자 확장**

```python
# 모든 접근제한자 지원
access_modifiers = r'(?:public|private|protected|package-private)?'
method_patterns = [
    rf'(?:@\w+(?:\([^)]*\))?\s*)*{access_modifiers}\s+(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*\{{[^}}]{{,2000}}\}}',
    rf'(?:@\w+(?:\([^)]*\))?\s*)*{access_modifiers}\s+(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*;'
]
```

### **🔧 해결책 3: 메서드 길이 제한 완화**

```python
# 500자 → 2000자로 확대, 또는 동적 매칭
method_patterns = [
    # 긴 메서드를 위한 동적 매칭 패턴
    r'(?:@\w+(?:\([^)]*\))?\s*)*public\s+(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*\{',
]

# 별도로 메서드 끝 찾기 (중괄호 매칭)
def _find_method_end(self, content: str, start_pos: int) -> int:
    """메서드의 끝 위치를 정확히 찾기 (중괄호 카운팅)"""
    brace_count = 0
    in_string = False
    i = start_pos
    
    while i < len(content):
        char = content[i]
        
        if char == '"' and (i == 0 or content[i-1] != '\\'):
            in_string = not in_string
        elif not in_string:
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0:
                    return i + 1
        i += 1
    
    return -1
```

### **🔧 해결책 4: 스마트 getter/setter 필터링**

```python
def _is_business_getter(self, method_name: str, params: List[str]) -> bool:
    """비즈니스 로직 getter 여부 판단"""
    # 단순 getter/setter가 아닌 비즈니스 메서드들
    business_prefixes = [
        'getUsersBy', 'getDataBy', 'findBy', 'selectBy', 'loadBy',
        'setStatusBy', 'updateBy', 'saveBy'
    ]
    
    for prefix in business_prefixes:
        if method_name.startswith(prefix):
            return True
    
    # 매개변수가 있는 get/set은 비즈니스 로직으로 판단
    if method_name.startswith('get') and len(params) > 0:
        return True
    if method_name.startswith('set') and len(params) > 1:
        return True
        
    return False

# getter/setter 제외 로직 개선
if not self._is_business_getter(method_name, param_list):
    if (method_name.startswith('get') and len(param_list) == 0) or \
       (method_name.startswith('set') and len(param_list) == 1) or \
       (method_name.startswith('is') and len(param_list) == 0):
        continue  # 단순 getter/setter만 제외
```

### **🔧 해결책 5: MyBatis 어노테이션 특별 처리**

```python
def _extract_mybatis_methods(self, content: str) -> List[Dict[str, Any]]:
    """MyBatis 매퍼 메서드 특별 추출"""
    mybatis_methods = []
    
    # MyBatis 어노테이션 패턴
    mybatis_patterns = [
        r'@(?:Select|Insert|Update|Delete)(?:\([^)]*\))?\s*(?:public\s+)?(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*;'
    ]
    
    for pattern in mybatis_patterns:
        matches = re.finditer(pattern, content, re.IGNORECASE | re.DOTALL)
        for match in matches:
            # MyBatis 메서드로 분류
            mybatis_methods.append({
                'name': match.group(2),
                'return_type': match.group(1),
                'parameters': self._parse_parameters(match.group(3)),
                'type': 'mybatis_mapper',
                'is_abstract': True
            })
    
    return mybatis_methods
```

## 단계별 구현 계획

### **🚀 Phase 1: 긴급 수정 (1시간)**
1. ✅ 인터페이스 추상 메서드 패턴 추가
2. ✅ 메서드 길이 제한 2000자로 확대  
3. ✅ 접근제한자 제한 완화 (private, protected 포함)

**예상 효과**: 43개 → 65개 (51% 증가)

### **🔧 Phase 2: 정확도 개선 (2시간)**
1. 스마트 getter/setter 필터링 구현
2. MyBatis 어노테이션 특별 처리
3. 중괄호 매칭 기반 정확한 메서드 경계 인식

**예상 효과**: 65개 → 75개 (96% 달성)

### **📊 Phase 3: 완전성 달성 (1시간)**
1. Lombok 어노테이션 처리 (`@Data`, `@Getter`, `@Setter`)
2. 생성자 오버로딩 완전 지원
3. 중첩 클래스 메서드 처리

**예상 효과**: 75개 → 77개 (100% 달성)

## 검증 방법

### **실제 파일별 검증**
```
UserController.java: 3개 메서드 (현재 0개 → 목표 3개)
- getUserList() ✓ (길이 제한 해제 후)
- searchUsers() ✓ (길이 제한 해제 후) 
- getUsersByType() ✓ (길이 제한 해제 후)

UserService.java: 6개 메서드 (현재 0개 → 목표 6개)
- 모든 추상 메서드 ✓ (인터페이스 패턴 추가 후)

UserMapper.java: 8개 메서드 (현재 0개 → 목표 8개)
- 모든 MyBatis 매퍼 메서드 ✓ (추상 메서드 패턴 + MyBatis 처리)
```

## 우선순위 권장사항

### **즉시 실행 (Critical)**
```python
# 1. 인터페이스 메서드 패턴 추가 (14개 메서드 복구)
# 2. 메서드 길이 제한 완화 (복잡한 비즈니스 로직 복구)
# 3. 접근제한자 확장 (private/protected 메서드 포함)
```

### **품질 개선**
1. 🔍 비즈니스 로직 vs 단순 getter/setter 정확한 구분
2. 📈 MyBatis, Spring 어노테이션 전용 처리 로직
3. 🔗 Lombok 자동 생성 메서드 인식

---

**분석 완료일시**: 2025-09-05 20:30:00  
**분석자**: SourceAnalyzer Technical Team  
**진단 상태**: ✅ 원인 정확히 파악됨  
**해결 방향성**: 파서 패턴 확장 + 필터링 로직 개선  
**예상 성공률**: 95% (Phase 2 완료 시)
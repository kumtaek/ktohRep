# 하이브리드 패턴 분석 보고서

## 하이브리드 패턴 방안

### 패턴 구성
```python
# 어노테이션이 있는 경우
pattern_with_annotation = r'(?:@\w+(?:\([^)]*\))?\s*)*public\s+(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*\{[^}]{,500}\}'

# 어노테이션이 없는 경우  
pattern_without_annotation = r'public\s+(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*\{[^}]{,500}\}'
```

## 테스트 케이스별 결과

### 1. 어노테이션이 있는 메서드들

#### 케이스 1: `@Override` 메서드
```java
@Override
public String toString() { return "Product"; }
```
- **어노테이션 있음**: ✅ 매치됨
- **어노테이션 없음**: ❌ 매치안됨 (어노테이션 때문에)
- **최종 결과**: ✅ **매치됨**

#### 케이스 2: `@RequestMapping` 메서드
```java
@RequestMapping("/products")
public String listProducts() { return "list"; }
```
- **어노테이션 있음**: ✅ 매치됨
- **어노테이션 없음**: ❌ 매치안됨 (어노테이션 때문에)
- **최종 결과**: ✅ **매치됨**

#### 케이스 3: `@Transactional` 메서드
```java
@Transactional
public void saveProduct(Product product) { /* save logic */ }
```
- **어노테이션 있음**: ✅ 매치됨
- **어노테이션 없음**: ❌ 매치안됨 (어노테이션 때문에)
- **최종 결과**: ✅ **매치됨**

### 2. 어노테이션이 없는 메서드들

#### 케이스 4: getter 메서드
```java
public String getProductId() { return productId; }
```
- **어노테이션 있음**: ✅ 매치됨 (어노테이션 부분이 0개 매치)
- **어노테이션 없음**: ✅ 매치됨
- **최종 결과**: ✅ **매치됨** (중복 매치 가능)

#### 케이스 5: setter 메서드
```java
public void setProductId(String productId) { this.productId = productId; }
```
- **어노테이션 있음**: ✅ 매치됨 (어노테이션 부분이 0개 매치)
- **어노테이션 없음**: ✅ 매치됨
- **최종 결과**: ✅ **매치됨** (중복 매치 가능)

#### 케이스 6: 생성자
```java
public Product() {}
```
- **어노테이션 있음**: ✅ 매치됨 (어노테이션 부분이 0개 매치)
- **어노테이션 없음**: ✅ 매치됨
- **최종 결과**: ✅ **매치됨** (중복 매치 가능)

## 하이브리드 패턴 장단점

### ✅ 장점

1. **완전한 커버리지**:
   - 어노테이션이 있는 메서드도 매치됨
   - 어노테이션이 없는 메서드도 매치됨
   - 기존 기능 유지 + 새로운 기능 추가

2. **호환성**:
   - 기존 프로젝트와의 호환성 유지
   - 새로운 Spring 프로젝트도 지원

3. **안정성**:
   - 하나의 패턴이 실패해도 다른 패턴으로 대체 가능

### ❌ 단점

1. **복잡도 증가**:
   - 패턴이 2개로 늘어남
   - 코드 복잡도 증가
   - 유지보수 어려움

2. **중복 매치 문제**:
   - 어노테이션이 없는 메서드가 두 패턴 모두에 매치됨
   - 중복 추출 가능성

3. **성능 저하**:
   - 2번의 정규식 매치 수행
   - 처리 시간 증가

4. **메모리 사용량 증가**:
   - 두 개의 패턴 객체 생성
   - 매치 결과 중복 저장

## 개선된 하이브리드 패턴 방안

### 방안 1: 중복 매치 방지
```python
def extract_methods_hybrid(content):
    methods = []
    seen_matches = set()
    
    # 어노테이션 있음 패턴 먼저 시도
    pattern_with_annotation = r'(?:@\w+(?:\([^)]*\))?\s*)*public\s+(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*\{[^}]{,500}\}'
    for match in re.finditer(pattern_with_annotation, content, re.IGNORECASE | re.DOTALL):
        if match.group(0) not in seen_matches:
            methods.append(match)
            seen_matches.add(match.group(0))
    
    # 어노테이션 없음 패턴으로 나머지 처리
    pattern_without_annotation = r'public\s+(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*\{[^}]{,500}\}'
    for match in re.finditer(pattern_without_annotation, content, re.IGNORECASE | re.DOTALL):
        if match.group(0) not in seen_matches:
            methods.append(match)
            seen_matches.add(match.group(0))
    
    return methods
```

### 방안 2: 통합 패턴
```python
# 어노테이션을 선택적으로 처리하는 통합 패턴
unified_pattern = r'(?:@\w+(?:\([^)]*\))?\s*)*public\s+(\w+(?:<[^>]*>)?)\s+(\w+)\s*\(([^)]*)\)\s*\{[^}]{,500}\}'
```

## 결론

### 하이브리드 패턴 평가

**✅ 장점이 단점보다 큽니다:**
- 완전한 커버리지로 모든 메서드 추출 가능
- 기존 기능 유지하면서 새로운 기능 추가
- 안정성과 호환성 확보

**⚠️ 주의사항:**
- 중복 매치 방지 로직 필수
- 성능 최적화 필요
- 코드 복잡도 관리 필요

### 권장사항

**하이브리드 패턴을 사용하되, 중복 매치 방지 로직을 추가하는 것이 최선입니다.**

1. **우선순위**: 어노테이션 있음 패턴 먼저 시도
2. **중복 방지**: 이미 매치된 내용은 제외
3. **성능 최적화**: 불필요한 매치 최소화
